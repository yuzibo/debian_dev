From 7298b39d0c90533db11e9b88e1ecb6a854d5b6ae Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Emilio=20Cobos=20=C3=81lvarez?= <emilio@crisal.io>
Date: Tue, 29 Mar 2022 14:43:38 +0200
Subject: [PATCH] Update nix.

---
 .cargo/config.in                              |   10 -
 Cargo.lock                                    |   12 +-
 Cargo.toml                                    |    7 +-
 third_party/rust/alsa/Cargo.toml              |    2 +-
 third_party/rust/midir/Cargo.toml             |    2 +-
 .../rust/minidump_writer_linux/Cargo.toml     |    2 +-
 third_party/rust/nix/.cargo-checksum.json     |    2 +-
 third_party/rust/nix/CHANGELOG.md             |  495 ++++++-
 third_party/rust/nix/CONTRIBUTING.md          |  114 --
 third_party/rust/nix/CONVENTIONS.md           |   87 --
 third_party/rust/nix/Cargo.toml               |   48 +-
 third_party/rust/nix/README.md                |   35 +-
 third_party/rust/nix/build.rs                 |   12 -
 third_party/rust/nix/src/dir.rs               |  117 +-
 third_party/rust/nix/src/env.rs               |   65 +
 third_party/rust/nix/src/errno.rs             | 1044 +++++++++++--
 third_party/rust/nix/src/errno_dragonfly.c    |    3 -
 third_party/rust/nix/src/fcntl.rs             |  330 ++++-
 third_party/rust/nix/src/features.rs          |   24 +-
 third_party/rust/nix/src/ifaddrs.rs           |   29 +-
 third_party/rust/nix/src/kmod.rs              |   13 +-
 third_party/rust/nix/src/lib.rs               |  187 +--
 third_party/rust/nix/src/macros.rs            |  125 +-
 third_party/rust/nix/src/mount/bsd.rs         |  426 ++++++
 .../rust/nix/src/{mount.rs => mount/linux.rs} |   45 +-
 third_party/rust/nix/src/mount/mod.rs         |   21 +
 third_party/rust/nix/src/mqueue.rs            |   82 +-
 third_party/rust/nix/src/net/if_.rs           |  237 ++-
 third_party/rust/nix/src/poll.rs              |   62 +-
 third_party/rust/nix/src/pty.rs               |  136 +-
 third_party/rust/nix/src/sched.rs             |  175 ++-
 third_party/rust/nix/src/sys/aio.rs           |  840 +++++------
 third_party/rust/nix/src/sys/epoll.rs         |   10 +-
 third_party/rust/nix/src/sys/event.rs         |   69 +-
 third_party/rust/nix/src/sys/eventfd.rs       |    5 +-
 third_party/rust/nix/src/sys/inotify.rs       |   69 +-
 third_party/rust/nix/src/sys/ioctl/bsd.rs     |   11 +-
 third_party/rust/nix/src/sys/ioctl/linux.rs   |    3 +-
 third_party/rust/nix/src/sys/ioctl/mod.rs     |   16 +-
 third_party/rust/nix/src/sys/memfd.rs         |   33 +-
 third_party/rust/nix/src/sys/mman.rs          |  216 ++-
 third_party/rust/nix/src/sys/mod.rs           |   32 +-
 third_party/rust/nix/src/sys/personality.rs   |   70 +
 third_party/rust/nix/src/sys/pthread.rs       |   27 +-
 third_party/rust/nix/src/sys/ptrace/bsd.rs    |   42 +-
 third_party/rust/nix/src/sys/ptrace/linux.rs  |  211 ++-
 third_party/rust/nix/src/sys/quota.rs         |   18 +-
 third_party/rust/nix/src/sys/reboot.rs        |   12 +-
 third_party/rust/nix/src/sys/resource.rs      |  233 +++
 third_party/rust/nix/src/sys/select.rs        |  170 ++-
 third_party/rust/nix/src/sys/sendfile.rs      |   41 +-
 third_party/rust/nix/src/sys/signal.rs        |  534 +++++--
 third_party/rust/nix/src/sys/signalfd.rs      |   43 +-
 third_party/rust/nix/src/sys/socket/addr.rs   |  449 ++++--
 third_party/rust/nix/src/sys/socket/mod.rs    | 1172 +++++++++++----
 .../rust/nix/src/sys/socket/sockopt.rs        |  524 +++++--
 third_party/rust/nix/src/sys/stat.rs          |   83 +-
 third_party/rust/nix/src/sys/statfs.rs        |  270 ++--
 third_party/rust/nix/src/sys/statvfs.rs       |   27 +-
 third_party/rust/nix/src/sys/sysinfo.rs       |   21 +-
 third_party/rust/nix/src/sys/termios.rs       |  313 ++--
 third_party/rust/nix/src/sys/time.rs          |   93 +-
 third_party/rust/nix/src/sys/timerfd.rs       |  281 ++++
 third_party/rust/nix/src/sys/uio.rs           |   69 +-
 third_party/rust/nix/src/sys/utsname.rs       |   16 +-
 third_party/rust/nix/src/sys/wait.rs          |   67 +-
 third_party/rust/nix/src/time.rs              |  260 ++++
 third_party/rust/nix/src/ucontext.rs          |   26 +-
 third_party/rust/nix/src/unistd.rs            | 1292 ++++++++++++-----
 third_party/rust/nix/test/common/mod.rs       |  141 ++
 third_party/rust/nix/test/sys/mod.rs          |    9 +
 third_party/rust/nix/test/sys/test_aio.rs     |  288 ++--
 .../rust/nix/test/sys/test_aio_drop.rs        |    3 -
 third_party/rust/nix/test/sys/test_epoll.rs   |    5 +-
 third_party/rust/nix/test/sys/test_inotify.rs |    6 +-
 third_party/rust/nix/test/sys/test_ioctl.rs   |   93 +-
 .../nix/test/sys/test_lio_listio_resubmit.rs  |   31 +-
 third_party/rust/nix/test/sys/test_mman.rs    |   92 ++
 third_party/rust/nix/test/sys/test_pthread.rs |   11 +-
 third_party/rust/nix/test/sys/test_ptrace.rs  |  140 +-
 third_party/rust/nix/test/sys/test_select.rs  |   32 +-
 third_party/rust/nix/test/sys/test_signal.rs  |   43 +-
 .../rust/nix/test/sys/test_signalfd.rs        |    6 +-
 third_party/rust/nix/test/sys/test_socket.rs  | 1107 ++++++++++++--
 third_party/rust/nix/test/sys/test_sockopt.rs |  150 +-
 third_party/rust/nix/test/sys/test_termios.rs |   30 +-
 third_party/rust/nix/test/sys/test_timerfd.rs |   61 +
 third_party/rust/nix/test/sys/test_uio.rs     |   36 +-
 third_party/rust/nix/test/sys/test_wait.rs    |   25 +-
 third_party/rust/nix/test/test.rs             |   77 +-
 third_party/rust/nix/test/test_clearenv.rs    |    9 +
 third_party/rust/nix/test/test_dir.rs         |   28 +-
 third_party/rust/nix/test/test_fcntl.rs       |  352 ++++-
 third_party/rust/nix/test/test_kmod/mod.rs    |   60 +-
 third_party/rust/nix/test/test_mount.rs       |   12 +-
 third_party/rust/nix/test/test_mq.rs          |   53 +-
 third_party/rust/nix/test/test_net.rs         |    2 +-
 third_party/rust/nix/test/test_nmount.rs      |   51 +
 third_party/rust/nix/test/test_poll.rs        |   42 +-
 third_party/rust/nix/test/test_pty.rs         |  132 +-
 .../rust/nix/test/test_ptymaster_drop.rs      |   37 +-
 third_party/rust/nix/test/test_resource.rs    |   23 +
 third_party/rust/nix/test/test_sched.rs       |   32 +
 third_party/rust/nix/test/test_sendfile.rs    |   22 +
 third_party/rust/nix/test/test_stat.rs        |  144 +-
 third_party/rust/nix/test/test_time.rs        |   58 +
 third_party/rust/nix/test/test_unistd.rs      |  639 +++++++-
 107 files changed, 11802 insertions(+), 3897 deletions(-)
 delete mode 100644 third_party/rust/nix/CONTRIBUTING.md
 delete mode 100644 third_party/rust/nix/CONVENTIONS.md
 delete mode 100644 third_party/rust/nix/build.rs
 create mode 100644 third_party/rust/nix/src/env.rs
 delete mode 100644 third_party/rust/nix/src/errno_dragonfly.c
 create mode 100644 third_party/rust/nix/src/mount/bsd.rs
 rename third_party/rust/nix/src/{mount.rs => mount/linux.rs} (68%)
 create mode 100644 third_party/rust/nix/src/mount/mod.rs
 create mode 100644 third_party/rust/nix/src/sys/personality.rs
 create mode 100644 third_party/rust/nix/src/sys/resource.rs
 create mode 100644 third_party/rust/nix/src/sys/timerfd.rs
 create mode 100644 third_party/rust/nix/src/time.rs
 create mode 100644 third_party/rust/nix/test/common/mod.rs
 create mode 100644 third_party/rust/nix/test/sys/test_mman.rs
 create mode 100644 third_party/rust/nix/test/sys/test_timerfd.rs
 create mode 100644 third_party/rust/nix/test/test_clearenv.rs
 create mode 100644 third_party/rust/nix/test/test_nmount.rs
 create mode 100644 third_party/rust/nix/test/test_resource.rs
 create mode 100644 third_party/rust/nix/test/test_sched.rs
 create mode 100644 third_party/rust/nix/test/test_time.rs

diff --git a/.cargo/config.in b/.cargo/config.in
index 1c4008d9a49a8..5fd35bd131eee 100644
--- a/.cargo/config.in
+++ b/.cargo/config.in
@@ -7,11 +7,6 @@ git = "https://github.com/smol-rs/async-task"
 replace-with = "vendored-sources"
 rev = "f6488e35beccb26eb6e85847b02aa78a42cd3d0e"
 
-[source."https://github.com/msirringhaus/minidump_writer_linux.git"]
-git = "https://github.com/msirringhaus/minidump_writer_linux.git"
-replace-with = "vendored-sources"
-rev = "029ac0d54b237f27dc7d8d4e51bc0fb076e5e852"
-
 [source."https://github.com/mozilla/neqo"]
 git = "https://github.com/mozilla/neqo"
 replace-with = "vendored-sources"
@@ -22,11 +17,6 @@ git = "https://github.com/mozilla/mp4parse-rust"
 replace-with = "vendored-sources"
 rev = "3bfc47d9a571d0842676043ba60716318e946c06"
 
-[source."https://github.com/mozilla/midir.git"]
-git = "https://github.com/mozilla/midir.git"
-replace-with = "vendored-sources"
-rev = "4c11f0ffb5d6a10de4aff40a7b81218b33b94e6f"
-
 [source."https://github.com/mozilla/cubeb-pulse-rs"]
 git = "https://github.com/mozilla/cubeb-pulse-rs"
 replace-with = "vendored-sources"
diff --git a/Cargo.lock b/Cargo.lock
index 7ed4c0b49a76f..6bf1394b9c5bc 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -26,8 +26,6 @@ dependencies = [
 [[package]]
 name = "alsa"
 version = "0.4.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "eb213f6b3e4b1480a60931ca2035794aa67b73103d254715b1db7b70dcb3c934"
 dependencies = [
  "alsa-sys",
  "bitflags",
@@ -3112,7 +3110,6 @@ dependencies = [
 [[package]]
 name = "midir"
 version = "0.7.0"
-source = "git+https://github.com/mozilla/midir.git?rev=4c11f0ffb5d6a10de4aff40a7b81218b33b94e6f#4c11f0ffb5d6a10de4aff40a7b81218b33b94e6f"
 dependencies = [
  "alsa",
  "bitflags",
@@ -3155,7 +3152,6 @@ dependencies = [
 [[package]]
 name = "minidump_writer_linux"
 version = "0.1.0"
-source = "git+https://github.com/msirringhaus/minidump_writer_linux.git?rev=029ac0d54b237f27dc7d8d4e51bc0fb076e5e852#029ac0d54b237f27dc7d8d4e51bc0fb076e5e852"
 dependencies = [
  "byteorder",
  "goblin",
@@ -3565,15 +3561,15 @@ checksum = "e4a24736216ec316047a1fc4252e27dabb04218aa4a3f37c6e7ddbf1f9782b54"
 
 [[package]]
 name = "nix"
-version = "0.15.0"
+version = "0.23.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3b2e0b4f3320ed72aaedb9a5ac838690a8047c7b275da22711fddff4f8a14229"
+checksum = "9f866317acbd3a240710c63f065ffb1e4fd466259045ccb504130b7f668f35c6"
 dependencies = [
  "bitflags",
  "cc",
- "cfg-if 0.1.10",
+ "cfg-if 1.0.0",
  "libc",
- "void",
+ "memoffset 0.6.5",
 ]
 
 [[package]]
diff --git a/Cargo.toml b/Cargo.toml
index ea9e05ca80906..9f40db7307183 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -103,6 +103,10 @@ web-sys = { path = "build/rust/dummy-web/web-sys" }
 # Overrides to allow easier use of common internal crates.
 moz_asserts = { path = "mozglue/static/rust/moz_asserts" }
 
+# Update nix.
+alsa = { path = "third_party/rust/alsa" }
+midir = { path = "third_party/rust/midir" }
+
 # Other overrides
 async-task = { git = "https://github.com/smol-rs/async-task", rev="f6488e35beccb26eb6e85847b02aa78a42cd3d0e" }
 chardetng = { git = "https://github.com/hsivonen/chardetng", rev="3484d3e3ebdc8931493aa5df4d7ee9360a90e76b" }
@@ -110,8 +114,7 @@ chardetng_c = { git = "https://github.com/hsivonen/chardetng_c", rev="ed8a4c6f90
 coremidi = { git = "https://github.com/chris-zen/coremidi.git", rev="fc68464b5445caf111e41f643a2e69ccce0b4f83" }
 libudev-sys = { path = "dom/webauthn/libudev-sys" }
 packed_simd = { git = "https://github.com/hsivonen/packed_simd", rev="8b4bd7d8229660a749dbe419a57ea01df9de5453" }
-midir = { git = "https://github.com/mozilla/midir.git", rev = "4c11f0ffb5d6a10de4aff40a7b81218b33b94e6f" }
-minidump_writer_linux = { git = "https://github.com/msirringhaus/minidump_writer_linux.git", rev = "029ac0d54b237f27dc7d8d4e51bc0fb076e5e852" }
+minidump_writer_linux = { path = "third_party/rust/minidump_writer_linux" }
 
 # Patch mio 0.6 to use winapi 0.3 and miow 0.3, getting rid of winapi 0.2.
 # There is not going to be new version of mio 0.6, mio now being >= 0.7.11.
diff --git a/third_party/rust/alsa/Cargo.toml b/third_party/rust/alsa/Cargo.toml
index c7578fb0785b9..4dc6fc8707f24 100644
--- a/third_party/rust/alsa/Cargo.toml
+++ b/third_party/rust/alsa/Cargo.toml
@@ -32,7 +32,7 @@ version = "1.2.1"
 version = "0.2.65"
 
 [dependencies.nix]
-version = "0.15"
+version = "0.23"
 [badges.is-it-maintained-issue-resolution]
 repository = "diwic/alsa-rs"
 
diff --git a/third_party/rust/midir/Cargo.toml b/third_party/rust/midir/Cargo.toml
index 49089e0ffe86e..be0d98528419f 100644
--- a/third_party/rust/midir/Cargo.toml
+++ b/third_party/rust/midir/Cargo.toml
@@ -29,7 +29,7 @@ winrt = { version = "0.7.0", optional = true}
 
 [target.'cfg(target_os = "linux")'.dependencies]
 alsa = "0.4.3"
-nix = "0.15"
+nix = "0.23"
 libc = "0.2.21"
 
 [target.'cfg(target_os = "macos")'.dependencies]
diff --git a/third_party/rust/minidump_writer_linux/Cargo.toml b/third_party/rust/minidump_writer_linux/Cargo.toml
index 237afe6a694d1..a8eb7ce18f5d0 100644
--- a/third_party/rust/minidump_writer_linux/Cargo.toml
+++ b/third_party/rust/minidump_writer_linux/Cargo.toml
@@ -9,7 +9,7 @@ license = "MIT"
 
 [dependencies]
 tempfile = "3.1.0"
-nix = "0.15"
+nix = "0.23"
 libc = "0.2.74"
 memoffset = "0.5.1"
 byteorder = "1.3.2"
diff --git a/third_party/rust/nix/.cargo-checksum.json b/third_party/rust/nix/.cargo-checksum.json
index e5f2bc789185a..27737e6f172ca 100644
--- a/third_party/rust/nix/.cargo-checksum.json
+++ b/third_party/rust/nix/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{"CHANGELOG.md":"91af9fd5f2d9cdb9c8bb750e24b625742e95a6c74bcff419f3de70eb26578281","CONTRIBUTING.md":"a9101e3d1487170d691d5f062ff49a433c167582ac8984dd41a744be92652f74","CONVENTIONS.md":"e150ce43c1d188c392c1a3bf7f2e08e3cf84906705c7bef43f319037d29ea385","Cargo.toml":"af0cc0ae7ff4bf6c2e5b35fe062f54fe2d619f70ba67795f4f43a981420b5de0","LICENSE":"66e3ee1fa7f909ad3c612d556f2a0cdabcd809ad6e66f3b0605015ac64841b70","README.md":"80d71b9eaac7bf7f0d307372592ed1467f994291e6fad816a44f3c70e2887d0f","build.rs":"14c9c678c33f5894509da47f77d6a326b14aecb4190ce87a24cce98687ca63b2","src/dir.rs":"21e330cbe6594274335b94d9e9b6059f1fa8e53d2e5b5c697058c52ec6b3c5ff","src/errno.rs":"a009ccf18b45c0a4c9319c65b0dc5bc322d9ad43cfe462ec4661559f44162451","src/errno_dragonfly.c":"a857e47b114acb85fddcb252a610ab5734d225c26b7bedd7c35d7789d46c8526","src/fcntl.rs":"6ae2f7f01dd2568b82a4e57f86e02b1d63eec6c26111c5adb2ca5d78a2a99fe7","src/features.rs":"22ff626ff8287a07dd55bcfc63c9f518c19c56144e15f9b6f9e3bbdcda51c2a8","src/ifaddrs.rs":"9a93de176edcca4613e668b8ccc2c3e3b6b711aa2d8d94ccb0ba08694d1ef35f","src/kmod.rs":"4d8a695d3d761f351a39d654303a1bd168e74295b7d142b918737e355b24f34d","src/lib.rs":"fdd8049a79ffb92384c72f0a6b0bab717001ddfa9b01f2b33413c83f424f2ac8","src/macros.rs":"aec27fa0fd98900913fada926c9a4581cd28f2640e3a7b5480707f923c9200f8","src/mount.rs":"cdf5db8409017483132db9d7493b5d6cc96df5560d0fa5ad8f385aff72db10ca","src/mqueue.rs":"82af42b31381af73e7966f845d1ed93957f0b9976bf2da524b178fad15b2b08d","src/net/if_.rs":"f7e02076fcf3cadf3fdf141884c9bd2c468a7047ba60bc490f0057df802b53ce","src/net/mod.rs":"577f70170e53d4a6de1abb70bf8f1031ec3e65c0e63ef5fcf05c907125e7ac17","src/poll.rs":"7305e250066cd1a7318cd239ed3db787937ee98426fe9289cf00fa874d76b6c7","src/pty.rs":"6b965b586579933af47d4efef4c82c391b927037eaa08d8c83fc974ef17fc7c8","src/sched.rs":"f9b214fa60006b5450ffb3589a55ec59c3694bd49597c65c38ac813fcd96c7dd","src/sys/aio.rs":"a1ba629258b3ce1268e5fe8e5b41dce3581f77d415dc5e2455c1f82f26dd3085","src/sys/epoll.rs":"f0b539e0645569657f2142db91a38c94ebe1925f44852d64c61c818758dbbf0b","src/sys/event.rs":"ef8bc02a08d9ce7924c87f8f891fa051587b195a36913712fe85237a2fe0685b","src/sys/eventfd.rs":"08008cf3dc64c2216847c02c0dd8d7189cf08edbaafe35ba2c57c053fde09ef4","src/sys/inotify.rs":"687c8417d737939aa93f805d6003afc4f84f50828b1bd9429ef5d00bef0e0955","src/sys/ioctl/bsd.rs":"56ca6ecf5f7cfb566f4f3ba589fcc778f747a517dd45e13780981922e6215344","src/sys/ioctl/linux.rs":"6cfbdff4dbfa1a3782acdedebe89ffa9f000fdfc4ab68cb46f52890ebc1c6f2d","src/sys/ioctl/mod.rs":"20bc3cf1fcbbc7c31e4d507baa4e576a793ea42fb33618d2e7afeda730c4324f","src/sys/memfd.rs":"11cd93c867fdbdbc9588cecb94268691de42b2ef2a38fe33525be7c7f60c85d5","src/sys/mman.rs":"f77d28611a7ff3bf62784a3c4f26d7d79969395b1d9bbc6ff15e734f52dc404f","src/sys/mod.rs":"f39a08c72e37638c7cecfb9c087e0a41e2b69409aa545b0ef7bbd59c0a063ee2","src/sys/pthread.rs":"cfa9ccd6f3b86c0c3fe012773c9c82a7813b298c2f20f8ab629781db627ce56b","src/sys/ptrace/bsd.rs":"8a7eacfc172b55763ae32109bf9b252669ba68b72cd5122f7504eb35c0c08345","src/sys/ptrace/linux.rs":"f09b45148004f4b28d8503c397a8d112d31046c98e68335bf4e89425d5b33f07","src/sys/ptrace/mod.rs":"671a6ccac955e75d5998f7e53ffc45ed4c7b6522a0f24a0937d60141f692dd39","src/sys/quota.rs":"7eb8e797466b506f6ed882f18eda92c4639cf43d9384a19bc39cd1bf982989c9","src/sys/reboot.rs":"fde9da27c2928f7026231430fa14fec2058df4e49a0aeda2a237a60524f11241","src/sys/select.rs":"57d6c4403d1bf788bd52ab6f03cfc16a189d31b6bfb338b135cb775fe369121f","src/sys/sendfile.rs":"ea386e83baf9b5b23488aca26635aacdc92f2bfe238e4399a7380bd0331e0ef7","src/sys/signal.rs":"9216cdd609b4dfb9c2e559c411be6b7c722f7ddd8024682c0895a32126b488aa","src/sys/signalfd.rs":"bfcfce619bf199e50f9cc80a3eb778d48474a015cfdafc64a0c3517373a225a9","src/sys/socket/addr.rs":"8b297ce13cd8ad200b3e764888c26ceb582ee505385d1e172440de94ade99644","src/sys/socket/mod.rs":"e0353f04f3d098a8bf5e2aae431645897b96e0889fb76537dc0330159c6f233d","src/sys/socket/sockopt.rs":"c663505d6a7a7ae9d76e03fbc17e53d308ea6b1eae92212812e1d76b2bf2916f","src/sys/stat.rs":"c4807048f86be67026756737cf81f448ec23c2a4745776cb40f40b533a88e0c8","src/sys/statfs.rs":"d2b72069f20aa7782ce5de4ec2d00c76a82a92376c2066bbb270cdac2167719e","src/sys/statvfs.rs":"2d328cf525ba04ab1e1351128624a7df7d0c55ea91fda6c8d620d13710d61606","src/sys/sysinfo.rs":"0c05244655aa9e6dff5138392c5c1ae97630d35bae0e5510d7f51a75c31fd425","src/sys/termios.rs":"a2e99afdfc3526641a2cb82b57bfd0a25a362fb9be5ad37ff9f11acaeb0b9439","src/sys/time.rs":"8a1224b9262026086af698630aedbed21b45d661fbd045fc6c6af41a16a23374","src/sys/uio.rs":"60a974275ff8c485ea183bdd6f7e25894e6f2360a5bfb25442391a825a3b9b8c","src/sys/utsname.rs":"c977a1aec6e051c72b27506395e942abab9cbd9523e6d345ea66dc10875ee87d","src/sys/wait.rs":"30b14a8f518d031805cae6c6ff644116f162d8c8a75fddcfce4479d8d55fd1c0","src/ucontext.rs":"075560ec08a362881534211f8c6b78844886d6b767c2f7067174600e38ed3f63","src/unistd.rs":"82308ec31b6293b55f86fafd04e976a41127fedebb8f158abd1399c7399af947","test/sys/mod.rs":"e0821cbc289ad952f17229609c7de4282cca1e44cd13e1a7494a6378ecbc12f8","test/sys/test_aio.rs":"b2544bfb321ca7fbed276ee637c769fb438156d14666cdc1e1d547b3514a44e3","test/sys/test_aio_drop.rs":"30dd1d238269d00381fa50f6d3cb2b13794b7cceb9f6455f3878fcbffa9aa62d","test/sys/test_epoll.rs":"35093d0cb1096a934dfc4f6efc737eadc4bdc2e2134d2a879061374a51b10c97","test/sys/test_inotify.rs":"a4f804bcf414b6635d9863c8534769a609009c451c3476cc839cdc30c439b3b1","test/sys/test_ioctl.rs":"eea690ed386da0a666df5eb23a417421fddb99dc8e39556f63b30969bb6cf779","test/sys/test_lio_listio_resubmit.rs":"203a583313542593148f375b087ae30620222a745680173fa98fc448d1e5ae7f","test/sys/test_pthread.rs":"3890e5ecbf2082e0d05d102cc9cec6e76ede3c15f250d104e3483b1c1c3400b1","test/sys/test_ptrace.rs":"4e8d5dff5fe6bc56e4ae53bdfd10f5e8ea567d8099576d1c690cf7a6b2bc955f","test/sys/test_select.rs":"bdb20211fc6ec1e3f186337eac51e08757acb6901d307d67c71bf9011f0d54bd","test/sys/test_signal.rs":"84ae63c2baa49eebeabe5bbd347b9c5417e14ba97f342719d753dc1c1c768d60","test/sys/test_signalfd.rs":"71b5d6d782283f6db64ca90f7fb06617faec71091d59d2587e41bbc9d8c43d5c","test/sys/test_socket.rs":"09a7ef0322e07b4579893e0307a7c4f81fbbc653d005b827a519c33a33e185ce","test/sys/test_sockopt.rs":"b3d386c8279f86bf9439c772317bafcdba5630fa806c8319e87ddac0ccfa3a03","test/sys/test_sysinfo.rs":"1e1bea9130fe38ccb07cd0ad7334c7be1e45efc33f7656a5973f8cad7126f225","test/sys/test_termios.rs":"fa4be3ade859b527bf33408f85a6f57b127917cf5f2afb662d09f6019d07913a","test/sys/test_uio.rs":"9da234e3bd5003fd200cc37c4a5be147ecda1a7670feb1d505f23d646d3e1c57","test/sys/test_wait.rs":"e6c5147e213daa93892cd828f53214995d2e019ff2372cc48d85ce9b93d26ec9","test/test.rs":"e6307f82a39426a949b8e925a2df4a62e31c0e43081d7a33d23759bdfeeece1f","test/test_dir.rs":"5d137a62f11d1a4993b4bb35dccc38a4c4416b7da374887f2335a9895b4fdee4","test/test_fcntl.rs":"730e64e99dc867ba5af7cc4ca83a4489c8b96b1a52f8937bcc666d673af27002","test/test_kmod/hello_mod/Makefile":"0219f7bce0603f97d997fb377ca071966c90333ecc665e78a54dfeb97a9c811b","test/test_kmod/hello_mod/hello.c":"bcac6b19c5bd807e1f3878c15e426acc85785a8ade9840c3bb4d068635c9188c","test/test_kmod/mod.rs":"f4754f028402a8ba788c87686288424cd3784e77c7eb5d96682ef491b1dd5262","test/test_mount.rs":"78ddc657f5098360c764fffa3a7d844503e4b6b65b44bfd42d9aa9045b415cb6","test/test_mq.rs":"5806f8825e91edc79dd0e2bc81d8be3ba094c2de6c0b2ac0268221ae2ad22701","test/test_net.rs":"ec6d580b87292519d514b0236bdd5abdd576fcf4835cfe49ed1ddb47c5f1aea3","test/test_nix_path.rs":"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855","test/test_poll.rs":"46c71ee988fe1b85561ea0530d099750be8c1b8f95ab6e845c8a9f46f16f060c","test/test_pty.rs":"be04f99904fa47b60400c2bd156a388b73df4b9aec2eebf13df7dcdfc9aacf45","test/test_ptymaster_drop.rs":"5cfbbb79551c205ab510c2d4ef497bf937ceac9151fbe2f2e543d6515e406990","test/test_sendfile.rs":"e0cbabbd34052ccaa03d6555d5631686aa076728f6378ee90f7ecec68f891144","test/test_stat.rs":"1dc420d3119bf4d863a7ae0ba63efa7f1416f6e46e4100ea161003fe1c3f66ba","test/test_unistd.rs":"0325c998acca1e826e9e2b3d351d55ab9723a6cb2ca2072245978e7f5a9acee8"},"package":"3b2e0b4f3320ed72aaedb9a5ac838690a8047c7b275da22711fddff4f8a14229"}
\ No newline at end of file
+{"files":{"CHANGELOG.md":"0f61d921a725184e0b751fafe4facf309f66f51e6ec008ed4a155aab7d6f5fd7","Cargo.toml":"a355ac1778ff0fac880a96f375ff267c3f60df6a961c245339dd2664e0f9c294","LICENSE":"66e3ee1fa7f909ad3c612d556f2a0cdabcd809ad6e66f3b0605015ac64841b70","README.md":"a025a45d01d256e4dff5445f84c9ab81e510f17d5c491dd0e88372cd0f738076","src/dir.rs":"87accca507d4023d2f040101aed2b1684dc6dba81c09c7efb068c0b6ea0dfd78","src/env.rs":"3657fb51d8569ed525787e22cd2adb0ea5eb250d27641cfb8926be6908be4f38","src/errno.rs":"dfd94a76ced3cb3c2d12db4e4ea557a8123361d6d5d0577c1588425067b87957","src/fcntl.rs":"f43d5bd24238686f57766023be3421c64ec03c40cdcab77ebe635320e4818130","src/features.rs":"939e9512b4cf4192e18b7ba6557896c8a65f26bbbe78361e786e50bfd06168fb","src/ifaddrs.rs":"4f19ed3b15f5059c2859958c6aa313d6fa75703e68f8608359ef8e0089508ed3","src/kmod.rs":"9031edb7b0a8ed1d6635163c9c32490537d5c204e9794cce9dc2db24ead60957","src/lib.rs":"50820d5cdb642823f80b14622e29a47bcc36b9983c5884bbb23376fb7eeb4229","src/macros.rs":"49577415d703c089bf45f352b0da8c796dc5173fbe85329b8d8070c987ed6019","src/mount/bsd.rs":"37790209392c66105704986905f12b05215fcf1595c23ca4f16a8af93e55c0b8","src/mount/linux.rs":"cb82f6be7fb1cf131ee89b65dfa0d30df853fe934ff3bb2c9f7fe65f56bd2a21","src/mount/mod.rs":"6929135b12505c270cc2253fcabdae0d4cc92191b2171cf62645e7ec93cf5157","src/mqueue.rs":"2551fb14e10482dbb6db187f02794be613d207074fd8953caf27088aa4f880b7","src/net/if_.rs":"4b797a75d1c20fa53ae9ccea86fa421342c468a7e8ff737a129ab831464169d2","src/net/mod.rs":"577f70170e53d4a6de1abb70bf8f1031ec3e65c0e63ef5fcf05c907125e7ac17","src/poll.rs":"a3d4c17ed046d838e0cb55051d93f6d5585f73934fe1dfcb94e422735fc051ef","src/pty.rs":"dc9c19d91c176f41548bdde9a79f0663b01115688f474542c48f6736c433a709","src/sched.rs":"fcfb4f8886931a8aeeb5ac957956a19ba43dfa75d7fb473d7e8d7c8c0b173054","src/sys/aio.rs":"3e499c53bb3f1f62851543a307f22e552f0b3c971a06ca36c98a14645236e6c3","src/sys/epoll.rs":"11582831df3fa13e2f1f7fc024c1d5142a8dbfb94f6ab9b206e40e025f4a9106","src/sys/event.rs":"5768b2fed5cf8952b76c2292a0e9625b355a605b7276b1604459f01d1462b588","src/sys/eventfd.rs":"bc8009f19e8b93b03d0202896e10bd08497f34e2987bb8ce864d6cde11eab892","src/sys/inotify.rs":"5f970799355fe395cdcc81fcffab9b62eeb79f1127f935e76f51a8e0a59083e6","src/sys/ioctl/bsd.rs":"76acf6de6c9e2cd9367835f1b97815120e4baede4c2200661f396be4e4eb800e","src/sys/ioctl/linux.rs":"642b25d3997518815dea454fa976e9067ad5fe4ed75622e7540e3f0d0c7d320a","src/sys/ioctl/mod.rs":"6341f40c37227c77ca4bbb1864e60f99c43898eeaaf05ebb5132be1129550f4b","src/sys/memfd.rs":"72a153df4da17ea0cc4ce90ee3c47c5bec24c6e32fbb4ee7c77c1a89d79efbdd","src/sys/mman.rs":"8c519c52194c2928d93f0f33159b09fdfa420522b5a48fc84cbe2689db5424a0","src/sys/mod.rs":"21df0a582abff77c5706f01667e3aed97385a1b8c6cb8bb7e8678323c3ca31ec","src/sys/personality.rs":"1ce33010f0b8343f8f3167d3c7905a9a1e43c656e5db4043072bf0dd411cdeba","src/sys/pthread.rs":"a0e57ebb60463bf7e62536cccfe6ab352a7e8d5d99004837e29fe10ae91a13c4","src/sys/ptrace/bsd.rs":"0b9293cf21f23a790fd5c0e8744e31826d229e320603de782d7bb6fd4aaede33","src/sys/ptrace/linux.rs":"fc36f737463d001c47ba7830909eb458a18ecf4a5e33d59447a921e5d5fb6ae7","src/sys/ptrace/mod.rs":"671a6ccac955e75d5998f7e53ffc45ed4c7b6522a0f24a0937d60141f692dd39","src/sys/quota.rs":"1b60c34302e6fad9422fe0bec9fe7e6b93fbe554b8cfe98ecf5834daf93c84de","src/sys/reboot.rs":"865310ee46951a49e51ec368f854368faa9eb1dcead51280aa758e125294d672","src/sys/resource.rs":"c1a8fc95d8dc239e5be1a11ab690a053abdbd7ead42e1f1e4f83e822f8b81867","src/sys/select.rs":"4f0e476faa4447bb59f795e71b28f9440c17396429af05ac6dc67ed78104a292","src/sys/sendfile.rs":"8858c15b27e5bf3acb6b6c2740fc5e3cad057293c6e65314b949e4c2273c7fb5","src/sys/signal.rs":"b3855c93ddc1f9d415d7e2b6ca870c3ac225496ffdf085f6a6e95e2c49017d9b","src/sys/signalfd.rs":"2677af132b9f01ec277615a5d039f49fbdd06dc4442639df668561b74b9785c4","src/sys/socket/addr.rs":"b1003c0b6dbe7c1b1a76a5882a43a6ae6bbffa7d587d27fab00e8334693e1a83","src/sys/socket/mod.rs":"281f12673fa136da83ecd9a0c4361a94ff96894c83077246081fedb40fac4645","src/sys/socket/sockopt.rs":"b894b009a07935a3236a3fb7e159a0fb67f5e2fd1c7c61264948d1022f0ddb80","src/sys/stat.rs":"7c7bd8e895040b0f05a7eee3d8ab559566262ebdae711cb19ca8f19dd16d93c6","src/sys/statfs.rs":"dd14609e60bca2d09b84c10a9b7ba28d35ca7df529a94e62b0f7c5bfe4203eb6","src/sys/statvfs.rs":"1b27b88ef4bdd33a5005519e5e263d6b929980746d49e2768d9dba5466ce1138","src/sys/sysinfo.rs":"7ff86d7848c2e8ded13b47dc53bf24cb0f4d7f3ded634d6d2f34558a2511ed99","src/sys/termios.rs":"ef1926cd1db964ebeb33775aa9f219506a11be22df499d2479eb3c4aa91b7753","src/sys/time.rs":"6ff8a79d143332995060b40b5bdf9596a03ed4b9195183d2331787394d6e389d","src/sys/timerfd.rs":"1ea212abc30742e99fe280e294cdab7ac182336f86e874d19b128a1413945365","src/sys/uio.rs":"92be85585382a45a24db7c82bc79983df5c8ccc8889f191494dfcf8d5b6a7daf","src/sys/utsname.rs":"f7d02dda48a328d733677d40984227441090efa5ad4865c1c43552735a43d13e","src/sys/wait.rs":"6acfb219db9f5b36577b36b12071dd7d671c0d23cd731e3549017fd59d9c479e","src/time.rs":"bf585149bc0c2df2d94acd5658ea821493adb1afa8b0c6011ae301e3ead104de","src/ucontext.rs":"863d783443be1307477daf1970a42594d17d637aba94c8e5b63d5d9a49ea624b","src/unistd.rs":"4bdf24d32c4d5cfd2a25140d4cf3e93761f80df4a94610cd27cdbf277694cb86","test/common/mod.rs":"89c8980966aa17a8d3f5872b44648f1541276e2331854203d327f7f36c86ee77","test/sys/mod.rs":"3f71863e16193521cc366b2daf21e56365a30208f0b2f117844f68c2e1404636","test/sys/test_aio.rs":"414af194f06b35b83a692e3569801f2c6b7999ba7b55b59f006091902e00146e","test/sys/test_aio_drop.rs":"b05b58b3fc5253f389e1869ee6fc3833701572fb68ed57bf79237080dac3125d","test/sys/test_epoll.rs":"c982bd8fa90c615a6f11de2c816b4553e11171dbbdd8db0944166fb044221a16","test/sys/test_inotify.rs":"dc3e4fe548b0b3b71f94c9bfc157c21b017f5ce8df9dee599849f3bfe7c222bb","test/sys/test_ioctl.rs":"b809085aca01c351380b3ab650153d3800f7271391e090b6f2d6dc9186ee50f4","test/sys/test_lio_listio_resubmit.rs":"436135fce2d2e55cfc9a3a18d43ca15018feb1a51b870eed56dff2f734b9c059","test/sys/test_mman.rs":"d149493cad917afaa7fcba8c74c42f3ba22420099917818399b8af1305a8e00b","test/sys/test_pthread.rs":"4be4a467ead0633429157c1b2191eb28962c5670aeb2ad6fe872acb95c336129","test/sys/test_ptrace.rs":"71634c3405ddb37c241a3cebe60c11516b95b82d29adaf13182bb36d0b50c6cb","test/sys/test_select.rs":"913ee0569c539fbf8f8d87678cec7ceb9d5529c184e72af845c8076b099b7d29","test/sys/test_signal.rs":"619aeb586309ffd2547b22c37475bb8cf6e88717c4cc114df72f6786b14de1f3","test/sys/test_signalfd.rs":"cccba36d0aba74178d78571dbd728448c8c23aba9063ad5ee24c7d89d01429c6","test/sys/test_socket.rs":"ec6d34cf06d1c52c32ba1bc5c13cd837968738f6268d976d136d7cc6128b9a26","test/sys/test_sockopt.rs":"ae74873a34be764c20c358a73002c10447b9f79055475f7c109d9f6f29c2bd72","test/sys/test_sysinfo.rs":"1e1bea9130fe38ccb07cd0ad7334c7be1e45efc33f7656a5973f8cad7126f225","test/sys/test_termios.rs":"9a9fb30655f418b59851edc9a9763f0fa1a97faaa5310989d9fa9a5c21add111","test/sys/test_timerfd.rs":"fcada956abd981e4d846da58e5640c5705b16026d47bccd1d603fae765ad10db","test/sys/test_uio.rs":"88a9616172beb9ed63021ec19aadf7c439d6f2fc42548fa265c4c7df8f65085f","test/sys/test_wait.rs":"ba95237600e1b825f09a3976219787a5041c6ba12296640070fd1244b9533539","test/test.rs":"8b6834fd1627d81f5bb5de3eef628b8e04e6b1bbed5e2c6947e25af921b7c65f","test/test_clearenv.rs":"45ca548035b3c20ec87314715feaba2be973709a635d85b8cde46fd1d9f1ecd4","test/test_dir.rs":"837d1666d6c48da3ae9f172fa32a497e0d61af94f1e5335c2afd16eafd6b1989","test/test_fcntl.rs":"04479bb8c082860481c9833911cb28fe4a62d35e1e0b283be045e2e53642ae5d","test/test_kmod/hello_mod/Makefile":"0219f7bce0603f97d997fb377ca071966c90333ecc665e78a54dfeb97a9c811b","test/test_kmod/hello_mod/hello.c":"bcac6b19c5bd807e1f3878c15e426acc85785a8ade9840c3bb4d068635c9188c","test/test_kmod/mod.rs":"58ac2bfb788480833d0bab990177324a405bd56d980edc222807acfb12ef23cf","test/test_mount.rs":"fc3fb51f4e7262dd8424e183e07919b378d5996b021544471b7cb1b3f9ad945f","test/test_mq.rs":"d9032902fcab0a69574ba09dd7fa9fa7db60cb1a1dd875124461276547dbdae5","test/test_net.rs":"d027680cdb1e2eed9e6912267b42a30cc0d81399826e03abfd7de81296a88282","test/test_nix_path.rs":"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855","test/test_nmount.rs":"26ecb0c687d9403e2d34d8e67733ddeeba7b4820f886ffa14e75f05ec4de38ea","test/test_poll.rs":"7c7ca94669c7879ee73d793a0261b27904b80c0bb380a5b5acdd4960c9c1aba5","test/test_pty.rs":"7cbc9a5c49fda499b957ef428e29f2c898aa772a9999c1a694f40f52a5a291bf","test/test_ptymaster_drop.rs":"48ae888ff4573c68e4da7d1fa737374deb307afb64deff2d788d1e0c81a11112","test/test_resource.rs":"569b95e16e84ab42a93ff9268bbb8545397408cbac17feb104a9559e8b0798ef","test/test_sched.rs":"f8ad92eb554164b0f92428f716db99040186d741cc6e1976f7930f099652f70c","test/test_sendfile.rs":"31d3f4982fe73610e216d9c332342b98c2c21de34b933744bfb3193d17376764","test/test_stat.rs":"c5358407e345bba02b827e2a3bd622bde4ec064dfdd5516b1b74561ad3e8dda5","test/test_time.rs":"bf668b680db81e443fb402a2580425553329636cd39fad70b828041ea894b43a","test/test_unistd.rs":"72a555c71232592de6a3799e11432e1eb73e0477dbf737868c1232e90aca822c"},"package":"9f866317acbd3a240710c63f065ffb1e4fd466259045ccb504130b7f668f35c6"}
\ No newline at end of file
diff --git a/third_party/rust/nix/CHANGELOG.md b/third_party/rust/nix/CHANGELOG.md
index d93a5ce6bbfc9..77d5b2a3268ab 100644
--- a/third_party/rust/nix/CHANGELOG.md
+++ b/third_party/rust/nix/CHANGELOG.md
@@ -1,14 +1,505 @@
 # Change Log
 
 All notable changes to this project will be documented in this file.
-This project adheres to [Semantic Versioning](http://semver.org/).
+This project adheres to [Semantic Versioning](https://semver.org/).
 
-## [Unreleased] - ReleaseDate
+## [0.23.1] - 2021-12-16
+
+### Added
+### Changed
+
+- Relaxed the bitflags requirement from 1.3.1 to 1.1.  This partially reverts
+  #1492.  From now on, the MSRV is not guaranteed to work with all versions of
+  all dependencies, just with some version of all dependencies.
+  (#[1607](https://github.com/nix-rust/nix/pull/1607))
+
+### Fixed
+
+- Fixed soundness issues in `FdSet::insert`, `FdSet::remove`, and
+  `FdSet::contains` involving file descriptors outside of the range
+  `0..FD_SETSIZE`.
+  (#[1575](https://github.com/nix-rust/nix/pull/1575))
+
+### Removed
+
+## [0.23.0] - 2021-09-28
+### Added
+
+- Added the `LocalPeerCred` sockopt.
+  (#[1482](https://github.com/nix-rust/nix/pull/1482))
+- Added `TimeSpec::from_duration` and `TimeSpec::from_timespec`
+  (#[1465](https://github.com/nix-rust/nix/pull/1465))
+- Added `IPV6_V6ONLY` sockopt.
+  (#[1470](https://github.com/nix-rust/nix/pull/1470))
+- Added `impl From<User> for libc::passwd` trait implementation to convert a `User`
+  into a `libc::passwd`. Consumes the `User` struct to give ownership over
+  the member pointers.
+  (#[1471](https://github.com/nix-rust/nix/pull/1471))
+- Added `pthread_kill`.
+  (#[1472](https://github.com/nix-rust/nix/pull/1472))
+- Added `mknodat`.
+  (#[1473](https://github.com/nix-rust/nix/pull/1473))
+- Added `setrlimit` and `getrlimit`.
+  (#[1302](https://github.com/nix-rust/nix/pull/1302))
+- Added `ptrace::interrupt` method for platforms that support `PTRACE_INTERRUPT`
+  (#[1422](https://github.com/nix-rust/nix/pull/1422))
+- Added `IP6T_SO_ORIGINAL_DST` sockopt.
+  (#[1490](https://github.com/nix-rust/nix/pull/1490))
+- Added the `PTRACE_EVENT_STOP` variant to the `sys::ptrace::Event` enum
+  (#[1335](https://github.com/nix-rust/nix/pull/1335))
+- Exposed `SockAddr::from_raw_sockaddr`
+  (#[1447](https://github.com/nix-rust/nix/pull/1447))
+- Added `TcpRepair`
+  (#[1503](https://github.com/nix-rust/nix/pull/1503))
+- Enabled `pwritev` and `preadv` for more operating systems.
+  (#[1511](https://github.com/nix-rust/nix/pull/1511))
+- Added support for `TCP_MAXSEG` TCP Maximum Segment Size socket options
+  (#[1292](https://github.com/nix-rust/nix/pull/1292))
+- Added `Ipv4RecvErr` and `Ipv6RecvErr` sockopts and associated control messages.
+  (#[1514](https://github.com/nix-rust/nix/pull/1514))
+- Added `AsRawFd` implementation on `PollFd`.
+  (#[1516](https://github.com/nix-rust/nix/pull/1516))
+- Added `Ipv4Ttl` and `Ipv6Ttl` sockopts.
+  (#[1515](https://github.com/nix-rust/nix/pull/1515))
+- Added `MAP_EXCL`, `MAP_ALIGNED_SUPER`, and `MAP_CONCEAL` mmap flags, and
+  exposed `MAP_ANONYMOUS` for all operating systems.
+  (#[1522](https://github.com/nix-rust/nix/pull/1522))
+  (#[1525](https://github.com/nix-rust/nix/pull/1525))
+  (#[1531](https://github.com/nix-rust/nix/pull/1531))
+  (#[1534](https://github.com/nix-rust/nix/pull/1534))
+- Added read/write accessors for 'events' on `PollFd`.
+  (#[1517](https://github.com/nix-rust/nix/pull/1517))
+
+### Changed
+
+- `FdSet::{contains, highest, fds}` no longer require a mutable reference.
+  (#[1464](https://github.com/nix-rust/nix/pull/1464))
+- `User::gecos` and corresponding `libc::passwd::pw_gecos` are supported on
+  64-bit Android, change conditional compilation to include the field in
+  64-bit Android builds
+  (#[1471](https://github.com/nix-rust/nix/pull/1471))
+- `eventfd`s are supported on Android, change conditional compilation to
+  include `sys::eventfd::eventfd` and `sys::eventfd::EfdFlags`for Android
+  builds.
+  (#[1481](https://github.com/nix-rust/nix/pull/1481))
+- Most enums that come from C, for example `Errno`, are now marked as
+  `#[non_exhaustive]`.
+  (#[1474](https://github.com/nix-rust/nix/pull/1474))
+- Many more functions, mostly contructors, are now `const`.
+  (#[1476](https://github.com/nix-rust/nix/pull/1476))
+  (#[1492](https://github.com/nix-rust/nix/pull/1492))
+- `sys::event::KEvent::filter` now returns a `Result` instead of being
+  infalliable.  The only cases where it will now return an error are cases
+  where it previously would've had undefined behavior.
+  (#[1484](https://github.com/nix-rust/nix/pull/1484))
+- Minimum supported Rust version is now 1.46.0.
+  ([#1492](https://github.com/nix-rust/nix/pull/1492))
+- Rework `UnixAddr` to encapsulate internals better in order to fix soundness
+  issues. No longer allows creating a `UnixAddr` from a raw `sockaddr_un`.
+  ([#1496](https://github.com/nix-rust/nix/pull/1496))
+- Raised bitflags to 1.3.0 and the MSRV to 1.46.0.
+  ([#1492](https://github.com/nix-rust/nix/pull/1492))
+
+### Fixed
+
+- `posix_fadvise` now returns errors in the conventional way, rather than as a
+  non-zero value in `Ok()`.
+  (#[1538](https://github.com/nix-rust/nix/pull/1538))
+- Added more errno definitions for better backwards compatibility with
+  Nix 0.21.0.
+  (#[1467](https://github.com/nix-rust/nix/pull/1467))
+- Fixed potential undefined behavior in `Signal::try_from` on some platforms.
+  (#[1484](https://github.com/nix-rust/nix/pull/1484))
+- Fixed buffer overflow in `unistd::getgrouplist`.
+  (#[1545](https://github.com/nix-rust/nix/pull/1545))
+
+
+### Removed
+
+- Removed a couple of termios constants on redox that were never actually
+  supported.
+  (#[1483](https://github.com/nix-rust/nix/pull/1483))
+- Removed `nix::sys::signal::NSIG`.  It was of dubious utility, and not correct
+  for all platforms.
+  (#[1484](https://github.com/nix-rust/nix/pull/1484))
+- Removed support for 32-bit Apple targets, since they've been dropped by both
+  Rustc and Xcode.
+  (#[1492](https://github.com/nix-rust/nix/pull/1492))
+- Deprecated `SockAddr/InetAddr::to_str` in favor of `ToString::to_string`
+  (#[1495](https://github.com/nix-rust/nix/pull/1495))
+- Removed `SigevNotify` on OpenBSD and Redox.
+  (#[1511](https://github.com/nix-rust/nix/pull/1511))
+
+## [0.22.0] - 9 July 2021
+### Added
+- Added `if_nameindex` (#[1445](https://github.com/nix-rust/nix/pull/1445))
+- Added `nmount` for FreeBSD.
+  (#[1453](https://github.com/nix-rust/nix/pull/1453))
+- Added `IpFreebind` socket option (sockopt) on Linux, Fuchsia and Android.
+  (#[1456](https://github.com/nix-rust/nix/pull/1456))
+- Added `TcpUserTimeout` socket option (sockopt) on Linux and Fuchsia.
+  (#[1457](https://github.com/nix-rust/nix/pull/1457))
+- Added `renameat2` for Linux
+  (#[1458](https://github.com/nix-rust/nix/pull/1458))
+- Added `RxqOvfl` support on Linux, Fuchsia and Android.
+  (#[1455](https://github.com/nix-rust/nix/pull/1455))
+
+### Changed
+- `ptsname_r` now returns a lossily-converted string in the event of bad UTF,
+  just like `ptsname`.
+  ([#1446](https://github.com/nix-rust/nix/pull/1446))
+- Nix's error type is now a simple wrapper around the platform's Errno.  This
+  means it is now `Into<std::io::Error>`.  It's also `Clone`, `Copy`, `Eq`, and
+  has a small fixed size.  It also requires less typing.  For example, the old
+  enum variant `nix::Error::Sys(nix::errno::Errno::EINVAL)` is now simply
+  `nix::Error::EINVAL`.
+  ([#1446](https://github.com/nix-rust/nix/pull/1446))
+
+### Fixed
+### Removed
+
+## [0.21.0] - 31 May 2021
+### Added
+- Added `getresuid` and `getresgid`
+  (#[1430](https://github.com/nix-rust/nix/pull/1430))
+- Added TIMESTAMPNS support for linux
+  (#[1402](https://github.com/nix-rust/nix/pull/1402))
+- Added `sendfile64` (#[1439](https://github.com/nix-rust/nix/pull/1439))
+- Added `MS_LAZYTIME` to `MsFlags`
+  (#[1437](https://github.com/nix-rust/nix/pull/1437))
+
+### Changed
+- Made `forkpty` unsafe, like `fork`
+  (#[1390](https://github.com/nix-rust/nix/pull/1390))
+- Made `Uid`, `Gid` and `Pid` methods `from_raw` and `as_raw` a `const fn`
+  (#[1429](https://github.com/nix-rust/nix/pull/1429))
+- Made `Uid::is_root` a `const fn`
+  (#[1429](https://github.com/nix-rust/nix/pull/1429))
+- `AioCb` is now always pinned.  Once a `libc::aiocb` gets sent to the kernel,
+  its address in memory must not change.  Nix now enforces that by using
+  `std::pin`.  Most users won't need to change anything, except when using
+  `aio_suspend`.  See that method's documentation for the new usage.
+  (#[1440](https://github.com/nix-rust/nix/pull/1440))
+- `LioCb` is now constructed using a distinct `LioCbBuilder` struct.  This
+  avoids a soundness issue with the old `LioCb`.  Usage is similar but
+  construction now uses the builder pattern.  See the documentation for
+  details.
+  (#[1440](https://github.com/nix-rust/nix/pull/1440))
+- Minimum supported Rust version is now 1.41.0.
+  ([#1440](https://github.com/nix-rust/nix/pull/1440))
+- Errno aliases are now associated consts on `Errno`, instead of consts in the
+  `errno` module.
+  (#[1452](https://github.com/nix-rust/nix/pull/1452))
+
+### Fixed
+- Allow `sockaddr_ll` size, as reported by the Linux kernel, to be smaller then it's definition
+  (#[1395](https://github.com/nix-rust/nix/pull/1395))
+- Fix spurious errors using `sendmmsg` with multiple cmsgs
+  (#[1414](https://github.com/nix-rust/nix/pull/1414))
+- Added `Errno::EOPNOTSUPP` to FreeBSD, where it was missing.
+  (#[1452](https://github.com/nix-rust/nix/pull/1452))
+
+### Removed
+
+- Removed `sys::socket::accept4` from Android arm because libc removed it in
+  version 0.2.87.
+  ([#1399](https://github.com/nix-rust/nix/pull/1399))
+- `AioCb::from_boxed_slice` and `AioCb::from_boxed_mut_slice` have been
+  removed.  They were useful with earlier versions of Rust, but should no
+  longer be needed now that async/await are available.  `AioCb`s now work
+  exclusively with borrowed buffers, not owned ones.
+  (#[1440](https://github.com/nix-rust/nix/pull/1440))
+- Removed some Errno values from platforms where they aren't actually defined.
+  (#[1452](https://github.com/nix-rust/nix/pull/1452))
+
+## [0.20.0] - 20 February 2021
+### Added
+
+- Added a `passwd` field to `Group` (#[1338](https://github.com/nix-rust/nix/pull/1338))
+- Added `mremap` (#[1306](https://github.com/nix-rust/nix/pull/1306))
+- Added `personality` (#[1331](https://github.com/nix-rust/nix/pull/1331))
+- Added limited Fuchsia support (#[1285](https://github.com/nix-rust/nix/pull/1285))
+- Added `getpeereid` (#[1342](https://github.com/nix-rust/nix/pull/1342))
+- Implemented `IntoIterator` for `Dir`
+  (#[1333](https://github.com/nix-rust/nix/pull/1333)).
+
+### Changed
+
+- Minimum supported Rust version is now 1.40.0.
+  ([#1356](https://github.com/nix-rust/nix/pull/1356))
+- i686-apple-darwin has been demoted to Tier 2 support, because it's deprecated
+  by Xcode.
+  (#[1350](https://github.com/nix-rust/nix/pull/1350))
+- Fixed calling `recvfrom` on an `AddrFamily::Packet` socket
+  (#[1344](https://github.com/nix-rust/nix/pull/1344))
+
+### Fixed
+- `TimerFd` now closes the underlying fd on drop.
+  ([#1381](https://github.com/nix-rust/nix/pull/1381))
+- Define `*_MAGIC` filesystem constants on Linux s390x
+  (#[1372](https://github.com/nix-rust/nix/pull/1372))
+- mqueue, sysinfo, timespec, statfs, test_ptrace_syscall() on x32
+  (#[1366](https://github.com/nix-rust/nix/pull/1366))
+
+### Removed
+
+- `Dir`, `SignalFd`, and `PtyMaster` are no longer `Clone`.
+  (#[1382](https://github.com/nix-rust/nix/pull/1382))
+- Removed `SockLevel`, which hasn't been used for a few years
+  (#[1362](https://github.com/nix-rust/nix/pull/1362))
+- Removed both `Copy` and `Clone` from `TimerFd`.
+  ([#1381](https://github.com/nix-rust/nix/pull/1381))
+
+## [0.19.1] - 28 November 2020
+### Fixed
+- Fixed bugs in `recvmmsg`.
+  (#[1341](https://github.com/nix-rust/nix/pull/1341))
+
+## [0.19.0] - 6 October 2020
 ### Added
+- Added Netlink protocol families to the `SockProtocol` enum
+  (#[1289](https://github.com/nix-rust/nix/pull/1289))
+- Added `clock_gettime`, `clock_settime`, `clock_getres`,
+  `clock_getcpuclockid` functions and `ClockId` struct.
+  (#[1281](https://github.com/nix-rust/nix/pull/1281))
+- Added wrapper functions for `PTRACE_SYSEMU` and `PTRACE_SYSEMU_SINGLESTEP`.
+  (#[1300](https://github.com/nix-rust/nix/pull/1300))
+- Add support for Vsock on Android rather than just Linux.
+  (#[1301](https://github.com/nix-rust/nix/pull/1301))
+- Added `TCP_KEEPCNT` and `TCP_KEEPINTVL` TCP keepalive options.
+  (#[1283](https://github.com/nix-rust/nix/pull/1283))
 ### Changed
+- Expose `SeekData` and `SeekHole` on all Linux targets
+  (#[1284](https://github.com/nix-rust/nix/pull/1284))
+- Changed unistd::{execv,execve,execvp,execvpe,fexecve,execveat} to take both `&[&CStr]` and `&[CString]` as its list argument(s).
+  (#[1278](https://github.com/nix-rust/nix/pull/1278))
+- Made `unistd::fork` an unsafe funtion, bringing it in line with [libstd's decision](https://github.com/rust-lang/rust/pull/58059).
+  (#[1293](https://github.com/nix-rust/nix/pull/1293))
 ### Fixed
 ### Removed
 
+## [0.18.0] - 26 July 2020
+### Added
+- Added `fchown(2)` wrapper.
+  (#[1257](https://github.com/nix-rust/nix/pull/1257))
+- Added support on linux systems for `MAP_HUGE_`_`SIZE`_ family of flags.
+  (#[1211](https://github.com/nix-rust/nix/pull/1211))
+- Added support for `F_OFD_*` `fcntl` commands on Linux and Android.
+  (#[1195](https://github.com/nix-rust/nix/pull/1195))
+- Added `env::clearenv()`: calls `libc::clearenv` on platforms
+  where it's available, and clears the environment of all variables
+  via `std::env::vars` and `std::env::remove_var` on others.
+  (#[1185](https://github.com/nix-rust/nix/pull/1185))
+- `FsType` inner value made public.
+  (#[1187](https://github.com/nix-rust/nix/pull/1187))
+- Added `unistd::setfsuid` and `unistd::setfsgid` to set the user or group
+  identity for filesystem checks per-thread.
+  (#[1163](https://github.com/nix-rust/nix/pull/1163))
+- Derived `Ord`, `PartialOrd` for `unistd::Pid` (#[1189](https://github.com/nix-rust/nix/pull/1189))
+- Added `select::FdSet::fds` method to iterate over file descriptors in a set.
+  ([#1207](https://github.com/nix-rust/nix/pull/1207))
+- Added support for UDP generic segmentation offload (GSO) and generic
+  receive offload (GRO) ([#1209](https://github.com/nix-rust/nix/pull/1209))
+- Added support for `sendmmsg` and `recvmmsg` calls
+  (#[1208](https://github.com/nix-rust/nix/pull/1208))
+- Added support for `SCM_CREDS` messages (`UnixCredentials`) on FreeBSD/DragonFly
+  (#[1216](https://github.com/nix-rust/nix/pull/1216))
+- Added `BindToDevice` socket option (sockopt) on Linux
+  (#[1233](https://github.com/nix-rust/nix/pull/1233))
+- Added `EventFilter` bitflags for `EV_DISPATCH` and `EV_RECEIPT` on OpenBSD.
+  (#[1252](https://github.com/nix-rust/nix/pull/1252))
+- Added support for `Ipv4PacketInfo` and `Ipv6PacketInfo` to `ControlMessage`.
+  (#[1222](https://github.com/nix-rust/nix/pull/1222))
+- `CpuSet` and `UnixCredentials` now implement `Default`.
+  (#[1244](https://github.com/nix-rust/nix/pull/1244))
+- Added `unistd::ttyname`
+  (#[1259](https://github.com/nix-rust/nix/pull/1259))
+- Added support for `Ipv4PacketInfo` and `Ipv6PacketInfo` to `ControlMessage` for iOS and Android.
+  (#[1265](https://github.com/nix-rust/nix/pull/1265))
+- Added support for `TimerFd`.
+  (#[1261](https://github.com/nix-rust/nix/pull/1261))
+
+### Changed
+- Changed `fallocate` return type from `c_int` to `()` (#[1201](https://github.com/nix-rust/nix/pull/1201))
+- Enabled `sys::ptrace::setregs` and `sys::ptrace::getregs` on x86_64-unknown-linux-musl target
+  (#[1198](https://github.com/nix-rust/nix/pull/1198))
+- On Linux, `ptrace::write` is now an `unsafe` function. Caveat programmer.
+  (#[1245](https://github.com/nix-rust/nix/pull/1245))
+- `execv`, `execve`, `execvp` and `execveat` in `::nix::unistd` and `reboot` in
+  `::nix::sys::reboot` now return `Result<Infallible>` instead of `Result<Void>` (#[1239](https://github.com/nix-rust/nix/pull/1239))
+- `sys::socket::sockaddr_storage_to_addr` is no longer `unsafe`.  So is
+  `offset_of!`.
+- `sys::socket::sockaddr_storage_to_addr`, `offset_of!`, and `Errno::clear` are
+  no longer `unsafe`.
+- `SockAddr::as_ffi_pair`,`sys::socket::sockaddr_storage_to_addr`, `offset_of!`,
+  and `Errno::clear` are no longer `unsafe`.
+  (#[1244](https://github.com/nix-rust/nix/pull/1244))
+- Several `Inotify` methods now take `self` by value instead of by reference
+  (#[1244](https://github.com/nix-rust/nix/pull/1244))
+- `nix::poll::ppoll`: `timeout` parameter is now optional, None is equivalent for infinite timeout.
+
+### Fixed
+
+- Fixed `getsockopt`.  The old code produced UB which triggers a panic with
+  Rust 1.44.0.
+  (#[1214](https://github.com/nix-rust/nix/pull/1214))
+
+- Fixed a bug in nix::unistd that would result in an infinite loop
+  when a group or user lookup required a buffer larger than
+  16KB. (#[1198](https://github.com/nix-rust/nix/pull/1198))
+- Fixed unaligned casting of `cmsg_data` to `af_alg_iv` (#[1206](https://github.com/nix-rust/nix/pull/1206))
+- Fixed `readlink`/`readlinkat` when reading symlinks longer than `PATH_MAX` (#[1231](https://github.com/nix-rust/nix/pull/1231))
+- `PollFd`, `EpollEvent`, `IpMembershipRequest`, `Ipv6MembershipRequest`,
+  `TimeVal`, and `IoVec` are now `repr(transparent)`.  This is required for
+  correctness's sake across all architectures and compilers, though now bugs
+  have been reported so far.
+  (#[1243](https://github.com/nix-rust/nix/pull/1243))
+- Fixed unaligned pointer read in `Inotify::read_events`.
+  (#[1244](https://github.com/nix-rust/nix/pull/1244))
+
+### Removed
+
+- Removed `sys::socket::addr::from_libc_sockaddr` from the public API.
+  (#[1215](https://github.com/nix-rust/nix/pull/1215))
+- Removed `sys::termios::{get_libc_termios, get_libc_termios_mut, update_wrapper`
+  from the public API. These were previously hidden in the docs but still usable
+  by downstream.
+  (#[1235](https://github.com/nix-rust/nix/pull/1235))
+
+- Nix no longer implements `NixPath` for `Option<P> where P: NixPath`.  Most
+  Nix functions that accept `NixPath` arguments can't do anything useful with
+  `None`.  The exceptions (`mount` and `quotactl_sync`) already take explicitly
+  optional arguments.
+  (#[1242](https://github.com/nix-rust/nix/pull/1242))
+
+- Removed `unistd::daemon` and `unistd::pipe2` on OSX and ios
+  (#[1255](https://github.com/nix-rust/nix/pull/1255))
+
+- Removed `sys::event::FilterFlag::NOTE_EXIT_REPARENTED` and
+  `sys::event::FilterFlag::NOTE_REAP` on OSX and ios.
+  (#[1255](https://github.com/nix-rust/nix/pull/1255))
+
+- Removed `sys::ptrace::ptrace` on Android and Linux.
+  (#[1255](https://github.com/nix-rust/nix/pull/1255))
+
+- Dropped support for powerpc64-unknown-linux-gnu
+  (#[1266](https://github.com/nix-rust/nix/pull/1268))
+
+## [0.17.0] - 3 February 2020
+### Added
+- Add `CLK_TCK` to `SysconfVar`
+  (#[1177](https://github.com/nix-rust/nix/pull/1177))
+### Changed
+### Fixed
+### Removed
+- Removed deprecated Error::description from error types
+  (#[1175](https://github.com/nix-rust/nix/pull/1175))
+
+## [0.16.1] - 23 December 2019
+### Added
+### Changed
+### Fixed
+
+- Fixed the build for OpenBSD
+  (#[1168](https://github.com/nix-rust/nix/pull/1168))
+
+### Removed
+
+## [0.16.0] - 1 December 2019
+### Added
+- Added `ptrace::seize()`: similar to `attach()` on Linux
+  but with better-defined semantics.
+  (#[1154](https://github.com/nix-rust/nix/pull/1154))
+
+- Added `Signal::as_str()`: returns signal name as `&'static str`
+  (#[1138](https://github.com/nix-rust/nix/pull/1138))
+
+- Added `posix_fallocate`.
+  ([#1105](https://github.com/nix-rust/nix/pull/1105))
+
+- Implemented `Default` for `FdSet`
+  ([#1107](https://github.com/nix-rust/nix/pull/1107))
+
+- Added `NixPath::is_empty`.
+  ([#1107](https://github.com/nix-rust/nix/pull/1107))
+
+- Added `mkfifoat`
+  ([#1133](https://github.com/nix-rust/nix/pull/1133))
+
+- Added `User::from_uid`, `User::from_name`, `User::from_gid` and
+  `Group::from_name`,
+  ([#1139](https://github.com/nix-rust/nix/pull/1139))
+
+- Added `linkat`
+  ([#1101](https://github.com/nix-rust/nix/pull/1101))
+
+- Added `sched_getaffinity`.
+  ([#1148](https://github.com/nix-rust/nix/pull/1148))
+
+- Added optional `Signal` argument to `ptrace::{detach, syscall}` for signal
+  injection. ([#1083](https://github.com/nix-rust/nix/pull/1083))
+
+### Changed
+- `sys::termios::BaudRate` now implements `TryFrom<speed_t>` instead of
+  `From<speed_t>`.  The old `From` implementation would panic on failure.
+  ([#1159](https://github.com/nix-rust/nix/pull/1159))
+
+- `sys::socket::ControlMessage::ScmCredentials` and
+  `sys::socket::ControlMessageOwned::ScmCredentials` now wrap `UnixCredentials`
+  rather than `libc::ucred`.
+  ([#1160](https://github.com/nix-rust/nix/pull/1160))
+
+- `sys::socket::recvmsg` now takes a plain `Vec` instead of a `CmsgBuffer`
+  implementor.  If you were already using `cmsg_space!`, then you needn't worry.
+  ([#1156](https://github.com/nix-rust/nix/pull/1156))
+
+- `sys::socket::recvfrom` now returns
+  `Result<(usize, Option<SockAddr>)>` instead of `Result<(usize, SockAddr)>`.
+  ([#1145](https://github.com/nix-rust/nix/pull/1145))
+
+- `Signal::from_c_int` has been replaced by `Signal::try_from`
+  ([#1113](https://github.com/nix-rust/nix/pull/1113))
+
+- Changed `readlink` and `readlinkat` to return `OsString`
+  ([#1109](https://github.com/nix-rust/nix/pull/1109))
+
+  ```rust
+  # use nix::fcntl::{readlink, readlinkat};
+  // the buffer argument of `readlink` and `readlinkat` has been removed,
+  // and the return value is now an owned type (`OsString`).
+  // Existing code can be updated by removing the buffer argument
+  // and removing any clone or similar operation on the output
+
+  // old code `readlink(&path, &mut buf)` can be replaced with the following
+  let _: OsString = readlink(&path);
+
+  // old code `readlinkat(dirfd, &path, &mut buf)` can be replaced with the following
+  let _: OsString = readlinkat(dirfd, &path);
+  ```
+
+- Minimum supported Rust version is now 1.36.0.
+  ([#1108](https://github.com/nix-rust/nix/pull/1108))
+
+- `Ipv4Addr::octets`, `Ipv4Addr::to_std`, `Error::as_errno`,
+  `ForkResult::is_child`, `ForkResult::is_parent`, `Gid::as_raw`,
+  `Uid::is_root`, `Uid::as_raw`, `Pid::as_raw`, and `PollFd::revents` now take
+  `self` by value.
+  ([#1107](https://github.com/nix-rust/nix/pull/1107))
+
+- Type `&CString` for parameters of `exec(v|ve|vp|vpe|veat)` are changed to `&CStr`.
+  ([#1121](https://github.com/nix-rust/nix/pull/1121))
+
+### Fixed
+- Fix length of abstract socket addresses
+  ([#1120](https://github.com/nix-rust/nix/pull/1120))
+
+- Fix initialization of msghdr in recvmsg/sendmsg when built with musl
+  ([#1136](https://github.com/nix-rust/nix/pull/1136))
+
+### Removed
+- Remove the deprecated `CmsgSpace`.
+  ([#1156](https://github.com/nix-rust/nix/pull/1156))
+
 ## [0.15.0] - 10 August 2019
 ### Added
 - Added `MSG_WAITALL` to `MsgFlags` in `sys::socket`.
diff --git a/third_party/rust/nix/CONTRIBUTING.md b/third_party/rust/nix/CONTRIBUTING.md
deleted file mode 100644
index 03a1f630dbb06..0000000000000
--- a/third_party/rust/nix/CONTRIBUTING.md
+++ /dev/null
@@ -1,114 +0,0 @@
-# Contributing to nix
-
-We're really glad you're interested in contributing to nix! This
-document has a few pointers and guidelines to help get you started.
-
-To have a welcoming and inclusive project, nix uses the Rust project's
-[Code of Conduct][conduct]. All contributors are expected to follow it.
-
-[conduct]: https://www.rust-lang.org/conduct.html
-
-
-# Issues
-
-We use GitHub's [issue tracker][issues].
-
-[issues]: https://github.com/nix-rust/nix/issues
-
-
-## Bug reports
-
-Before submitting a new bug report, please [search existing
-issues][issue-search] to see if there's something related. If not, just
-[open a new issue][new-issue]!
-
-As a reminder, the more information you can give in your issue, the
-easier it is to figure out how to fix it. For nix, this will likely
-include the OS and version, and the architecture.
-
-[issue-search]: https://github.com/nix-rust/nix/search?utf8=%E2%9C%93&q=is%3Aissue&type=Issues
-[new-issue]: https://github.com/nix-rust/nix/issues/new
-
-
-## Feature / API requests
-
-If you'd like a new API or feature added, please [open a new
-issue][new-issue] requesting it. As with reporting a bug, the more
-information you can provide, the better.
-
-
-## Labels
-
-We use labels to help manage issues. The structure is modeled after
-[Rust's issue labeling scheme][rust-labels]:
-- **A-**prefixed labels state which area of the project the issue
-  relates to
-- **E-**prefixed labels explain the level of experience necessary to fix the
-  issue
-- **O-**prefixed labels specify the OS for issues that are OS-specific
-- **R-**prefixed labels specify the architecture for issues that are
-  architecture-specific
-
-[rust-labels]: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#issue-triage
-
-
-# Pull requests
-
-GitHub pull requests are the primary mechanism we use to change nix. GitHub itself has
-some [great documentation][pr-docs] on using the Pull Request feature. We use the 'fork and
-pull' model described there.
-
-Please make pull requests against the `master` branch.
-
-If you change the API by way of adding, removing or changing something or if
-you fix a bug, please add an appropriate note to the [change log][cl]. We
-follow the conventions of [Keep A CHANGELOG][kacl].
-
-[cl]: https://github.com/nix-rust/nix/blob/master/CHANGELOG.md
-[kacl]: https://github.com/olivierlacan/keep-a-changelog/tree/18adb5f5be7a898d046f6a4acb93e39dcf40c4ad
-[pr-docs]: https://help.github.com/articles/using-pull-requests/
-
-## Testing
-
-nix has a test suite that you can run with `cargo test`. Ideally, we'd like pull
-requests to include tests where they make sense. For example, when fixing a bug,
-add a test that would have failed without the fix.
-
-After you've made your change, make sure the tests pass in your development
-environment. We also have [continuous integration set up on
-Travis-CI][travis-ci], which might find some issues on other platforms. The CI
-will run once you open a pull request.
-
-There is also infrastructure for running tests for other targets
-locally.  More information is available in the [CI Readme][ci-readme].
-
-[travis-ci]: https://travis-ci.org/nix-rust/nix
-[ci-readme]: ci/README.md
-
-### Disabling a test in the CI environment
-
-Sometimes there are features that cannot be tested in the CI environment.
-To stop a test from running under CI, add `#[cfg_attr(travis, ignore)]`
-to it. Please include a comment describing the reason it shouldn't run
-under CI, and a link to an upstream issue if possible!
-
-## bors, the bot who merges all the PRs
-
-All pull requests are merged via [bors], an integration bot. After the
-pull request has been reviewed, the reviewer will leave a comment like
-
-> bors r+
-
-to let bors know that it was approved. Then bors will check that it passes
-tests when merged with the latest changes in the `master` branch, and
-merge if the tests succeed.
-
-[bors]: https://bors-ng.github.io/
-
-
-## API conventions
-
-If you're adding a new API, we have a [document with
-conventions][conventions] to use throughout the nix project.
-
-[conventions]: https://github.com/nix-rust/nix/blob/master/CONVENTIONS.md
diff --git a/third_party/rust/nix/CONVENTIONS.md b/third_party/rust/nix/CONVENTIONS.md
deleted file mode 100644
index 48daa937345d2..0000000000000
--- a/third_party/rust/nix/CONVENTIONS.md
+++ /dev/null
@@ -1,87 +0,0 @@
-# Conventions
-
-In order to achieve our goal of wrapping [libc][libc] code in idiomatic rust
-constructs with minimal performance overhead, we follow the following
-conventions.
-
-Note that, thus far, not all the code follows these conventions and not all
-conventions we try to follow have been documented here. If you find an instance
-of either, feel free to remedy the flaw by opening a pull request with
-appropriate changes or additions.
-
-## Change Log
-
-We follow the conventions laid out in [Keep A CHANGELOG][kacl].
-
-[kacl]: https://github.com/olivierlacan/keep-a-changelog/tree/18adb5f5be7a898d046f6a4acb93e39dcf40c4ad
-
-## libc constants, functions and structs
-
-We do not define integer constants ourselves, but use or reexport them from the
-[libc crate][libc].
-
-We use the functions exported from [libc][libc] instead of writing our own
-`extern` declarations.
-
-We use the `struct` definitions from [libc][libc] internally instead of writing
-our own. If we want to add methods to a libc type, we use the newtype pattern.
-For example,
-
-```rust
-pub struct SigSet(libc::sigset_t);
-
-impl SigSet {
-    ...
-}
-```
-
-When creating newtypes, we use Rust's `CamelCase` type naming convention.
-
-## Bitflags
-
-Many C functions have flags parameters that are combined from constants using
-bitwise operations. We represent the types of these parameters by types defined
-using our `libc_bitflags!` macro, which is a convenience wrapper around the
-`bitflags!` macro from the [bitflags crate][bitflags] that brings in the
-constant value from `libc`.
-
-We name the type for a set of constants whose element's names start with `FOO_`
-`FooFlags`.
-
-For example,
-
-```rust
-libc_bitflags!{
-    pub struct ProtFlags: libc::c_int {
-        PROT_NONE;
-        PROT_READ;
-        PROT_WRITE;
-        PROT_EXEC;
-        #[cfg(any(target_os = "linux", target_os = "android"))]
-        PROT_GROWSDOWN;
-        #[cfg(any(target_os = "linux", target_os = "android"))]
-        PROT_GROWSUP;
-    }
-}
-```
-
-
-## Enumerations
-
-We represent sets of constants that are intended as mutually exclusive arguments
-to parameters of functions by [enumerations][enum].
-
-
-## Structures Initialized by libc Functions
-
-Whenever we need to use a [libc][libc] function to properly initialize a
-variable and said function allows us to use uninitialized memory, we use
-[`std::mem::uninitialized`][std_uninitialized] (or [`core::mem::uninitialized`][core_uninitialized])
-when defining the variable. This allows us to avoid the overhead incurred by
-zeroing or otherwise initializing the variable.
-
-[bitflags]: https://crates.io/crates/bitflags/
-[core_uninitialized]: https://doc.rust-lang.org/core/mem/fn.uninitialized.html
-[enum]: https://doc.rust-lang.org/reference.html#enumerations
-[libc]: https://crates.io/crates/libc/
-[std_uninitialized]: https://doc.rust-lang.org/std/mem/fn.uninitialized.html
diff --git a/third_party/rust/nix/Cargo.toml b/third_party/rust/nix/Cargo.toml
index 555b99020d68f..122c1af2ff4f1 100644
--- a/third_party/rust/nix/Cargo.toml
+++ b/third_party/rust/nix/Cargo.toml
@@ -3,22 +3,25 @@
 # When uploading crates to the registry Cargo will automatically
 # "normalize" Cargo.toml files for maximal compatibility
 # with all versions of Cargo and also rewrite `path` dependencies
-# to registry (e.g., crates.io) dependencies
+# to registry (e.g., crates.io) dependencies.
 #
-# If you believe there's an error in this file please file an
-# issue against the rust-lang/cargo repository. If you're
-# editing this file be aware that the upstream Cargo.toml
-# will likely look very different (and much more reasonable)
+# If you are reading this file be aware that the original Cargo.toml
+# will likely look very different (and much more reasonable).
+# See Cargo.toml.orig for the original contents.
 
 [package]
+edition = "2018"
+rust-version = "1.46"
 name = "nix"
-version = "0.15.0"
+version = "0.23.1"
 authors = ["The nix-rust Project Developers"]
-exclude = ["/.gitignore", "/.travis.yml", "/ci/*", "/Cross.toml", "/RELEASE_PROCEDURE.md", "/bors.toml"]
+include = ["src/**/*", "test/**/*", "LICENSE", "README.md", "CHANGELOG.md"]
 description = "Rust friendly bindings to *nix APIs"
 categories = ["os::unix-apis"]
 license = "MIT"
 repository = "https://github.com/nix-rust/nix"
+[package.metadata.docs.rs]
+targets = ["x86_64-unknown-linux-gnu", "aarch64-linux-android", "x86_64-apple-darwin", "aarch64-apple-ios", "x86_64-unknown-freebsd", "x86_64-unknown-openbsd", "x86_64-unknown-netbsd", "x86_64-unknown-dragonfly", "x86_64-fuchsia", "x86_64-unknown-redox", "x86_64-unknown-illumos"]
 
 [[test]]
 name = "test"
@@ -28,6 +31,10 @@ path = "test/test.rs"
 name = "test-aio-drop"
 path = "test/sys/test_aio_drop.rs"
 
+[[test]]
+name = "test-clearenv"
+path = "test/test_clearenv.rs"
+
 [[test]]
 name = "test-lio-listio-resubmit"
 path = "test/sys/test_lio_listio_resubmit.rs"
@@ -41,30 +48,35 @@ harness = false
 name = "test-ptymaster-drop"
 path = "test/test_ptymaster_drop.rs"
 [dependencies.bitflags]
-version = "1.0"
+version = "1.1"
 
 [dependencies.cfg-if]
-version = "0.1.2"
+version = "1.0"
 
 [dependencies.libc]
-version = "0.2.60"
+version = "0.2.102"
 features = ["extra_traits"]
-
-[dependencies.void]
-version = "1.0.2"
-[dev-dependencies.bytes]
-version = "0.4.8"
+[dev-dependencies.assert-impl]
+version = "0.1"
 
 [dev-dependencies.lazy_static]
 version = "1.2"
 
+[dev-dependencies.parking_lot]
+version = "0.11.2"
+
 [dev-dependencies.rand]
-version = ">= 0.6, < 0.7"
+version = "0.8"
+
+[dev-dependencies.semver]
+version = "1.0.0"
 
 [dev-dependencies.tempfile]
-version = ">= 3.0.5, < 3.0.9"
+version = "3.2.0"
 [target."cfg(any(target_os = \"android\", target_os = \"linux\"))".dev-dependencies.caps]
-version = "0.3.1"
+version = "0.5.1"
+[target."cfg(not(target_os = \"redox\"))".dependencies.memoffset]
+version = "0.6.3"
 [target."cfg(target_os = \"dragonfly\")".build-dependencies.cc]
 version = "1"
 [target."cfg(target_os = \"freebsd\")".dev-dependencies.sysctl]
diff --git a/third_party/rust/nix/README.md b/third_party/rust/nix/README.md
index 0e540ba5b968e..a8759f1ce8ecb 100644
--- a/third_party/rust/nix/README.md
+++ b/third_party/rust/nix/README.md
@@ -1,7 +1,7 @@
 # Rust bindings to *nix APIs
 
-[![Build Status](https://travis-ci.org/nix-rust/nix.svg?branch=master)](https://travis-ci.org/nix-rust/nix)
-[![crates.io](http://meritbadge.herokuapp.com/nix)](https://crates.io/crates/nix)
+[![Cirrus Build Status](https://api.cirrus-ci.com/github/nix-rust/nix.svg)](https://cirrus-ci.com/github/nix-rust/nix)
+[![crates.io](https://img.shields.io/crates/v/nix.svg)](https://crates.io/crates/nix)
 
 [Documentation (Releases)](https://docs.rs/nix/)
 
@@ -17,7 +17,7 @@ usage.
 
 As an example of what Nix provides, examine the differences between what is
 exposed by libc and nix for the
-[gethostname](http://man7.org/linux/man-pages/man2/gethostname.2.html) system
+[gethostname](https://man7.org/linux/man-pages/man2/gethostname.2.html) system
 call:
 
 ```rust,ignore
@@ -50,7 +50,6 @@ Tier 1:
   * aarch64-unknown-linux-gnu
   * arm-unknown-linux-gnueabi
   * armv7-unknown-linux-gnueabihf
-  * i686-apple-darwin
   * i686-unknown-freebsd
   * i686-unknown-linux-gnu
   * i686-unknown-linux-musl
@@ -58,7 +57,6 @@ Tier 1:
   * mips64-unknown-linux-gnuabi64
   * mips64el-unknown-linux-gnuabi64
   * mipsel-unknown-linux-gnu
-  * powerpc64-unknown-linux-gnu
   * powerpc64le-unknown-linux-gnu
   * x86_64-apple-darwin
   * x86_64-unknown-freebsd
@@ -70,33 +68,26 @@ Tier 2:
   * aarch64-linux-android
   * arm-linux-androideabi
   * arm-unknown-linux-musleabi
-  * armv7-apple-ios
   * armv7-linux-androideabi
-  * armv7s-apple-ios
-  * i386-apple-ios
   * i686-linux-android
   * powerpc-unknown-linux-gnu
   * s390x-unknown-linux-gnu
   * x86_64-apple-ios
   * x86_64-linux-android
+  * x86_64-unknown-illumos
   * x86_64-unknown-netbsd
 
-## Usage
+Tier 3:
+  * x86_64-fuchsia
+  * x86_64-unknown-dragonfly
+  * x86_64-unknown-linux-gnux32
+  * x86_64-unknown-openbsd
+  * x86_64-unknown-redox
 
-`nix` requires Rust 1.31.0 or newer.
+## Minimum Supported Rust Version (MSRV)
 
-To use `nix`, first add this to your `Cargo.toml`:
-
-```toml
-[dependencies]
-nix = "0.15.0"
-```
-
-Then, add this to your crate root:
-
-```rust,ignore
-extern crate nix;
-```
+nix is supported on Rust 1.46.0 and higher.  It's MSRV will not be
+changed in the future without bumping the major or minor version.
 
 ## Contributing
 
diff --git a/third_party/rust/nix/build.rs b/third_party/rust/nix/build.rs
deleted file mode 100644
index 92fd3667fa5b1..0000000000000
--- a/third_party/rust/nix/build.rs
+++ /dev/null
@@ -1,12 +0,0 @@
-#[cfg(target_os = "dragonfly")]
-extern crate cc;
-
-#[cfg(target_os = "dragonfly")]
-fn main() {
-    cc::Build::new()
-        .file("src/errno_dragonfly.c")
-        .compile("liberrno_dragonfly.a");
-}
-
-#[cfg(not(target_os = "dragonfly"))]
-fn main() {}
diff --git a/third_party/rust/nix/src/dir.rs b/third_party/rust/nix/src/dir.rs
index 1820b5330ff60..ed70a458ac2ab 100644
--- a/third_party/rust/nix/src/dir.rs
+++ b/third_party/rust/nix/src/dir.rs
@@ -1,10 +1,10 @@
-use {Error, NixPath, Result};
-use errno::Errno;
-use fcntl::{self, OFlag};
-use libc;
+use crate::{Error, NixPath, Result};
+use crate::errno::Errno;
+use crate::fcntl::{self, OFlag};
 use std::os::unix::io::{AsRawFd, IntoRawFd, RawFd};
-use std::{ffi, ptr};
-use sys;
+use std::ptr;
+use std::ffi;
+use crate::sys;
 
 #[cfg(target_os = "linux")]
 use libc::{dirent64 as dirent, readdir64_r as readdir_r};
@@ -25,7 +25,7 @@ use libc::{dirent, readdir_r};
 ///    * returns entries for `.` (current directory) and `..` (parent directory).
 ///    * returns entries' names as a `CStr` (no allocation or conversion beyond whatever libc
 ///      does).
-#[derive(Clone, Debug, Eq, Hash, PartialEq)]
+#[derive(Debug, Eq, Hash, PartialEq)]
 pub struct Dir(
     ptr::NonNull<libc::DIR>
 );
@@ -53,14 +53,12 @@ impl Dir {
 
     /// Converts from a file descriptor, closing it on success or failure.
     pub fn from_fd(fd: RawFd) -> Result<Self> {
-        let d = unsafe { libc::fdopendir(fd) };
-        if d.is_null() {
+        let d = ptr::NonNull::new(unsafe { libc::fdopendir(fd) }).ok_or_else(|| {
             let e = Error::last();
             unsafe { libc::close(fd) };
-            return Err(e);
-        };
-        // Always guaranteed to be non-null by the previous check
-        Ok(Dir(ptr::NonNull::new(d).unwrap()))
+            e
+        })?;
+        Ok(Dir(d))
     }
 
     /// Returns an iterator of `Result<Entry>` which rewinds when finished.
@@ -85,7 +83,32 @@ impl AsRawFd for Dir {
 
 impl Drop for Dir {
     fn drop(&mut self) {
-        unsafe { libc::closedir(self.0.as_ptr()) };
+        let e = Errno::result(unsafe { libc::closedir(self.0.as_ptr()) });
+        if !std::thread::panicking() && e == Err(Errno::EBADF) {
+            panic!("Closing an invalid file descriptor!");
+        };
+    }
+}
+
+fn next(dir: &mut Dir) -> Option<Result<Entry>> {
+    unsafe {
+        // Note: POSIX specifies that portable applications should dynamically allocate a
+        // buffer with room for a `d_name` field of size `pathconf(..., _PC_NAME_MAX)` plus 1
+        // for the NUL byte. It doesn't look like the std library does this; it just uses
+        // fixed-sized buffers (and libc's dirent seems to be sized so this is appropriate).
+        // Probably fine here too then.
+        let mut ent = std::mem::MaybeUninit::<dirent>::uninit();
+        let mut result = ptr::null_mut();
+        if let Err(e) = Errno::result(
+            readdir_r(dir.0.as_ptr(), ent.as_mut_ptr(), &mut result))
+        {
+            return Some(Err(e));
+        }
+        if result.is_null() {
+            return None;
+        }
+        assert_eq!(result, ent.as_mut_ptr());
+        Some(Ok(Entry(ent.assume_init())))
     }
 }
 
@@ -96,23 +119,7 @@ impl<'d> Iterator for Iter<'d> {
     type Item = Result<Entry>;
 
     fn next(&mut self) -> Option<Self::Item> {
-        unsafe {
-            // Note: POSIX specifies that portable applications should dynamically allocate a
-            // buffer with room for a `d_name` field of size `pathconf(..., _PC_NAME_MAX)` plus 1
-            // for the NUL byte. It doesn't look like the std library does this; it just uses
-            // fixed-sized buffers (and libc's dirent seems to be sized so this is appropriate).
-            // Probably fine here too then.
-            let mut ent: Entry = Entry(::std::mem::uninitialized());
-            let mut result = ptr::null_mut();
-            if let Err(e) = Errno::result(readdir_r((self.0).0.as_ptr(), &mut ent.0, &mut result)) {
-                return Some(Err(e));
-            }
-            if result == ptr::null_mut() {
-                return None;
-            }
-            assert_eq!(result, &mut ent.0 as *mut dirent);
-            return Some(Ok(ent));
-        }
+        next(self.0)
     }
 }
 
@@ -122,10 +129,48 @@ impl<'d> Drop for Iter<'d> {
     }
 }
 
+/// The return type of [Dir::into_iter]
+#[derive(Debug, Eq, Hash, PartialEq)]
+pub struct OwningIter(Dir);
+
+impl Iterator for OwningIter {
+    type Item = Result<Entry>;
+
+    fn next(&mut self) -> Option<Self::Item> {
+        next(&mut self.0)
+    }
+}
+
+impl IntoIterator for Dir {
+    type Item = Result<Entry>;
+    type IntoIter = OwningIter;
+
+    /// Creates a owning iterator, that is, one that takes ownership of the
+    /// `Dir`. The `Dir` cannot be used after calling this.  This can be useful
+    /// when you have a function that both creates a `Dir` instance and returns
+    /// an `Iterator`.
+    ///
+    /// Example:
+    ///
+    /// ```
+    /// use nix::{dir::Dir, fcntl::OFlag, sys::stat::Mode};
+    /// use std::{iter::Iterator, string::String};
+    ///
+    /// fn ls_upper(dirname: &str) -> impl Iterator<Item=String> {
+    ///     let d = Dir::open(dirname, OFlag::O_DIRECTORY, Mode::S_IXUSR).unwrap();
+    ///     d.into_iter().map(|x| x.unwrap().file_name().as_ref().to_string_lossy().to_ascii_uppercase())
+    /// }
+    /// ```
+    fn into_iter(self) -> Self::IntoIter {
+        OwningIter(self)
+    }
+}
+
 /// A directory entry, similar to `std::fs::DirEntry`.
 ///
 /// Note that unlike the std version, this may represent the `.` or `..` entries.
 #[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]
+#[repr(transparent)]
 pub struct Entry(dirent);
 
 #[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]
@@ -145,6 +190,7 @@ impl Entry {
               target_os = "emscripten",
               target_os = "fuchsia",
               target_os = "haiku",
+              target_os = "illumos",
               target_os = "ios",
               target_os = "l4re",
               target_os = "linux",
@@ -159,13 +205,15 @@ impl Entry {
                   target_os = "emscripten",
                   target_os = "fuchsia",
                   target_os = "haiku",
+                  target_os = "illumos",
                   target_os = "ios",
                   target_os = "l4re",
                   target_os = "linux",
                   target_os = "macos",
                   target_os = "solaris")))]
+    #[allow(clippy::useless_conversion)]    // Not useless on all OSes
     pub fn ino(&self) -> u64 {
-        self.0.d_fileno as u64
+        u64::from(self.0.d_fileno)
     }
 
     /// Returns the bare file name of this directory entry without any other leading path component.
@@ -179,6 +227,7 @@ impl Entry {
     /// notably, some Linux filesystems don't implement this. The caller should use `stat` or
     /// `fstat` if this returns `None`.
     pub fn file_type(&self) -> Option<Type> {
+        #[cfg(not(any(target_os = "illumos", target_os = "solaris")))]
         match self.0.d_type {
             libc::DT_FIFO => Some(Type::Fifo),
             libc::DT_CHR => Some(Type::CharacterDevice),
@@ -189,5 +238,9 @@ impl Entry {
             libc::DT_SOCK => Some(Type::Socket),
             /* libc::DT_UNKNOWN | */ _ => None,
         }
+
+        // illumos and Solaris systems do not have the d_type member at all:
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        None
     }
 }
diff --git a/third_party/rust/nix/src/env.rs b/third_party/rust/nix/src/env.rs
new file mode 100644
index 0000000000000..bcae28713edb9
--- /dev/null
+++ b/third_party/rust/nix/src/env.rs
@@ -0,0 +1,65 @@
+//! Environment variables
+use cfg_if::cfg_if;
+use std::fmt;
+
+/// Indicates that [`clearenv`] failed for some unknown reason
+#[derive(Clone, Copy, Debug)]
+pub struct ClearEnvError;
+
+impl fmt::Display for ClearEnvError {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        write!(f, "clearenv failed")
+    }
+}
+
+impl std::error::Error for ClearEnvError {}
+
+/// Clear the environment of all name-value pairs.
+///
+/// On platforms where libc provides `clearenv()`, it will be used. libc's
+/// `clearenv()` is documented to return an error code but not set errno; if the
+/// return value indicates a failure, this function will return
+/// [`ClearEnvError`].
+///
+/// On platforms where libc does not provide `clearenv()`, a fallback
+/// implementation will be used that iterates over all environment variables and
+/// removes them one-by-one.
+///
+/// # Safety
+///
+/// This function is not threadsafe and can cause undefined behavior in
+/// combination with `std::env` or other program components that access the
+/// environment. See, for example, the discussion on `std::env::remove_var`; this
+/// function is a case of an "inherently unsafe non-threadsafe API" dealing with
+/// the environment.
+///
+///  The caller must ensure no other threads access the process environment while
+///  this function executes and that no raw pointers to an element of libc's
+///  `environ` is currently held. The latter is not an issue if the only other
+///  environment access in the program is via `std::env`, but the requirement on
+///  thread safety must still be upheld.
+pub unsafe fn clearenv() -> std::result::Result<(), ClearEnvError> {
+    cfg_if! {
+        if #[cfg(any(target_os = "fuchsia",
+                     target_os = "wasi",
+                     target_env = "wasi",
+                     target_env = "uclibc",
+                     target_os = "linux",
+                     target_os = "android",
+                     target_os = "emscripten"))] {
+            let ret = libc::clearenv();
+        } else {
+            use std::env;
+            for (name, _) in env::vars_os() {
+                env::remove_var(name);
+            }
+            let ret = 0;
+        }
+    }
+
+    if ret == 0 {
+        Ok(())
+    } else {
+        Err(ClearEnvError)
+    }
+}
diff --git a/third_party/rust/nix/src/errno.rs b/third_party/rust/nix/src/errno.rs
index 6a2447bc52675..3da246e823969 100644
--- a/third_party/rust/nix/src/errno.rs
+++ b/third_party/rust/nix/src/errno.rs
@@ -1,8 +1,8 @@
-#[cfg(not(target_os = "dragonfly"))]
-use libc;
+use cfg_if::cfg_if;
 use libc::{c_int, c_void};
+use std::convert::TryFrom;
 use std::{fmt, io, error};
-use {Error, Result};
+use crate::{Error, Result};
 
 pub use self::consts::*;
 
@@ -13,41 +13,32 @@ cfg_if! {
         unsafe fn errno_location() -> *mut c_int {
             libc::__error()
         }
-    } else if #[cfg(target_os = "dragonfly")] {
-        // DragonFly uses a thread-local errno variable, but #[thread_local] is
-        // feature-gated and not available in stable Rust as of this writing
-        // (Rust 1.21.0). We have to use a C extension to access it
-        // (src/errno_dragonfly.c).
-        //
-        // Tracking issue for `thread_local` stabilization:
-        //
-        //     https://github.com/rust-lang/rust/issues/29594
-        //
-        // Once this becomes stable, we can remove build.rs,
-        // src/errno_dragonfly.c, and use:
-        //
-        //     extern { #[thread_local] static errno: c_int; }
-        //
-        #[link(name="errno_dragonfly", kind="static")]
-        extern {
-            pub fn errno_location() -> *mut c_int;
-        }
     } else if #[cfg(any(target_os = "android",
                         target_os = "netbsd",
                         target_os = "openbsd"))] {
         unsafe fn errno_location() -> *mut c_int {
             libc::__errno()
         }
-    } else if #[cfg(target_os = "linux")] {
+    } else if #[cfg(any(target_os = "linux",
+                        target_os = "redox",
+                        target_os = "dragonfly",
+                        target_os = "fuchsia"))] {
         unsafe fn errno_location() -> *mut c_int {
             libc::__errno_location()
         }
+    } else if #[cfg(any(target_os = "illumos", target_os = "solaris"))] {
+        unsafe fn errno_location() -> *mut c_int {
+            libc::___errno()
+        }
     }
 }
 
 /// Sets the platform-specific errno to no-error
-unsafe fn clear() -> () {
-    *errno_location() = 0;
+fn clear() {
+    // Safe because errno is a thread-local variable
+    unsafe {
+        *errno_location() = 0;
+    }
 }
 
 /// Returns the platform-specific value of errno
@@ -58,6 +49,43 @@ pub fn errno() -> i32 {
 }
 
 impl Errno {
+    /// Convert this `Error` to an [`Errno`](enum.Errno.html).
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// # use nix::Error;
+    /// # use nix::errno::Errno;
+    /// let e = Error::from(Errno::EPERM);
+    /// assert_eq!(Some(Errno::EPERM), e.as_errno());
+    /// ```
+    #[deprecated(
+        since = "0.22.0",
+        note = "It's a no-op now; just delete it."
+    )]
+    pub const fn as_errno(self) -> Option<Self> {
+        Some(self)
+    }
+
+    /// Create a nix Error from a given errno
+    #[deprecated(
+        since = "0.22.0",
+        note = "It's a no-op now; just delete it."
+    )]
+    #[allow(clippy::wrong_self_convention)] // False positive
+    pub fn from_errno(errno: Errno) -> Error {
+        errno
+    }
+
+    /// Create a new invalid argument error (`EINVAL`)
+    #[deprecated(
+        since = "0.22.0",
+        note = "Use Errno::EINVAL instead"
+    )]
+    pub const fn invalid_argument() -> Error {
+        Errno::EINVAL
+    }
+
     pub fn last() -> Self {
         last()
     }
@@ -66,23 +94,39 @@ impl Errno {
         desc(self)
     }
 
-    pub fn from_i32(err: i32) -> Errno {
+    pub const fn from_i32(err: i32) -> Errno {
         from_i32(err)
     }
 
-    pub unsafe fn clear() -> () {
+    pub fn clear() {
         clear()
     }
 
     /// Returns `Ok(value)` if it does not contain the sentinel value. This
     /// should not be used when `-1` is not the errno sentinel value.
+    #[inline]
     pub fn result<S: ErrnoSentinel + PartialEq<S>>(value: S) -> Result<S> {
         if value == S::sentinel() {
-            Err(Error::Sys(Self::last()))
+            Err(Self::last())
         } else {
             Ok(value)
         }
     }
+
+    /// Backwards compatibility hack for Nix <= 0.21.0 users
+    ///
+    /// In older versions of Nix, `Error::Sys` was an enum variant.  Now it's a
+    /// function, which is compatible with most of the former use cases of the
+    /// enum variant.  But you should use `Error(Errno::...)` instead.
+    #[deprecated(
+        since = "0.22.0",
+        note = "Use Errno::... instead"
+    )]
+    #[allow(non_snake_case)]
+    #[inline]
+    pub const fn Sys(errno: Errno) -> Error {
+        errno
+    }
 }
 
 /// The sentinel value indicates that a function failed and more detailed
@@ -104,18 +148,14 @@ impl ErrnoSentinel for i64 {
 }
 
 impl ErrnoSentinel for *mut c_void {
-    fn sentinel() -> Self { (-1 as isize) as *mut c_void }
+    fn sentinel() -> Self { -1isize as *mut c_void }
 }
 
 impl ErrnoSentinel for libc::sighandler_t {
     fn sentinel() -> Self { libc::SIG_ERR }
 }
 
-impl error::Error for Errno {
-    fn description(&self) -> &str {
-        self.desc()
-    }
-}
+impl error::Error for Errno {}
 
 impl fmt::Display for Errno {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
@@ -129,6 +169,16 @@ impl From<Errno> for io::Error {
     }
 }
 
+impl TryFrom<io::Error> for Errno {
+    type Error = io::Error;
+
+    fn try_from(ioerror: io::Error) -> std::result::Result<Self, io::Error> {
+        ioerror.raw_os_error()
+            .map(Errno::from_i32)
+            .ok_or(ioerror)
+    }
+}
+
 fn last() -> Errno {
     Errno::from_i32(errno())
 }
@@ -207,200 +257,314 @@ fn desc(errno: Errno) -> &'static str {
         EHOSTDOWN       => "Host is down",
         EHOSTUNREACH    => "No route to host",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ECHRNG          => "Channel number out of range",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         EL2NSYNC        => "Level 2 not synchronized",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         EL3HLT          => "Level 3 halted",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         EL3RST          => "Level 3 reset",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ELNRNG          => "Link number out of range",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         EUNATCH         => "Protocol driver not attached",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ENOCSI          => "No CSI structure available",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         EL2HLT          => "Level 2 halted",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         EBADE           => "Invalid exchange",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         EBADR           => "Invalid request descriptor",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         EXFULL          => "Exchange full",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ENOANO          => "No anode",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         EBADRQC         => "Invalid request code",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         EBADSLT         => "Invalid slot",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         EBFONT          => "Bad font file format",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ENOSTR          => "Device not a stream",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ENODATA         => "No data available",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ETIME           => "Timer expired",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ENOSR           => "Out of streams resources",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ENONET          => "Machine is not on the network",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ENOPKG          => "Package not installed",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         EREMOTE         => "Object is remote",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ENOLINK         => "Link has been severed",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         EADV            => "Advertise error",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ESRMNT          => "Srmount error",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ECOMM           => "Communication error on send",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         EPROTO          => "Protocol error",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         EMULTIHOP       => "Multihop attempted",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "fuchsia"))]
         EDOTDOT         => "RFS specific error",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "fuchsia"))]
         EBADMSG         => "Not a data message",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        EBADMSG         => "Trying to read unreadable message",
+
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "fuchsia"))]
         EOVERFLOW       => "Value too large for defined data type",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ENOTUNIQ        => "Name not unique on network",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         EBADFD          => "File descriptor in bad state",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         EREMCHG         => "Remote address changed",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ELIBACC         => "Can not access a needed shared library",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ELIBBAD         => "Accessing a corrupted shared library",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ELIBSCN         => ".lib section in a.out corrupted",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ELIBMAX         => "Attempting to link in too many shared libraries",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ELIBEXEC        => "Cannot exec a shared library directly",
 
-        #[cfg(any(target_os = "linux", target_os = "android", target_os = "openbsd"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia", target_os = "openbsd"))]
         EILSEQ          => "Illegal byte sequence",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ERESTART        => "Interrupted system call should be restarted",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ESTRPIPE        => "Streams pipe error",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         EUSERS          => "Too many users",
 
-        #[cfg(any(target_os = "linux", target_os = "android", target_os = "netbsd"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "fuchsia", target_os = "netbsd",
+                  target_os = "redox"))]
         EOPNOTSUPP      => "Operation not supported on transport endpoint",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "fuchsia"))]
         ESTALE          => "Stale file handle",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "fuchsia"))]
         EUCLEAN         => "Structure needs cleaning",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "fuchsia"))]
         ENOTNAM         => "Not a XENIX named type file",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "fuchsia"))]
         ENAVAIL         => "No XENIX semaphores available",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "fuchsia"))]
         EISNAM          => "Is a named type file",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "fuchsia"))]
         EREMOTEIO       => "Remote I/O error",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "fuchsia"))]
         EDQUOT          => "Quota exceeded",
 
         #[cfg(any(target_os = "linux", target_os = "android",
-                  target_os = "openbsd", target_os = "dragonfly"))]
+                  target_os = "fuchsia", target_os = "openbsd",
+                  target_os = "dragonfly"))]
         ENOMEDIUM       => "No medium found",
 
-        #[cfg(any(target_os = "linux", target_os = "android", target_os = "openbsd"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "fuchsia", target_os = "openbsd"))]
         EMEDIUMTYPE     => "Wrong medium type",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "illumos", target_os = "solaris",
+                  target_os = "fuchsia"))]
         ECANCELED       => "Operation canceled",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "fuchsia"))]
         ENOKEY          => "Required key not available",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "fuchsia"))]
         EKEYEXPIRED     => "Key has expired",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "fuchsia"))]
         EKEYREVOKED     => "Key has been revoked",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "fuchsia"))]
         EKEYREJECTED    => "Key was rejected by service",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "fuchsia"))]
         EOWNERDEAD      => "Owner died",
 
-        #[cfg(any(target_os = "linux", target_os = "android"))]
+        #[cfg(any( target_os = "illumos", target_os = "solaris"))]
+        EOWNERDEAD      => "Process died with lock",
+
+        #[cfg(any(target_os = "linux", target_os = "android",
+                  target_os = "fuchsia"))]
         ENOTRECOVERABLE => "State not recoverable",
 
-        #[cfg(all(target_os = "linux", not(target_arch="mips")))]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        ENOTRECOVERABLE => "Lock is not recoverable",
+
+        #[cfg(any(all(target_os = "linux", not(target_arch="mips")),
+                  target_os = "fuchsia"))]
         ERFKILL         => "Operation not possible due to RF-kill",
 
-        #[cfg(all(target_os = "linux", not(target_arch="mips")))]
+        #[cfg(any(all(target_os = "linux", not(target_arch="mips")),
+                  target_os = "fuchsia"))]
         EHWPOISON       => "Memory page has hardware error",
 
         #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
         EDOOFUS         => "Programming error",
 
-        #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+        #[cfg(any(target_os = "freebsd", target_os = "dragonfly", target_os = "redox"))]
         EMULTIHOP       => "Multihop attempted",
 
-        #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+        #[cfg(any(target_os = "freebsd", target_os = "dragonfly",
+                  target_os = "redox"))]
         ENOLINK         => "Link has been severed",
 
         #[cfg(target_os = "freebsd")]
@@ -416,12 +580,14 @@ fn desc(errno: Errno) -> &'static str {
 
         #[cfg(any(target_os = "macos", target_os = "freebsd",
                   target_os = "dragonfly", target_os = "ios",
-                  target_os = "openbsd", target_os = "netbsd"))]
+                  target_os = "openbsd", target_os = "netbsd",
+                  target_os = "redox", target_os = "illumos",
+                  target_os = "solaris"))]
         EOVERFLOW       => "Value too large to be stored in data type",
 
         #[cfg(any(target_os = "macos", target_os = "freebsd",
                   target_os = "dragonfly", target_os = "ios",
-                  target_os = "netbsd"))]
+                  target_os = "netbsd", target_os = "redox"))]
         EILSEQ          => "Illegal byte sequence",
 
         #[cfg(any(target_os = "macos", target_os = "freebsd",
@@ -431,16 +597,18 @@ fn desc(errno: Errno) -> &'static str {
 
         #[cfg(any(target_os = "macos", target_os = "freebsd",
                   target_os = "dragonfly", target_os = "ios",
-                  target_os = "openbsd", target_os = "netbsd"))]
+                  target_os = "openbsd", target_os = "netbsd",
+                  target_os = "redox"))]
         EBADMSG         => "Bad message",
 
         #[cfg(any(target_os = "macos", target_os = "freebsd",
                   target_os = "dragonfly", target_os = "ios",
-                  target_os = "openbsd", target_os = "netbsd"))]
+                  target_os = "openbsd", target_os = "netbsd",
+                  target_os = "redox"))]
         EPROTO          => "Protocol error",
 
         #[cfg(any(target_os = "macos", target_os = "freebsd",
-                  target_os = "ios", target_os = "openbsd", ))]
+                  target_os = "ios", target_os = "openbsd"))]
         ENOTRECOVERABLE => "State not recoverable",
 
         #[cfg(any(target_os = "macos", target_os = "freebsd",
@@ -449,7 +617,8 @@ fn desc(errno: Errno) -> &'static str {
 
         #[cfg(any(target_os = "macos", target_os = "freebsd",
                   target_os = "dragonfly", target_os = "ios",
-                  target_os = "openbsd", target_os = "netbsd"))]
+                  target_os = "openbsd", target_os = "netbsd",
+                  target_os = "illumos", target_os = "solaris"))]
         ENOTSUP         => "Operation not supported",
 
         #[cfg(any(target_os = "macos", target_os = "freebsd",
@@ -459,22 +628,28 @@ fn desc(errno: Errno) -> &'static str {
 
         #[cfg(any(target_os = "macos", target_os = "freebsd",
                   target_os = "dragonfly", target_os = "ios",
-                  target_os = "openbsd", target_os = "netbsd"))]
+                  target_os = "openbsd", target_os = "netbsd",
+                  target_os = "redox"))]
         EUSERS          => "Too many users",
 
         #[cfg(any(target_os = "macos", target_os = "freebsd",
                   target_os = "dragonfly", target_os = "ios",
-                  target_os = "openbsd", target_os = "netbsd"))]
+                  target_os = "openbsd", target_os = "netbsd",
+                  target_os = "redox", target_os = "illumos",
+                  target_os = "solaris"))]
         EDQUOT          => "Disc quota exceeded",
 
         #[cfg(any(target_os = "macos", target_os = "freebsd",
                   target_os = "dragonfly", target_os = "ios",
-                  target_os = "openbsd", target_os = "netbsd"))]
+                  target_os = "openbsd", target_os = "netbsd",
+                  target_os = "redox", target_os = "illumos",
+                  target_os = "solaris"))]
         ESTALE          => "Stale NFS file handle",
 
         #[cfg(any(target_os = "macos", target_os = "freebsd",
                   target_os = "dragonfly", target_os = "ios",
-                  target_os = "openbsd", target_os = "netbsd"))]
+                  target_os = "openbsd", target_os = "netbsd",
+                  target_os = "redox"))]
         EREMOTE         => "Too many levels of remote in path",
 
         #[cfg(any(target_os = "macos", target_os = "freebsd",
@@ -514,7 +689,8 @@ fn desc(errno: Errno) -> &'static str {
 
         #[cfg(any(target_os = "macos", target_os = "freebsd",
                   target_os = "dragonfly", target_os = "ios",
-                  target_os = "openbsd", target_os = "netbsd"))]
+                  target_os = "openbsd", target_os = "netbsd",
+                  target_os = "redox"))]
         ECANCELED       => "Operation canceled",
 
         #[cfg(any(target_os = "macos", target_os = "ios"))]
@@ -535,25 +711,32 @@ fn desc(errno: Errno) -> &'static str {
         #[cfg(any(target_os = "macos", target_os = "ios"))]
         EBADMACHO       => "Malformed Macho file",
 
-        #[cfg(any(target_os = "macos", target_os = "ios", target_os = "netbsd"))]
+        #[cfg(any(target_os = "macos", target_os = "ios",
+                  target_os = "netbsd"))]
         EMULTIHOP       => "Reserved",
 
-        #[cfg(any(target_os = "macos", target_os = "ios", target_os = "netbsd"))]
+        #[cfg(any(target_os = "macos", target_os = "ios",
+                  target_os = "netbsd", target_os = "redox"))]
         ENODATA         => "No message available on STREAM",
 
-        #[cfg(any(target_os = "macos", target_os = "ios", target_os = "netbsd"))]
+        #[cfg(any(target_os = "macos", target_os = "ios",
+                  target_os = "netbsd"))]
         ENOLINK         => "Reserved",
 
-        #[cfg(any(target_os = "macos", target_os = "ios", target_os = "netbsd"))]
+        #[cfg(any(target_os = "macos", target_os = "ios",
+                  target_os = "netbsd", target_os = "redox"))]
         ENOSR           => "No STREAM resources",
 
-        #[cfg(any(target_os = "macos", target_os = "ios", target_os = "netbsd"))]
+        #[cfg(any(target_os = "macos", target_os = "ios",
+                  target_os = "netbsd", target_os = "redox"))]
         ENOSTR          => "Not a STREAM",
 
-        #[cfg(any(target_os = "macos", target_os = "ios", target_os = "netbsd"))]
+        #[cfg(any(target_os = "macos", target_os = "ios",
+                  target_os = "netbsd", target_os = "redox"))]
         ETIME           => "STREAM ioctl timeout",
 
-        #[cfg(any(target_os = "macos", target_os = "ios"))]
+        #[cfg(any(target_os = "macos", target_os = "ios",
+                  target_os = "illumos", target_os = "solaris"))]
         EOPNOTSUPP      => "Operation not supported on socket",
 
         #[cfg(any(target_os = "macos", target_os = "ios"))]
@@ -570,15 +753,24 @@ fn desc(errno: Errno) -> &'static str {
 
         #[cfg(target_os = "dragonfly")]
         EASYNC          => "Async",
+
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        EDEADLOCK       => "Resource deadlock would occur",
+
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        ELOCKUNMAPPED   => "Locked lock was unmapped",
+
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        ENOTACTIVE      => "Facility is not active",
     }
 }
 
-#[cfg(any(target_os = "linux", target_os = "android"))]
+#[cfg(any(target_os = "linux", target_os = "android",
+          target_os = "fuchsia"))]
 mod consts {
-    use libc;
-
     #[derive(Clone, Copy, Debug, Eq, PartialEq)]
     #[repr(i32)]
+    #[non_exhaustive]
     pub enum Errno {
         UnknownErrno    = 0,
         EPERM           = libc::EPERM,
@@ -716,11 +908,29 @@ mod consts {
         EHWPOISON       = libc::EHWPOISON,
     }
 
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::EWOULDBLOCK instead"
+    )]
     pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::EDEADLOCK instead"
+    )]
     pub const EDEADLOCK:   Errno = Errno::EDEADLK;
-    pub const ENOTSUP:     Errno = Errno::EOPNOTSUPP;
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::ENOTSUP instead"
+    )]
+    pub const ENOTSUP:  Errno = Errno::EOPNOTSUPP;
+
+    impl Errno {
+        pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
+        pub const EDEADLOCK:   Errno = Errno::EDEADLK;
+        pub const ENOTSUP:     Errno = Errno::EOPNOTSUPP;
+    }
 
-    pub fn from_i32(e: i32) -> Errno {
+    pub const fn from_i32(e: i32) -> Errno {
         use self::Errno::*;
 
         match e {
@@ -864,10 +1074,9 @@ mod consts {
 
 #[cfg(any(target_os = "macos", target_os = "ios"))]
 mod consts {
-    use libc;
-
     #[derive(Clone, Copy, Debug, Eq, PartialEq)]
     #[repr(i32)]
+    #[non_exhaustive]
     pub enum Errno {
         UnknownErrno    = 0,
         EPERM           = libc::EPERM,
@@ -978,13 +1187,29 @@ mod consts {
         EQFULL          = libc::EQFULL,
     }
 
-    pub const ELAST: Errno       = Errno::EQFULL;
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::ELAST instead"
+    )]
+    pub const ELAST:  Errno = Errno::EQFULL;
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::EWOULDBLOCK instead"
+    )]
     pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::EDEADLOCK instead"
+    )]
     pub const EDEADLOCK:   Errno = Errno::EDEADLK;
 
-    pub const EL2NSYNC: Errno = Errno::UnknownErrno;
+    impl Errno {
+        pub const ELAST: Errno       = Errno::EQFULL;
+        pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
+        pub const EDEADLOCK:   Errno = Errno::EDEADLK;
+    }
 
-    pub fn from_i32(e: i32) -> Errno {
+    pub const fn from_i32(e: i32) -> Errno {
         use self::Errno::*;
 
         match e {
@@ -1101,10 +1326,9 @@ mod consts {
 
 #[cfg(target_os = "freebsd")]
 mod consts {
-    use libc;
-
     #[derive(Clone, Copy, Debug, Eq, PartialEq)]
     #[repr(i32)]
+    #[non_exhaustive]
     pub enum Errno {
         UnknownErrno    = 0,
         EPERM           = libc::EPERM,
@@ -1205,13 +1429,35 @@ mod consts {
         EOWNERDEAD      = libc::EOWNERDEAD,
     }
 
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::ELAST instead"
+    )]
     pub const ELAST: Errno       = Errno::EOWNERDEAD;
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::EWOULDBLOCK instead"
+    )]
     pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::EDEADLOCK instead"
+    )]
     pub const EDEADLOCK:   Errno = Errno::EDEADLK;
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::EOPNOTSUPP instead"
+    )]
+    pub const EOPNOTSUPP:  Errno = Errno::ENOTSUP;
 
-    pub const EL2NSYNC: Errno = Errno::UnknownErrno;
+    impl Errno {
+        pub const ELAST: Errno       = Errno::EOWNERDEAD;
+        pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
+        pub const EDEADLOCK:   Errno = Errno::EDEADLK;
+        pub const EOPNOTSUPP:  Errno = Errno::ENOTSUP;
+    }
 
-    pub fn from_i32(e: i32) -> Errno {
+    pub const fn from_i32(e: i32) -> Errno {
         use self::Errno::*;
 
         match e {
@@ -1319,10 +1565,9 @@ mod consts {
 
 #[cfg(target_os = "dragonfly")]
 mod consts {
-    use libc;
-
     #[derive(Clone, Copy, Debug, Eq, PartialEq)]
     #[repr(i32)]
+    #[non_exhaustive]
     pub enum Errno {
         UnknownErrno    = 0,
         EPERM           = libc::EPERM,
@@ -1421,14 +1666,35 @@ mod consts {
         EASYNC          = libc::EASYNC,
     }
 
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::ELAST instead"
+    )]
     pub const ELAST: Errno       = Errno::EASYNC;
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::EWOULDBLOCK instead"
+    )]
     pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::EDEADLOCK instead"
+    )]
     pub const EDEADLOCK:   Errno = Errno::EDEADLK;
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::EOPNOTSUPP instead"
+    )]
     pub const EOPNOTSUPP:  Errno = Errno::ENOTSUP;
 
-    pub const EL2NSYNC: Errno = Errno::UnknownErrno;
+    impl Errno {
+        pub const ELAST: Errno       = Errno::EASYNC;
+        pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
+        pub const EDEADLOCK:   Errno = Errno::EDEADLK;
+        pub const EOPNOTSUPP:  Errno = Errno::ENOTSUP;
+    }
 
-    pub fn from_i32(e: i32) -> Errno {
+    pub const fn from_i32(e: i32) -> Errno {
         use self::Errno::*;
 
         match e {
@@ -1534,10 +1800,9 @@ mod consts {
 
 #[cfg(target_os = "openbsd")]
 mod consts {
-    use libc;
-
     #[derive(Clone, Copy, Debug, Eq, PartialEq)]
     #[repr(i32)]
+    #[non_exhaustive]
     pub enum Errno {
         UnknownErrno    = 0,
         EPERM           = libc::EPERM,
@@ -1637,12 +1902,23 @@ mod consts {
         EPROTO          = libc::EPROTO,
     }
 
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::ELAST instead"
+    )]
     pub const ELAST: Errno       = Errno::ENOTSUP;
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::EWOULDBLOCK instead"
+    )]
     pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
 
-    pub const EL2NSYNC: Errno = Errno::UnknownErrno;
+    impl Errno {
+        pub const ELAST: Errno       = Errno::ENOTSUP;
+        pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
+    }
 
-    pub fn from_i32(e: i32) -> Errno {
+    pub const fn from_i32(e: i32) -> Errno {
         use self::Errno::*;
 
         match e {
@@ -1748,10 +2024,9 @@ mod consts {
 
 #[cfg(target_os = "netbsd")]
 mod consts {
-    use libc;
-
     #[derive(Clone, Copy, Debug, Eq, PartialEq)]
     #[repr(i32)]
+    #[non_exhaustive]
     pub enum Errno {
         UnknownErrno    = 0,
         EPERM           = libc::EPERM,
@@ -1852,12 +2127,23 @@ mod consts {
         EPROTO          = libc::EPROTO,
     }
 
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::ELAST instead"
+    )]
     pub const ELAST: Errno       = Errno::ENOTSUP;
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::EWOULDBLOCK instead"
+    )]
     pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
 
-    pub const EL2NSYNC: Errno = Errno::UnknownErrno;
+    impl Errno {
+        pub const ELAST: Errno       = Errno::ENOTSUP;
+        pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
+    }
 
-    pub fn from_i32(e: i32) -> Errno {
+    pub const fn from_i32(e: i32) -> Errno {
         use self::Errno::*;
 
         match e {
@@ -1961,3 +2247,477 @@ mod consts {
         }
     }
 }
+
+#[cfg(target_os = "redox")]
+mod consts {
+    #[derive(Clone, Copy, Debug, Eq, PartialEq)]
+    #[repr(i32)]
+    #[non_exhaustive]
+    pub enum Errno {
+        UnknownErrno = 0,
+        EPERM = libc::EPERM,
+        ENOENT = libc::ENOENT,
+        ESRCH = libc::ESRCH,
+        EINTR = libc::EINTR,
+        EIO = libc::EIO,
+        ENXIO = libc::ENXIO,
+        E2BIG = libc::E2BIG,
+        ENOEXEC = libc::ENOEXEC,
+        EBADF = libc::EBADF,
+        ECHILD = libc::ECHILD,
+        EDEADLK = libc::EDEADLK,
+        ENOMEM = libc::ENOMEM,
+        EACCES = libc::EACCES,
+        EFAULT = libc::EFAULT,
+        ENOTBLK = libc::ENOTBLK,
+        EBUSY = libc::EBUSY,
+        EEXIST = libc::EEXIST,
+        EXDEV = libc::EXDEV,
+        ENODEV = libc::ENODEV,
+        ENOTDIR = libc::ENOTDIR,
+        EISDIR = libc::EISDIR,
+        EINVAL = libc::EINVAL,
+        ENFILE = libc::ENFILE,
+        EMFILE = libc::EMFILE,
+        ENOTTY = libc::ENOTTY,
+        ETXTBSY = libc::ETXTBSY,
+        EFBIG = libc::EFBIG,
+        ENOSPC = libc::ENOSPC,
+        ESPIPE = libc::ESPIPE,
+        EROFS = libc::EROFS,
+        EMLINK = libc::EMLINK,
+        EPIPE = libc::EPIPE,
+        EDOM = libc::EDOM,
+        ERANGE = libc::ERANGE,
+        EAGAIN = libc::EAGAIN,
+        EINPROGRESS = libc::EINPROGRESS,
+        EALREADY = libc::EALREADY,
+        ENOTSOCK = libc::ENOTSOCK,
+        EDESTADDRREQ = libc::EDESTADDRREQ,
+        EMSGSIZE = libc::EMSGSIZE,
+        EPROTOTYPE = libc::EPROTOTYPE,
+        ENOPROTOOPT = libc::ENOPROTOOPT,
+        EPROTONOSUPPORT = libc::EPROTONOSUPPORT,
+        ESOCKTNOSUPPORT = libc::ESOCKTNOSUPPORT,
+        EOPNOTSUPP = libc::EOPNOTSUPP,
+        EPFNOSUPPORT = libc::EPFNOSUPPORT,
+        EAFNOSUPPORT = libc::EAFNOSUPPORT,
+        EADDRINUSE = libc::EADDRINUSE,
+        EADDRNOTAVAIL = libc::EADDRNOTAVAIL,
+        ENETDOWN = libc::ENETDOWN,
+        ENETUNREACH = libc::ENETUNREACH,
+        ENETRESET = libc::ENETRESET,
+        ECONNABORTED = libc::ECONNABORTED,
+        ECONNRESET = libc::ECONNRESET,
+        ENOBUFS = libc::ENOBUFS,
+        EISCONN = libc::EISCONN,
+        ENOTCONN = libc::ENOTCONN,
+        ESHUTDOWN = libc::ESHUTDOWN,
+        ETOOMANYREFS = libc::ETOOMANYREFS,
+        ETIMEDOUT = libc::ETIMEDOUT,
+        ECONNREFUSED = libc::ECONNREFUSED,
+        ELOOP = libc::ELOOP,
+        ENAMETOOLONG = libc::ENAMETOOLONG,
+        EHOSTDOWN = libc::EHOSTDOWN,
+        EHOSTUNREACH = libc::EHOSTUNREACH,
+        ENOTEMPTY = libc::ENOTEMPTY,
+        EUSERS = libc::EUSERS,
+        EDQUOT = libc::EDQUOT,
+        ESTALE = libc::ESTALE,
+        EREMOTE = libc::EREMOTE,
+        ENOLCK = libc::ENOLCK,
+        ENOSYS = libc::ENOSYS,
+        EIDRM = libc::EIDRM,
+        ENOMSG = libc::ENOMSG,
+        EOVERFLOW = libc::EOVERFLOW,
+        EILSEQ = libc::EILSEQ,
+        ECANCELED = libc::ECANCELED,
+        EBADMSG = libc::EBADMSG,
+        ENODATA = libc::ENODATA,
+        ENOSR = libc::ENOSR,
+        ENOSTR = libc::ENOSTR,
+        ETIME = libc::ETIME,
+        EMULTIHOP = libc::EMULTIHOP,
+        ENOLINK = libc::ENOLINK,
+        EPROTO = libc::EPROTO,
+    }
+
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::EWOULDBLOCK instead"
+    )]
+    pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
+
+    impl Errno {
+        pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
+    }
+
+    pub const fn from_i32(e: i32) -> Errno {
+        use self::Errno::*;
+
+        match e {
+            libc::EPERM => EPERM,
+            libc::ENOENT => ENOENT,
+            libc::ESRCH => ESRCH,
+            libc::EINTR => EINTR,
+            libc::EIO => EIO,
+            libc::ENXIO => ENXIO,
+            libc::E2BIG => E2BIG,
+            libc::ENOEXEC => ENOEXEC,
+            libc::EBADF => EBADF,
+            libc::ECHILD => ECHILD,
+            libc::EDEADLK => EDEADLK,
+            libc::ENOMEM => ENOMEM,
+            libc::EACCES => EACCES,
+            libc::EFAULT => EFAULT,
+            libc::ENOTBLK => ENOTBLK,
+            libc::EBUSY => EBUSY,
+            libc::EEXIST => EEXIST,
+            libc::EXDEV => EXDEV,
+            libc::ENODEV => ENODEV,
+            libc::ENOTDIR => ENOTDIR,
+            libc::EISDIR => EISDIR,
+            libc::EINVAL => EINVAL,
+            libc::ENFILE => ENFILE,
+            libc::EMFILE => EMFILE,
+            libc::ENOTTY => ENOTTY,
+            libc::ETXTBSY => ETXTBSY,
+            libc::EFBIG => EFBIG,
+            libc::ENOSPC => ENOSPC,
+            libc::ESPIPE => ESPIPE,
+            libc::EROFS => EROFS,
+            libc::EMLINK => EMLINK,
+            libc::EPIPE => EPIPE,
+            libc::EDOM => EDOM,
+            libc::ERANGE => ERANGE,
+            libc::EAGAIN => EAGAIN,
+            libc::EINPROGRESS => EINPROGRESS,
+            libc::EALREADY => EALREADY,
+            libc::ENOTSOCK => ENOTSOCK,
+            libc::EDESTADDRREQ => EDESTADDRREQ,
+            libc::EMSGSIZE => EMSGSIZE,
+            libc::EPROTOTYPE => EPROTOTYPE,
+            libc::ENOPROTOOPT => ENOPROTOOPT,
+            libc::EPROTONOSUPPORT => EPROTONOSUPPORT,
+            libc::ESOCKTNOSUPPORT => ESOCKTNOSUPPORT,
+            libc::EOPNOTSUPP => EOPNOTSUPP,
+            libc::EPFNOSUPPORT => EPFNOSUPPORT,
+            libc::EAFNOSUPPORT => EAFNOSUPPORT,
+            libc::EADDRINUSE => EADDRINUSE,
+            libc::EADDRNOTAVAIL => EADDRNOTAVAIL,
+            libc::ENETDOWN => ENETDOWN,
+            libc::ENETUNREACH => ENETUNREACH,
+            libc::ENETRESET => ENETRESET,
+            libc::ECONNABORTED => ECONNABORTED,
+            libc::ECONNRESET => ECONNRESET,
+            libc::ENOBUFS => ENOBUFS,
+            libc::EISCONN => EISCONN,
+            libc::ENOTCONN => ENOTCONN,
+            libc::ESHUTDOWN => ESHUTDOWN,
+            libc::ETOOMANYREFS => ETOOMANYREFS,
+            libc::ETIMEDOUT => ETIMEDOUT,
+            libc::ECONNREFUSED => ECONNREFUSED,
+            libc::ELOOP => ELOOP,
+            libc::ENAMETOOLONG => ENAMETOOLONG,
+            libc::EHOSTDOWN => EHOSTDOWN,
+            libc::EHOSTUNREACH => EHOSTUNREACH,
+            libc::ENOTEMPTY => ENOTEMPTY,
+            libc::EUSERS => EUSERS,
+            libc::EDQUOT => EDQUOT,
+            libc::ESTALE => ESTALE,
+            libc::EREMOTE => EREMOTE,
+            libc::ENOLCK => ENOLCK,
+            libc::ENOSYS => ENOSYS,
+            libc::EIDRM => EIDRM,
+            libc::ENOMSG => ENOMSG,
+            libc::EOVERFLOW => EOVERFLOW,
+            libc::EILSEQ => EILSEQ,
+            libc::ECANCELED => ECANCELED,
+            libc::EBADMSG => EBADMSG,
+            libc::ENODATA => ENODATA,
+            libc::ENOSR => ENOSR,
+            libc::ENOSTR => ENOSTR,
+            libc::ETIME => ETIME,
+            libc::EMULTIHOP => EMULTIHOP,
+            libc::ENOLINK => ENOLINK,
+            libc::EPROTO => EPROTO,
+            _ => UnknownErrno,
+        }
+    }
+}
+
+#[cfg(any(target_os = "illumos", target_os = "solaris"))]
+mod consts {
+    #[derive(Clone, Copy, Debug, Eq, PartialEq)]
+    #[repr(i32)]
+    #[non_exhaustive]
+    pub enum Errno {
+        UnknownErrno = 0,
+        EPERM = libc::EPERM,
+        ENOENT = libc::ENOENT,
+        ESRCH = libc::ESRCH,
+        EINTR = libc::EINTR,
+        EIO = libc::EIO,
+        ENXIO = libc::ENXIO,
+        E2BIG = libc::E2BIG,
+        ENOEXEC = libc::ENOEXEC,
+        EBADF = libc::EBADF,
+        ECHILD = libc::ECHILD,
+        EAGAIN = libc::EAGAIN,
+        ENOMEM = libc::ENOMEM,
+        EACCES = libc::EACCES,
+        EFAULT = libc::EFAULT,
+        ENOTBLK = libc::ENOTBLK,
+        EBUSY = libc::EBUSY,
+        EEXIST = libc::EEXIST,
+        EXDEV = libc::EXDEV,
+        ENODEV = libc::ENODEV,
+        ENOTDIR = libc::ENOTDIR,
+        EISDIR = libc::EISDIR,
+        EINVAL = libc::EINVAL,
+        ENFILE = libc::ENFILE,
+        EMFILE = libc::EMFILE,
+        ENOTTY = libc::ENOTTY,
+        ETXTBSY = libc::ETXTBSY,
+        EFBIG = libc::EFBIG,
+        ENOSPC = libc::ENOSPC,
+        ESPIPE = libc::ESPIPE,
+        EROFS = libc::EROFS,
+        EMLINK = libc::EMLINK,
+        EPIPE = libc::EPIPE,
+        EDOM = libc::EDOM,
+        ERANGE = libc::ERANGE,
+        ENOMSG = libc::ENOMSG,
+        EIDRM = libc::EIDRM,
+        ECHRNG = libc::ECHRNG,
+        EL2NSYNC = libc::EL2NSYNC,
+        EL3HLT = libc::EL3HLT,
+        EL3RST = libc::EL3RST,
+        ELNRNG = libc::ELNRNG,
+        EUNATCH = libc::EUNATCH,
+        ENOCSI = libc::ENOCSI,
+        EL2HLT = libc::EL2HLT,
+        EDEADLK = libc::EDEADLK,
+        ENOLCK = libc::ENOLCK,
+        ECANCELED = libc::ECANCELED,
+        ENOTSUP = libc::ENOTSUP,
+        EDQUOT = libc::EDQUOT,
+        EBADE = libc::EBADE,
+        EBADR = libc::EBADR,
+        EXFULL = libc::EXFULL,
+        ENOANO = libc::ENOANO,
+        EBADRQC = libc::EBADRQC,
+        EBADSLT = libc::EBADSLT,
+        EDEADLOCK = libc::EDEADLOCK,
+        EBFONT = libc::EBFONT,
+        EOWNERDEAD = libc::EOWNERDEAD,
+        ENOTRECOVERABLE = libc::ENOTRECOVERABLE,
+        ENOSTR = libc::ENOSTR,
+        ENODATA = libc::ENODATA,
+        ETIME = libc::ETIME,
+        ENOSR = libc::ENOSR,
+        ENONET = libc::ENONET,
+        ENOPKG = libc::ENOPKG,
+        EREMOTE = libc::EREMOTE,
+        ENOLINK = libc::ENOLINK,
+        EADV = libc::EADV,
+        ESRMNT = libc::ESRMNT,
+        ECOMM = libc::ECOMM,
+        EPROTO = libc::EPROTO,
+        ELOCKUNMAPPED = libc::ELOCKUNMAPPED,
+        ENOTACTIVE = libc::ENOTACTIVE,
+        EMULTIHOP = libc::EMULTIHOP,
+        EBADMSG = libc::EBADMSG,
+        ENAMETOOLONG = libc::ENAMETOOLONG,
+        EOVERFLOW = libc::EOVERFLOW,
+        ENOTUNIQ = libc::ENOTUNIQ,
+        EBADFD = libc::EBADFD,
+        EREMCHG = libc::EREMCHG,
+        ELIBACC = libc::ELIBACC,
+        ELIBBAD = libc::ELIBBAD,
+        ELIBSCN = libc::ELIBSCN,
+        ELIBMAX = libc::ELIBMAX,
+        ELIBEXEC = libc::ELIBEXEC,
+        EILSEQ = libc::EILSEQ,
+        ENOSYS = libc::ENOSYS,
+        ELOOP = libc::ELOOP,
+        ERESTART = libc::ERESTART,
+        ESTRPIPE = libc::ESTRPIPE,
+        ENOTEMPTY = libc::ENOTEMPTY,
+        EUSERS = libc::EUSERS,
+        ENOTSOCK = libc::ENOTSOCK,
+        EDESTADDRREQ = libc::EDESTADDRREQ,
+        EMSGSIZE = libc::EMSGSIZE,
+        EPROTOTYPE = libc::EPROTOTYPE,
+        ENOPROTOOPT = libc::ENOPROTOOPT,
+        EPROTONOSUPPORT = libc::EPROTONOSUPPORT,
+        ESOCKTNOSUPPORT = libc::ESOCKTNOSUPPORT,
+        EOPNOTSUPP = libc::EOPNOTSUPP,
+        EPFNOSUPPORT = libc::EPFNOSUPPORT,
+        EAFNOSUPPORT = libc::EAFNOSUPPORT,
+        EADDRINUSE = libc::EADDRINUSE,
+        EADDRNOTAVAIL = libc::EADDRNOTAVAIL,
+        ENETDOWN = libc::ENETDOWN,
+        ENETUNREACH = libc::ENETUNREACH,
+        ENETRESET = libc::ENETRESET,
+        ECONNABORTED = libc::ECONNABORTED,
+        ECONNRESET = libc::ECONNRESET,
+        ENOBUFS = libc::ENOBUFS,
+        EISCONN = libc::EISCONN,
+        ENOTCONN = libc::ENOTCONN,
+        ESHUTDOWN = libc::ESHUTDOWN,
+        ETOOMANYREFS = libc::ETOOMANYREFS,
+        ETIMEDOUT = libc::ETIMEDOUT,
+        ECONNREFUSED = libc::ECONNREFUSED,
+        EHOSTDOWN = libc::EHOSTDOWN,
+        EHOSTUNREACH = libc::EHOSTUNREACH,
+        EALREADY = libc::EALREADY,
+        EINPROGRESS = libc::EINPROGRESS,
+        ESTALE = libc::ESTALE,
+    }
+
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::ELAST instead"
+    )]
+    pub const ELAST: Errno = Errno::ELAST;
+    #[deprecated(
+        since = "0.22.1",
+        note = "use nix::errno::Errno::EWOULDBLOCK instead"
+    )]
+    pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
+
+    impl Errno {
+        pub const ELAST: Errno       = Errno::ESTALE;
+        pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
+    }
+
+    pub const fn from_i32(e: i32) -> Errno {
+        use self::Errno::*;
+
+        match e {
+            libc::EPERM => EPERM,
+            libc::ENOENT => ENOENT,
+            libc::ESRCH => ESRCH,
+            libc::EINTR => EINTR,
+            libc::EIO => EIO,
+            libc::ENXIO => ENXIO,
+            libc::E2BIG => E2BIG,
+            libc::ENOEXEC => ENOEXEC,
+            libc::EBADF => EBADF,
+            libc::ECHILD => ECHILD,
+            libc::EAGAIN => EAGAIN,
+            libc::ENOMEM => ENOMEM,
+            libc::EACCES => EACCES,
+            libc::EFAULT => EFAULT,
+            libc::ENOTBLK => ENOTBLK,
+            libc::EBUSY => EBUSY,
+            libc::EEXIST => EEXIST,
+            libc::EXDEV => EXDEV,
+            libc::ENODEV => ENODEV,
+            libc::ENOTDIR => ENOTDIR,
+            libc::EISDIR => EISDIR,
+            libc::EINVAL => EINVAL,
+            libc::ENFILE => ENFILE,
+            libc::EMFILE => EMFILE,
+            libc::ENOTTY => ENOTTY,
+            libc::ETXTBSY => ETXTBSY,
+            libc::EFBIG => EFBIG,
+            libc::ENOSPC => ENOSPC,
+            libc::ESPIPE => ESPIPE,
+            libc::EROFS => EROFS,
+            libc::EMLINK => EMLINK,
+            libc::EPIPE => EPIPE,
+            libc::EDOM => EDOM,
+            libc::ERANGE => ERANGE,
+            libc::ENOMSG => ENOMSG,
+            libc::EIDRM => EIDRM,
+            libc::ECHRNG => ECHRNG,
+            libc::EL2NSYNC => EL2NSYNC,
+            libc::EL3HLT => EL3HLT,
+            libc::EL3RST => EL3RST,
+            libc::ELNRNG => ELNRNG,
+            libc::EUNATCH => EUNATCH,
+            libc::ENOCSI => ENOCSI,
+            libc::EL2HLT => EL2HLT,
+            libc::EDEADLK => EDEADLK,
+            libc::ENOLCK => ENOLCK,
+            libc::ECANCELED => ECANCELED,
+            libc::ENOTSUP => ENOTSUP,
+            libc::EDQUOT => EDQUOT,
+            libc::EBADE => EBADE,
+            libc::EBADR => EBADR,
+            libc::EXFULL => EXFULL,
+            libc::ENOANO => ENOANO,
+            libc::EBADRQC => EBADRQC,
+            libc::EBADSLT => EBADSLT,
+            libc::EDEADLOCK => EDEADLOCK,
+            libc::EBFONT => EBFONT,
+            libc::EOWNERDEAD => EOWNERDEAD,
+            libc::ENOTRECOVERABLE => ENOTRECOVERABLE,
+            libc::ENOSTR => ENOSTR,
+            libc::ENODATA => ENODATA,
+            libc::ETIME => ETIME,
+            libc::ENOSR => ENOSR,
+            libc::ENONET => ENONET,
+            libc::ENOPKG => ENOPKG,
+            libc::EREMOTE => EREMOTE,
+            libc::ENOLINK => ENOLINK,
+            libc::EADV => EADV,
+            libc::ESRMNT => ESRMNT,
+            libc::ECOMM => ECOMM,
+            libc::EPROTO => EPROTO,
+            libc::ELOCKUNMAPPED => ELOCKUNMAPPED,
+            libc::ENOTACTIVE => ENOTACTIVE,
+            libc::EMULTIHOP => EMULTIHOP,
+            libc::EBADMSG => EBADMSG,
+            libc::ENAMETOOLONG => ENAMETOOLONG,
+            libc::EOVERFLOW => EOVERFLOW,
+            libc::ENOTUNIQ => ENOTUNIQ,
+            libc::EBADFD => EBADFD,
+            libc::EREMCHG => EREMCHG,
+            libc::ELIBACC => ELIBACC,
+            libc::ELIBBAD => ELIBBAD,
+            libc::ELIBSCN => ELIBSCN,
+            libc::ELIBMAX => ELIBMAX,
+            libc::ELIBEXEC => ELIBEXEC,
+            libc::EILSEQ => EILSEQ,
+            libc::ENOSYS => ENOSYS,
+            libc::ELOOP => ELOOP,
+            libc::ERESTART => ERESTART,
+            libc::ESTRPIPE => ESTRPIPE,
+            libc::ENOTEMPTY => ENOTEMPTY,
+            libc::EUSERS => EUSERS,
+            libc::ENOTSOCK => ENOTSOCK,
+            libc::EDESTADDRREQ => EDESTADDRREQ,
+            libc::EMSGSIZE => EMSGSIZE,
+            libc::EPROTOTYPE => EPROTOTYPE,
+            libc::ENOPROTOOPT => ENOPROTOOPT,
+            libc::EPROTONOSUPPORT => EPROTONOSUPPORT,
+            libc::ESOCKTNOSUPPORT => ESOCKTNOSUPPORT,
+            libc::EOPNOTSUPP => EOPNOTSUPP,
+            libc::EPFNOSUPPORT => EPFNOSUPPORT,
+            libc::EAFNOSUPPORT => EAFNOSUPPORT,
+            libc::EADDRINUSE => EADDRINUSE,
+            libc::EADDRNOTAVAIL => EADDRNOTAVAIL,
+            libc::ENETDOWN => ENETDOWN,
+            libc::ENETUNREACH => ENETUNREACH,
+            libc::ENETRESET => ENETRESET,
+            libc::ECONNABORTED => ECONNABORTED,
+            libc::ECONNRESET => ECONNRESET,
+            libc::ENOBUFS => ENOBUFS,
+            libc::EISCONN => EISCONN,
+            libc::ENOTCONN => ENOTCONN,
+            libc::ESHUTDOWN => ESHUTDOWN,
+            libc::ETOOMANYREFS => ETOOMANYREFS,
+            libc::ETIMEDOUT => ETIMEDOUT,
+            libc::ECONNREFUSED => ECONNREFUSED,
+            libc::EHOSTDOWN => EHOSTDOWN,
+            libc::EHOSTUNREACH => EHOSTUNREACH,
+            libc::EALREADY => EALREADY,
+            libc::EINPROGRESS => EINPROGRESS,
+            libc::ESTALE => ESTALE,
+            _ => UnknownErrno,
+        }
+    }
+}
diff --git a/third_party/rust/nix/src/errno_dragonfly.c b/third_party/rust/nix/src/errno_dragonfly.c
deleted file mode 100644
index 32fb4dab4d137..0000000000000
--- a/third_party/rust/nix/src/errno_dragonfly.c
+++ /dev/null
@@ -1,3 +0,0 @@
-#include <errno.h>
-
-int *errno_location() { return &errno; }
diff --git a/third_party/rust/nix/src/fcntl.rs b/third_party/rust/nix/src/fcntl.rs
index be6ee0f73a8be..dd8e59a6ec49f 100644
--- a/third_party/rust/nix/src/fcntl.rs
+++ b/third_party/rust/nix/src/fcntl.rs
@@ -1,34 +1,41 @@
-use {Error, Result, NixPath};
-use errno::Errno;
-use libc::{self, c_int, c_uint, c_char, size_t, ssize_t};
-use sys::stat::Mode;
+use crate::errno::Errno;
+use libc::{self, c_char, c_int, c_uint, size_t, ssize_t};
+use std::ffi::OsString;
+#[cfg(not(target_os = "redox"))]
 use std::os::raw;
+use std::os::unix::ffi::OsStringExt;
 use std::os::unix::io::RawFd;
-use std::ffi::OsStr;
-use std::os::unix::ffi::OsStrExt;
+use crate::sys::stat::Mode;
+use crate::{NixPath, Result};
 
 #[cfg(any(target_os = "android", target_os = "linux"))]
 use std::ptr; // For splice and copy_file_range
 #[cfg(any(target_os = "android", target_os = "linux"))]
-use sys::uio::IoVec;  // For vmsplice
-
-#[cfg(any(target_os = "linux",
-          target_os = "android",
-          target_os = "emscripten",
-          target_os = "fuchsia",
-          any(target_os = "wasi", target_env = "wasi"),
-          target_env = "uclibc",
-          target_env = "freebsd"))]
+use crate::sys::uio::IoVec; // For vmsplice
+
+#[cfg(any(
+    target_os = "linux",
+    target_os = "android",
+    target_os = "emscripten",
+    target_os = "fuchsia",
+    any(target_os = "wasi", target_env = "wasi"),
+    target_env = "uclibc",
+    target_os = "freebsd"
+))]
 pub use self::posix_fadvise::*;
 
-libc_bitflags!{
+#[cfg(not(target_os = "redox"))]
+libc_bitflags! {
     pub struct AtFlags: c_int {
         AT_REMOVEDIR;
+        AT_SYMLINK_FOLLOW;
         AT_SYMLINK_NOFOLLOW;
         #[cfg(any(target_os = "android", target_os = "linux"))]
         AT_NO_AUTOMOUNT;
         #[cfg(any(target_os = "android", target_os = "linux"))]
         AT_EMPTY_PATH;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        AT_EACCESS;
     }
 }
 
@@ -43,6 +50,7 @@ libc_bitflags!(
         /// Open the file in append-only mode.
         O_APPEND;
         /// Generate a signal when input or output becomes possible.
+        #[cfg(not(any(target_os = "illumos", target_os = "solaris")))]
         O_ASYNC;
         /// Closes the file descriptor once an `execve` call is made.
         ///
@@ -58,6 +66,7 @@ libc_bitflags!(
                   target_os = "netbsd"))]
         O_DIRECT;
         /// If the specified path isn't a directory, fail.
+        #[cfg(not(any(target_os = "illumos", target_os = "solaris")))]
         O_DIRECTORY;
         /// Implicitly follow each `write()` with an `fdatasync()`.
         #[cfg(any(target_os = "android",
@@ -78,7 +87,8 @@ libc_bitflags!(
                   target_os = "ios",
                   target_os = "macos",
                   target_os = "netbsd",
-                  target_os = "openbsd"))]
+                  target_os = "openbsd",
+                  target_os = "redox"))]
         O_EXLOCK;
         /// Same as `O_SYNC`.
         #[cfg(any(target_os = "dragonfly",
@@ -87,7 +97,8 @@ libc_bitflags!(
                   all(target_os = "linux", not(target_env = "musl")),
                   target_os = "macos",
                   target_os = "netbsd",
-                  target_os = "openbsd"))]
+                  target_os = "openbsd",
+                  target_os = "redox"))]
         O_FSYNC;
         /// Allow files whose sizes can't be represented in an `off_t` to be opened.
         #[cfg(any(target_os = "android", target_os = "linux"))]
@@ -96,8 +107,10 @@ libc_bitflags!(
         #[cfg(any(target_os = "android", target_os = "linux"))]
         O_NOATIME;
         /// Don't attach the device as the process' controlling terminal.
+        #[cfg(not(target_os = "redox"))]
         O_NOCTTY;
         /// Same as `O_NONBLOCK`.
+        #[cfg(not(target_os = "redox"))]
         O_NDELAY;
         /// `open()` will fail if the given path is a symbolic link.
         O_NOFOLLOW;
@@ -109,7 +122,7 @@ libc_bitflags!(
         /// Obtain a file descriptor for low-level access.
         ///
         /// The file itself is not opened and other file operations will fail.
-        #[cfg(any(target_os = "android", target_os = "linux"))]
+        #[cfg(any(target_os = "android", target_os = "linux", target_os = "redox"))]
         O_PATH;
         /// Only allow reading.
         ///
@@ -131,9 +144,11 @@ libc_bitflags!(
                   target_os = "ios",
                   target_os = "macos",
                   target_os = "netbsd",
-                  target_os = "openbsd"))]
+                  target_os = "openbsd",
+                  target_os = "redox"))]
         O_SHLOCK;
         /// Implicitly follow each `write()` with an `fsync()`.
+        #[cfg(not(target_os = "redox"))]
         O_SYNC;
         /// Create an unnamed temporary file.
         #[cfg(any(target_os = "android", target_os = "linux"))]
@@ -150,6 +165,8 @@ libc_bitflags!(
     }
 );
 
+// The conversion is not identical on all operating systems.
+#[allow(clippy::useless_conversion)]
 pub fn open<P: ?Sized + NixPath>(path: &P, oflag: OFlag, mode: Mode) -> Result<RawFd> {
     let fd = path.with_nix_path(|cstr| {
         unsafe { libc::open(cstr.as_ptr(), oflag.bits(), mode.bits() as c_uint) }
@@ -158,56 +175,173 @@ pub fn open<P: ?Sized + NixPath>(path: &P, oflag: OFlag, mode: Mode) -> Result<R
     Errno::result(fd)
 }
 
-pub fn openat<P: ?Sized + NixPath>(dirfd: RawFd, path: &P, oflag: OFlag, mode: Mode) -> Result<RawFd> {
+// The conversion is not identical on all operating systems.
+#[allow(clippy::useless_conversion)]
+#[cfg(not(target_os = "redox"))]
+pub fn openat<P: ?Sized + NixPath>(
+    dirfd: RawFd,
+    path: &P,
+    oflag: OFlag,
+    mode: Mode,
+) -> Result<RawFd> {
     let fd = path.with_nix_path(|cstr| {
         unsafe { libc::openat(dirfd, cstr.as_ptr(), oflag.bits(), mode.bits() as c_uint) }
     })?;
     Errno::result(fd)
 }
 
-pub fn renameat<P1: ?Sized + NixPath, P2: ?Sized + NixPath>(old_dirfd: Option<RawFd>, old_path: &P1,
-                                                            new_dirfd: Option<RawFd>, new_path: &P2)
-                                                            -> Result<()> {
+#[cfg(not(target_os = "redox"))]
+pub fn renameat<P1: ?Sized + NixPath, P2: ?Sized + NixPath>(
+    old_dirfd: Option<RawFd>,
+    old_path: &P1,
+    new_dirfd: Option<RawFd>,
+    new_path: &P2,
+) -> Result<()> {
     let res = old_path.with_nix_path(|old_cstr| {
         new_path.with_nix_path(|new_cstr| unsafe {
-            libc::renameat(at_rawfd(old_dirfd), old_cstr.as_ptr(),
-                           at_rawfd(new_dirfd), new_cstr.as_ptr())
+            libc::renameat(
+                at_rawfd(old_dirfd),
+                old_cstr.as_ptr(),
+                at_rawfd(new_dirfd),
+                new_cstr.as_ptr(),
+            )
         })
     })??;
     Errno::result(res).map(drop)
 }
 
-fn wrap_readlink_result(buffer: &mut[u8], res: ssize_t) -> Result<&OsStr> {
-    match Errno::result(res) {
-        Err(err) => Err(err),
-        Ok(len) => {
-            if (len as usize) >= buffer.len() {
-                Err(Error::Sys(Errno::ENAMETOOLONG))
-            } else {
-                Ok(OsStr::from_bytes(&buffer[..(len as usize)]))
-            }
-        }
+#[cfg(all(
+    target_os = "linux",
+    target_env = "gnu",
+))]
+libc_bitflags! {
+    pub struct RenameFlags: u32 {
+        RENAME_EXCHANGE;
+        RENAME_NOREPLACE;
+        RENAME_WHITEOUT;
     }
 }
 
-pub fn readlink<'a, P: ?Sized + NixPath>(path: &P, buffer: &'a mut [u8]) -> Result<&'a OsStr> {
-    let res = path.with_nix_path(|cstr| {
-        unsafe { libc::readlink(cstr.as_ptr(), buffer.as_mut_ptr() as *mut c_char, buffer.len() as size_t) }
-    })?;
+#[cfg(all(
+    target_os = "linux",
+    target_env = "gnu",
+))]
+pub fn renameat2<P1: ?Sized + NixPath, P2: ?Sized + NixPath>(
+    old_dirfd: Option<RawFd>,
+    old_path: &P1,
+    new_dirfd: Option<RawFd>,
+    new_path: &P2,
+    flags: RenameFlags,
+) -> Result<()> {
+    let res = old_path.with_nix_path(|old_cstr| {
+        new_path.with_nix_path(|new_cstr| unsafe {
+            libc::renameat2(
+                at_rawfd(old_dirfd),
+                old_cstr.as_ptr(),
+                at_rawfd(new_dirfd),
+                new_cstr.as_ptr(),
+                flags.bits(),
+            )
+        })
+    })??;
+    Errno::result(res).map(drop)
+}
 
-    wrap_readlink_result(buffer, res)
+fn wrap_readlink_result(mut v: Vec<u8>, len: ssize_t) -> Result<OsString> {
+    unsafe { v.set_len(len as usize) }
+    v.shrink_to_fit();
+    Ok(OsString::from_vec(v.to_vec()))
 }
 
+fn readlink_maybe_at<P: ?Sized + NixPath>(
+    dirfd: Option<RawFd>,
+    path: &P,
+    v: &mut Vec<u8>,
+) -> Result<libc::ssize_t> {
+    path.with_nix_path(|cstr| unsafe {
+        match dirfd {
+            #[cfg(target_os = "redox")]
+            Some(_) => unreachable!(),
+            #[cfg(not(target_os = "redox"))]
+            Some(dirfd) => libc::readlinkat(
+                dirfd,
+                cstr.as_ptr(),
+                v.as_mut_ptr() as *mut c_char,
+                v.capacity() as size_t,
+            ),
+            None => libc::readlink(
+                cstr.as_ptr(),
+                v.as_mut_ptr() as *mut c_char,
+                v.capacity() as size_t,
+            ),
+        }
+    })
+}
 
-pub fn readlinkat<'a, P: ?Sized + NixPath>(dirfd: RawFd, path: &P, buffer: &'a mut [u8]) -> Result<&'a OsStr> {
-    let res = path.with_nix_path(|cstr| {
-        unsafe { libc::readlinkat(dirfd, cstr.as_ptr(), buffer.as_mut_ptr() as *mut c_char, buffer.len() as size_t) }
-    })?;
+fn inner_readlink<P: ?Sized + NixPath>(dirfd: Option<RawFd>, path: &P) -> Result<OsString> {
+    let mut v = Vec::with_capacity(libc::PATH_MAX as usize);
+    // simple case: result is strictly less than `PATH_MAX`
+    let res = readlink_maybe_at(dirfd, path, &mut v)?;
+    let len = Errno::result(res)?;
+    debug_assert!(len >= 0);
+    if (len as usize) < v.capacity() {
+        return wrap_readlink_result(v, res);
+    }
+    // Uh oh, the result is too long...
+    // Let's try to ask lstat how many bytes to allocate.
+    let reported_size = match dirfd {
+        #[cfg(target_os = "redox")]
+        Some(_) => unreachable!(),
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        Some(dirfd) => {
+            let flags = if path.is_empty() { AtFlags::AT_EMPTY_PATH } else { AtFlags::empty() };
+            super::sys::stat::fstatat(dirfd, path, flags | AtFlags::AT_SYMLINK_NOFOLLOW)
+        },
+        #[cfg(not(any(target_os = "android", target_os = "linux", target_os = "redox")))]
+        Some(dirfd) => super::sys::stat::fstatat(dirfd, path, AtFlags::AT_SYMLINK_NOFOLLOW),
+        None => super::sys::stat::lstat(path)
+    }
+        .map(|x| x.st_size)
+        .unwrap_or(0);
+    let mut try_size = if reported_size > 0 {
+        // Note: even if `lstat`'s apparently valid answer turns out to be
+        // wrong, we will still read the full symlink no matter what.
+        reported_size as usize + 1
+    } else {
+        // If lstat doesn't cooperate, or reports an error, be a little less
+        // precise.
+        (libc::PATH_MAX as usize).max(128) << 1
+    };
+    loop {
+        v.reserve_exact(try_size);
+        let res = readlink_maybe_at(dirfd, path, &mut v)?;
+        let len = Errno::result(res)?;
+        debug_assert!(len >= 0);
+        if (len as usize) < v.capacity() {
+            break wrap_readlink_result(v, res);
+        } else {
+            // Ugh! Still not big enough!
+            match try_size.checked_shl(1) {
+                Some(next_size) => try_size = next_size,
+                // It's absurd that this would happen, but handle it sanely
+                // anyway.
+                None => break Err(Errno::ENAMETOOLONG),
+            }
+        }
+    }
+}
 
-    wrap_readlink_result(buffer, res)
+pub fn readlink<P: ?Sized + NixPath>(path: &P) -> Result<OsString> {
+    inner_readlink(None, path)
+}
+
+#[cfg(not(target_os = "redox"))]
+pub fn readlinkat<P: ?Sized + NixPath>(dirfd: RawFd, path: &P) -> Result<OsString> {
+    inner_readlink(Some(dirfd), path)
 }
 
 /// Computes the raw fd consumed by a function of the form `*at`.
+#[cfg(not(target_os = "redox"))]
 pub(crate) fn at_rawfd(fd: Option<RawFd>) -> raw::c_int {
     match fd {
         None => libc::AT_FDCWD,
@@ -238,7 +372,9 @@ libc_bitflags!(
     }
 );
 
+#[cfg(not(target_os = "redox"))]
 #[derive(Debug, Eq, Hash, PartialEq)]
+#[non_exhaustive]
 pub enum FcntlArg<'a> {
     F_DUPFD(RawFd),
     F_DUPFD_CLOEXEC(RawFd),
@@ -265,9 +401,20 @@ pub enum FcntlArg<'a> {
     F_GETPIPE_SZ,
     #[cfg(any(target_os = "linux", target_os = "android"))]
     F_SETPIPE_SZ(c_int),
-
     // TODO: Rest of flags
 }
+
+#[cfg(target_os = "redox")]
+#[derive(Debug, Clone, Copy, Eq, Hash, PartialEq)]
+#[non_exhaustive]
+pub enum FcntlArg {
+    F_DUPFD(RawFd),
+    F_DUPFD_CLOEXEC(RawFd),
+    F_GETFD,
+    F_SETFD(FdFlag), // FD_FLAGS
+    F_GETFL,
+    F_SETFL(OFlag), // O_NONBLOCK
+}
 pub use self::FcntlArg::*;
 
 // TODO: Figure out how to handle value fcntl returns
@@ -280,10 +427,19 @@ pub fn fcntl(fd: RawFd, arg: FcntlArg) -> Result<c_int> {
             F_SETFD(flag) => libc::fcntl(fd, libc::F_SETFD, flag.bits()),
             F_GETFL => libc::fcntl(fd, libc::F_GETFL),
             F_SETFL(flag) => libc::fcntl(fd, libc::F_SETFL, flag.bits()),
+            #[cfg(not(target_os = "redox"))]
             F_SETLK(flock) => libc::fcntl(fd, libc::F_SETLK, flock),
+            #[cfg(not(target_os = "redox"))]
             F_SETLKW(flock) => libc::fcntl(fd, libc::F_SETLKW, flock),
+            #[cfg(not(target_os = "redox"))]
             F_GETLK(flock) => libc::fcntl(fd, libc::F_GETLK, flock),
             #[cfg(any(target_os = "android", target_os = "linux"))]
+            F_OFD_SETLK(flock) => libc::fcntl(fd, libc::F_OFD_SETLK, flock),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            F_OFD_SETLKW(flock) => libc::fcntl(fd, libc::F_OFD_SETLKW, flock),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            F_OFD_GETLK(flock) => libc::fcntl(fd, libc::F_OFD_GETLK, flock),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
             F_ADD_SEALS(flag) => libc::fcntl(fd, libc::F_ADD_SEALS, flag.bits()),
             #[cfg(any(target_os = "android", target_os = "linux"))]
             F_GET_SEALS => libc::fcntl(fd, libc::F_GET_SEALS),
@@ -293,8 +449,6 @@ pub fn fcntl(fd: RawFd, arg: FcntlArg) -> Result<c_int> {
             F_GETPIPE_SZ => libc::fcntl(fd, libc::F_GETPIPE_SZ),
             #[cfg(any(target_os = "linux", target_os = "android"))]
             F_SETPIPE_SZ(size) => libc::fcntl(fd, libc::F_SETPIPE_SZ, size),
-            #[cfg(any(target_os = "linux", target_os = "android"))]
-            _ => unimplemented!()
         }
     };
 
@@ -302,6 +456,7 @@ pub fn fcntl(fd: RawFd, arg: FcntlArg) -> Result<c_int> {
 }
 
 #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+#[non_exhaustive]
 pub enum FlockArg {
     LockShared,
     LockExclusive,
@@ -311,6 +466,7 @@ pub enum FlockArg {
     UnlockNonblock,
 }
 
+#[cfg(not(target_os = "redox"))]
 pub fn flock(fd: RawFd, arg: FlockArg) -> Result<()> {
     use self::FlockArg::*;
 
@@ -410,9 +566,7 @@ pub fn splice(
         .map(|offset| offset as *mut libc::loff_t)
         .unwrap_or(ptr::null_mut());
 
-    let ret = unsafe {
-        libc::splice(fd_in, off_in, fd_out, off_out, len, flags.bits())
-    };
+    let ret = unsafe { libc::splice(fd_in, off_in, fd_out, off_out, len, flags.bits()) };
     Errno::result(ret).map(|r| r as usize)
 }
 
@@ -425,7 +579,12 @@ pub fn tee(fd_in: RawFd, fd_out: RawFd, len: usize, flags: SpliceFFlags) -> Resu
 #[cfg(any(target_os = "linux", target_os = "android"))]
 pub fn vmsplice(fd: RawFd, iov: &[IoVec<&[u8]>], flags: SpliceFFlags) -> Result<usize> {
     let ret = unsafe {
-        libc::vmsplice(fd, iov.as_ptr() as *const libc::iovec, iov.len(), flags.bits())
+        libc::vmsplice(
+            fd,
+            iov.as_ptr() as *const libc::iovec,
+            iov.len(),
+            flags.bits(),
+        )
     };
     Errno::result(ret).map(|r| r as usize)
 }
@@ -466,26 +625,33 @@ libc_bitflags!(
 /// Allows the caller to directly manipulate the allocated disk space for the
 /// file referred to by fd.
 #[cfg(any(target_os = "linux"))]
-pub fn fallocate(fd: RawFd, mode: FallocateFlags, offset: libc::off_t, len: libc::off_t) -> Result<c_int> {
+pub fn fallocate(
+    fd: RawFd,
+    mode: FallocateFlags,
+    offset: libc::off_t,
+    len: libc::off_t,
+) -> Result<()> {
     let res = unsafe { libc::fallocate(fd, mode.bits(), offset, len) };
-    Errno::result(res)
+    Errno::result(res).map(drop)
 }
 
-#[cfg(any(target_os = "linux",
-          target_os = "android",
-          target_os = "emscripten",
-          target_os = "fuchsia",
-          any(target_os = "wasi", target_env = "wasi"),
-          target_env = "uclibc",
-          target_env = "freebsd"))]
+#[cfg(any(
+    target_os = "linux",
+    target_os = "android",
+    target_os = "emscripten",
+    target_os = "fuchsia",
+    any(target_os = "wasi", target_env = "wasi"),
+    target_env = "uclibc",
+    target_os = "freebsd"
+))]
 mod posix_fadvise {
-    use Result;
-    use libc;
-    use errno::Errno;
+    use crate::errno::Errno;
     use std::os::unix::io::RawFd;
+    use crate::Result;
 
     libc_enum! {
         #[repr(i32)]
+        #[non_exhaustive]
         pub enum PosixFadviseAdvice {
             POSIX_FADV_NORMAL,
             POSIX_FADV_SEQUENTIAL,
@@ -496,11 +662,35 @@ mod posix_fadvise {
         }
     }
 
-    pub fn posix_fadvise(fd: RawFd,
-                         offset: libc::off_t,
-                         len: libc::off_t,
-                         advice: PosixFadviseAdvice) -> Result<libc::c_int> {
+    pub fn posix_fadvise(
+        fd: RawFd,
+        offset: libc::off_t,
+        len: libc::off_t,
+        advice: PosixFadviseAdvice,
+    ) -> Result<()> {
         let res = unsafe { libc::posix_fadvise(fd, offset, len, advice as libc::c_int) };
-        Errno::result(res)
+
+        if res == 0 {
+            Ok(())
+        } else {
+            Err(Errno::from_i32(res))
+        }
+    }
+}
+
+#[cfg(any(
+    target_os = "linux",
+    target_os = "android",
+    target_os = "emscripten",
+    target_os = "fuchsia",
+    any(target_os = "wasi", target_env = "wasi"),
+    target_os = "freebsd"
+))]
+pub fn posix_fallocate(fd: RawFd, offset: libc::off_t, len: libc::off_t) -> Result<()> {
+    let res = unsafe { libc::posix_fallocate(fd, offset, len) };
+    match Errno::result(res) {
+        Err(err) => Err(err),
+        Ok(0) => Ok(()),
+        Ok(errno) => Err(Errno::from_i32(errno)),
     }
 }
diff --git a/third_party/rust/nix/src/features.rs b/third_party/rust/nix/src/features.rs
index 76cdfd3a1a6f1..ed80fd714b3bf 100644
--- a/third_party/rust/nix/src/features.rs
+++ b/third_party/rust/nix/src/features.rs
@@ -3,7 +3,7 @@ pub use self::os::*;
 
 #[cfg(any(target_os = "linux", target_os = "android"))]
 mod os {
-    use sys::utsname::uname;
+    use crate::sys::utsname::uname;
 
     // Features:
     // * atomic cloexec on socket: 2.6.27
@@ -94,10 +94,28 @@ mod os {
     }
 }
 
-#[cfg(any(target_os = "macos", target_os = "freebsd", target_os = "dragonfly", target_os = "ios", target_os = "openbsd", target_os = "netbsd"))]
+#[cfg(any(
+        target_os = "dragonfly",    // Since ???
+        target_os = "freebsd",      // Since 10.0
+        target_os = "illumos",      // Since ???
+        target_os = "netbsd",       // Since 6.0
+        target_os = "openbsd",      // Since 5.7
+        target_os = "redox",        // Since 1-july-2020
+))]
 mod os {
     /// Check if the OS supports atomic close-on-exec for sockets
-    pub fn socket_atomic_cloexec() -> bool {
+    pub const fn socket_atomic_cloexec() -> bool {
+        true
+    }
+}
+
+#[cfg(any(target_os = "macos",
+          target_os = "ios",
+          target_os = "fuchsia",
+          target_os = "solaris"))]
+mod os {
+    /// Check if the OS supports atomic close-on-exec for sockets
+    pub const fn socket_atomic_cloexec() -> bool {
         false
     }
 }
diff --git a/third_party/rust/nix/src/ifaddrs.rs b/third_party/rust/nix/src/ifaddrs.rs
index 12b59bcc92bef..ed6328f3efab2 100644
--- a/third_party/rust/nix/src/ifaddrs.rs
+++ b/third_party/rust/nix/src/ifaddrs.rs
@@ -3,16 +3,15 @@
 //! Uses the Linux and/or BSD specific function `getifaddrs` to query the list
 //! of interfaces and their associated addresses.
 
+use cfg_if::cfg_if;
 use std::ffi;
 use std::iter::Iterator;
 use std::mem;
 use std::option::Option;
 
-use libc;
-
-use {Result, Errno};
-use sys::socket::SockAddr;
-use net::if_::*;
+use crate::{Result, Errno};
+use crate::sys::socket::SockAddr;
+use crate::net::if_::*;
 
 /// Describes a single address for an interface as returned by `getifaddrs`.
 #[derive(Clone, Debug, Eq, Hash, PartialEq)]
@@ -52,8 +51,8 @@ impl InterfaceAddress {
         let mut addr = InterfaceAddress {
             interface_name: ifname.to_string_lossy().to_string(),
             flags: InterfaceFlags::from_bits_truncate(info.ifa_flags as i32),
-            address: address,
-            netmask: netmask,
+            address,
+            netmask,
             broadcast: None,
             destination: None,
         };
@@ -125,13 +124,15 @@ impl Iterator for InterfaceAddressIterator {
 /// }
 /// ```
 pub fn getifaddrs() -> Result<InterfaceAddressIterator> {
-    let mut addrs: *mut libc::ifaddrs = unsafe { mem::uninitialized() };
-    Errno::result(unsafe { libc::getifaddrs(&mut addrs) }).map(|_| {
-        InterfaceAddressIterator {
-            base: addrs,
-            next: addrs,
-        }
-    })
+    let mut addrs = mem::MaybeUninit::<*mut libc::ifaddrs>::uninit();
+    unsafe {
+        Errno::result(libc::getifaddrs(addrs.as_mut_ptr())).map(|_| {
+            InterfaceAddressIterator {
+                base: addrs.assume_init(),
+                next: addrs.assume_init(),
+            }
+        })
+    }
 }
 
 #[cfg(test)]
diff --git a/third_party/rust/nix/src/kmod.rs b/third_party/rust/nix/src/kmod.rs
index e853261b14f9d..c42068c70a619 100644
--- a/third_party/rust/nix/src/kmod.rs
+++ b/third_party/rust/nix/src/kmod.rs
@@ -2,12 +2,11 @@
 //!
 //! For more details see
 
-use libc;
 use std::ffi::CStr;
 use std::os::unix::io::AsRawFd;
 
-use errno::Errno;
-use Result;
+use crate::errno::Errno;
+use crate::Result;
 
 /// Loads a kernel module from a buffer.
 ///
@@ -42,7 +41,7 @@ use Result;
 /// init_module(&mut contents, &CString::new("who=Rust when=Now,12").unwrap()).unwrap();
 /// ```
 ///
-/// See [`man init_module(2)`](http://man7.org/linux/man-pages/man2/init_module.2.html) for more information.
+/// See [`man init_module(2)`](https://man7.org/linux/man-pages/man2/init_module.2.html) for more information.
 pub fn init_module(module_image: &[u8], param_values: &CStr) -> Result<()> {
     let res = unsafe {
         libc::syscall(
@@ -79,7 +78,7 @@ libc_bitflags!(
 /// finit_module(&f, &CString::new("").unwrap(), ModuleInitFlags::empty()).unwrap();
 /// ```
 ///
-/// See [`man init_module(2)`](http://man7.org/linux/man-pages/man2/init_module.2.html) for more information.
+/// See [`man init_module(2)`](https://man7.org/linux/man-pages/man2/init_module.2.html) for more information.
 pub fn finit_module<T: AsRawFd>(fd: &T, param_values: &CStr, flags: ModuleInitFlags) -> Result<()> {
     let res = unsafe {
         libc::syscall(
@@ -96,7 +95,7 @@ pub fn finit_module<T: AsRawFd>(fd: &T, param_values: &CStr, flags: ModuleInitFl
 libc_bitflags!(
     /// Flags used by `delete_module`.
     ///
-    /// See [`man delete_module(2)`](http://man7.org/linux/man-pages/man2/delete_module.2.html)
+    /// See [`man delete_module(2)`](https://man7.org/linux/man-pages/man2/delete_module.2.html)
     /// for a detailed description how these flags work.
     pub struct DeleteModuleFlags: libc::c_int {
         O_NONBLOCK;
@@ -115,7 +114,7 @@ libc_bitflags!(
 /// delete_module(&CString::new("mymod").unwrap(), DeleteModuleFlags::O_NONBLOCK).unwrap();
 /// ```
 ///
-/// See [`man delete_module(2)`](http://man7.org/linux/man-pages/man2/delete_module.2.html) for more information.
+/// See [`man delete_module(2)`](https://man7.org/linux/man-pages/man2/delete_module.2.html) for more information.
 pub fn delete_module(name: &CStr, flags: DeleteModuleFlags) -> Result<()> {
     let res = unsafe { libc::syscall(libc::SYS_delete_module, name.as_ptr(), flags.bits()) };
 
diff --git a/third_party/rust/nix/src/lib.rs b/third_party/rust/nix/src/lib.rs
index 71485d2af1824..3a2b63ab0b759 100644
--- a/third_party/rust/nix/src/lib.rs
+++ b/third_party/rust/nix/src/lib.rs
@@ -5,38 +5,30 @@
 #![crate_name = "nix"]
 #![cfg(unix)]
 #![allow(non_camel_case_types)]
-// latest bitflags triggers a rustc bug with cross-crate macro expansions causing dead_code
-// warnings even though the macro expands into something with allow(dead_code)
-#![allow(dead_code)]
 #![cfg_attr(test, deny(warnings))]
 #![recursion_limit = "500"]
 #![deny(unused)]
 #![deny(unstable_features)]
 #![deny(missing_copy_implementations)]
 #![deny(missing_debug_implementations)]
-// XXX Allow deprecated items until release 0.16.0.  See issue #1096.
-#![allow(deprecated)]
-
-// External crates
-#[macro_use]
-extern crate bitflags;
-#[macro_use]
-extern crate cfg_if;
-extern crate void;
+#![warn(missing_docs)]
 
 // Re-exported external crates
-pub extern crate libc;
+pub use libc;
 
 // Private internal modules
 #[macro_use] mod macros;
 
 // Public crates
+#[cfg(not(target_os = "redox"))]
+#[allow(missing_docs)]
 pub mod dir;
+pub mod env;
+#[allow(missing_docs)]
 pub mod errno;
-#[deny(missing_docs)]
 pub mod features;
+#[allow(missing_docs)]
 pub mod fcntl;
-#[deny(missing_docs)]
 #[cfg(any(target_os = "android",
           target_os = "dragonfly",
           target_os = "freebsd",
@@ -44,12 +36,15 @@ pub mod fcntl;
           target_os = "linux",
           target_os = "macos",
           target_os = "netbsd",
+          target_os = "illumos",
           target_os = "openbsd"))]
 pub mod ifaddrs;
 #[cfg(any(target_os = "android",
           target_os = "linux"))]
+#[allow(missing_docs)]
 pub mod kmod;
 #[cfg(any(target_os = "android",
+          target_os = "freebsd",
           target_os = "linux"))]
 pub mod mount;
 #[cfg(any(target_os = "dragonfly",
@@ -57,20 +52,24 @@ pub mod mount;
           target_os = "fushsia",
           target_os = "linux",
           target_os = "netbsd"))]
+#[allow(missing_docs)]
 pub mod mqueue;
-#[deny(missing_docs)]
+#[cfg(not(target_os = "redox"))]
 pub mod net;
-#[deny(missing_docs)]
 pub mod poll;
-#[deny(missing_docs)]
+#[cfg(not(any(target_os = "redox", target_os = "fuchsia")))]
 pub mod pty;
 pub mod sched;
 pub mod sys;
+#[allow(missing_docs)]
+pub mod time;
 // This can be implemented for other platforms as soon as libc
 // provides bindings for them.
 #[cfg(all(target_os = "linux",
           any(target_arch = "x86", target_arch = "x86_64")))]
+#[allow(missing_docs)]
 pub mod ucontext;
+#[allow(missing_docs)]
 pub mod unistd;
 
 /*
@@ -81,7 +80,7 @@ pub mod unistd;
 
 use libc::{c_char, PATH_MAX};
 
-use std::{error, fmt, ptr, result};
+use std::{ptr, result};
 use std::ffi::{CStr, OsStr};
 use std::os::unix::ffi::OsStrExt;
 use std::path::{Path, PathBuf};
@@ -89,101 +88,40 @@ use std::path::{Path, PathBuf};
 use errno::Errno;
 
 /// Nix Result Type
-pub type Result<T> = result::Result<T, Error>;
+pub type Result<T> = result::Result<T, Errno>;
 
-/// Nix Error Type
+/// Nix's main error type.
 ///
-/// The nix error type provides a common way of dealing with
-/// various system system/libc calls that might fail.  Each
-/// error has a corresponding errno (usually the one from the
-/// underlying OS) to which it can be mapped in addition to
-/// implementing other common traits.
-#[derive(Clone, Copy, Debug, Eq, PartialEq)]
-pub enum Error {
-    Sys(Errno),
-    InvalidPath,
-    /// The operation involved a conversion to Rust's native String type, which failed because the
-    /// string did not contain all valid UTF-8.
-    InvalidUtf8,
-    /// The operation is not supported by Nix, in this instance either use the libc bindings or
-    /// consult the module documentation to see if there is a more appropriate interface available.
-    UnsupportedOperation,
-}
-
-impl Error {
-    /// Convert this `Error` to an [`Errno`](enum.Errno.html).
-    ///
-    /// # Example
-    ///
-    /// ```
-    /// # use nix::Error;
-    /// # use nix::errno::Errno;
-    /// let e = Error::from(Errno::EPERM);
-    /// assert_eq!(Some(Errno::EPERM), e.as_errno());
-    /// ```
-    pub fn as_errno(&self) -> Option<Errno> {
-        if let &Error::Sys(ref e) = self {
-            Some(*e)
-        } else {
-            None
-        }
-    }
-
-    /// Create a nix Error from a given errno
-    pub fn from_errno(errno: Errno) -> Error {
-        Error::Sys(errno)
-    }
-
-    /// Get the current errno and convert it to a nix Error
-    pub fn last() -> Error {
-        Error::Sys(Errno::last())
-    }
-
-    /// Create a new invalid argument error (`EINVAL`)
-    pub fn invalid_argument() -> Error {
-        Error::Sys(Errno::EINVAL)
-    }
-
-}
-
-impl From<Errno> for Error {
-    fn from(errno: Errno) -> Error { Error::from_errno(errno) }
-}
-
-impl From<std::string::FromUtf8Error> for Error {
-    fn from(_: std::string::FromUtf8Error) -> Error { Error::InvalidUtf8 }
-}
-
-impl error::Error for Error {
-    fn description(&self) -> &str {
-        match *self {
-            Error::InvalidPath => "Invalid path",
-            Error::InvalidUtf8 => "Invalid UTF-8 string",
-            Error::UnsupportedOperation => "Unsupported Operation",
-            Error::Sys(ref errno) => errno.desc(),
-        }
-    }
-}
-
-impl fmt::Display for Error {
-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-        match *self {
-            Error::InvalidPath => write!(f, "Invalid path"),
-            Error::InvalidUtf8 => write!(f, "Invalid UTF-8 string"),
-            Error::UnsupportedOperation => write!(f, "Unsupported Operation"),
-            Error::Sys(errno) => write!(f, "{:?}: {}", errno, errno.desc()),
-        }
-    }
-}
-
+/// It's a wrapper around Errno.  As such, it's very interoperable with
+/// [`std::io::Error`], but it has the advantages of:
+/// * `Clone`
+/// * `Copy`
+/// * `Eq`
+/// * Small size
+/// * Represents all of the system's errnos, instead of just the most common
+/// ones.
+pub type Error = Errno;
+
+/// Common trait used to represent file system paths by many Nix functions.
 pub trait NixPath {
+    /// Is the path empty?
+    fn is_empty(&self) -> bool;
+
+    /// Length of the path in bytes
     fn len(&self) -> usize;
 
+    /// Execute a function with this path as a `CStr`.
+    ///
+    /// Mostly used internally by Nix.
     fn with_nix_path<T, F>(&self, f: F) -> Result<T>
         where F: FnOnce(&CStr) -> T;
 }
 
 impl NixPath for str {
+    fn is_empty(&self) -> bool {
+        NixPath::is_empty(OsStr::new(self))
+    }
+
     fn len(&self) -> usize {
         NixPath::len(OsStr::new(self))
     }
@@ -195,6 +133,10 @@ impl NixPath for str {
 }
 
 impl NixPath for OsStr {
+    fn is_empty(&self) -> bool {
+        self.as_bytes().is_empty()
+    }
+
     fn len(&self) -> usize {
         self.as_bytes().len()
     }
@@ -206,6 +148,10 @@ impl NixPath for OsStr {
 }
 
 impl NixPath for CStr {
+    fn is_empty(&self) -> bool {
+        self.to_bytes().is_empty()
+    }
+
     fn len(&self) -> usize {
         self.to_bytes().len()
     }
@@ -214,7 +160,7 @@ impl NixPath for CStr {
             where F: FnOnce(&CStr) -> T {
         // Equivalence with the [u8] impl.
         if self.len() >= PATH_MAX as usize {
-            return Err(Error::InvalidPath);
+            return Err(Errno::ENAMETOOLONG)
         }
 
         Ok(f(self))
@@ -222,6 +168,10 @@ impl NixPath for CStr {
 }
 
 impl NixPath for [u8] {
+    fn is_empty(&self) -> bool {
+        self.is_empty()
+    }
+
     fn len(&self) -> usize {
         self.len()
     }
@@ -231,11 +181,11 @@ impl NixPath for [u8] {
         let mut buf = [0u8; PATH_MAX as usize];
 
         if self.len() >= PATH_MAX as usize {
-            return Err(Error::InvalidPath);
+            return Err(Errno::ENAMETOOLONG)
         }
 
         match self.iter().position(|b| *b == 0) {
-            Some(_) => Err(Error::InvalidPath),
+            Some(_) => Err(Errno::EINVAL),
             None => {
                 unsafe {
                     // TODO: Replace with bytes::copy_memory. rust-lang/rust#24028
@@ -249,6 +199,10 @@ impl NixPath for [u8] {
 }
 
 impl NixPath for Path {
+    fn is_empty(&self) -> bool {
+        NixPath::is_empty(self.as_os_str())
+    }
+
     fn len(&self) -> usize {
         NixPath::len(self.as_os_str())
     }
@@ -259,26 +213,15 @@ impl NixPath for Path {
 }
 
 impl NixPath for PathBuf {
-    fn len(&self) -> usize {
-        NixPath::len(self.as_os_str())
-    }
-
-    fn with_nix_path<T, F>(&self, f: F) -> Result<T> where F: FnOnce(&CStr) -> T {
-        self.as_os_str().with_nix_path(f)
+    fn is_empty(&self) -> bool {
+        NixPath::is_empty(self.as_os_str())
     }
-}
 
-/// Treats `None` as an empty string.
-impl<'a, NP: ?Sized + NixPath>  NixPath for Option<&'a NP> {
     fn len(&self) -> usize {
-        self.map_or(0, NixPath::len)
+        NixPath::len(self.as_os_str())
     }
 
     fn with_nix_path<T, F>(&self, f: F) -> Result<T> where F: FnOnce(&CStr) -> T {
-        if let Some(nix_path) = *self {
-            nix_path.with_nix_path(f)
-        } else {
-            unsafe { CStr::from_ptr("\0".as_ptr() as *const _).with_nix_path(f) }
-        }
+        self.as_os_str().with_nix_path(f)
     }
 }
diff --git a/third_party/rust/nix/src/macros.rs b/third_party/rust/nix/src/macros.rs
index 3d1b0e4b7699c..3ccbfdd43b048 100644
--- a/third_party/rust/nix/src/macros.rs
+++ b/third_party/rust/nix/src/macros.rs
@@ -48,7 +48,7 @@ macro_rules! libc_bitflags {
             )+
         }
     ) => {
-        bitflags! {
+        ::bitflags::bitflags! {
             $(#[$outer])*
             pub struct $BitFlags: $T {
                 $(
@@ -81,87 +81,114 @@ macro_rules! libc_bitflags {
 /// }
 /// ```
 macro_rules! libc_enum {
-    // (non-pub) Exit rule.
+    // Exit rule.
     (@make_enum
+        name: $BitFlags:ident,
         {
-            name: $BitFlags:ident,
+            $v:vis
             attrs: [$($attrs:tt)*],
             entries: [$($entries:tt)*],
         }
     ) => {
         $($attrs)*
         #[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
-        enum $BitFlags {
+        $v enum $BitFlags {
             $($entries)*
         }
     };
 
-    // (pub) Exit rule.
+    // Exit rule including TryFrom
     (@make_enum
+        name: $BitFlags:ident,
         {
-            pub,
-            name: $BitFlags:ident,
+            $v:vis
             attrs: [$($attrs:tt)*],
             entries: [$($entries:tt)*],
+            from_type: $repr:path,
+            try_froms: [$($try_froms:tt)*]
         }
     ) => {
         $($attrs)*
         #[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
-        pub enum $BitFlags {
+        $v enum $BitFlags {
             $($entries)*
         }
+        impl ::std::convert::TryFrom<$repr> for $BitFlags {
+            type Error = $crate::Error;
+            #[allow(unused_doc_comments)]
+            fn try_from(x: $repr) -> $crate::Result<Self> {
+                match x {
+                    $($try_froms)*
+                    _ => Err($crate::Error::EINVAL)
+                }
+            }
+        }
     };
 
-    // (non-pub) Done accumulating.
+    // Done accumulating.
     (@accumulate_entries
+        name: $BitFlags:ident,
         {
-            name: $BitFlags:ident,
+            $v:vis
             attrs: $attrs:tt,
         },
-        $entries:tt;
+        $entries:tt,
+        $try_froms:tt;
     ) => {
         libc_enum! {
             @make_enum
+            name: $BitFlags,
             {
-                name: $BitFlags,
+                $v
                 attrs: $attrs,
                 entries: $entries,
             }
         }
     };
 
-    // (pub) Done accumulating.
+    // Done accumulating and want TryFrom
     (@accumulate_entries
+        name: $BitFlags:ident,
         {
-            pub,
-            name: $BitFlags:ident,
+            $v:vis
             attrs: $attrs:tt,
+            from_type: $repr:path,
         },
-        $entries:tt;
+        $entries:tt,
+        $try_froms:tt;
     ) => {
         libc_enum! {
             @make_enum
+            name: $BitFlags,
             {
-                pub,
-                name: $BitFlags,
+                $v
                 attrs: $attrs,
                 entries: $entries,
+                from_type: $repr,
+                try_froms: $try_froms
             }
         }
     };
 
     // Munch an attr.
     (@accumulate_entries
+        name: $BitFlags:ident,
         $prefix:tt,
-        [$($entries:tt)*];
+        [$($entries:tt)*],
+        [$($try_froms:tt)*];
         #[$attr:meta] $($tail:tt)*
     ) => {
         libc_enum! {
             @accumulate_entries
+            name: $BitFlags,
             $prefix,
             [
                 $($entries)*
                 #[$attr]
+            ],
+            [
+                $($try_froms)*
+                #[$attr]
             ];
             $($tail)*
         }
@@ -169,32 +196,47 @@ macro_rules! libc_enum {
 
     // Munch last ident if not followed by a comma.
     (@accumulate_entries
+        name: $BitFlags:ident,
         $prefix:tt,
-        [$($entries:tt)*];
+        [$($entries:tt)*],
+        [$($try_froms:tt)*];
         $entry:ident
     ) => {
         libc_enum! {
             @accumulate_entries
+            name: $BitFlags,
             $prefix,
             [
                 $($entries)*
                 $entry = libc::$entry,
+            ],
+            [
+                $($try_froms)*
+                libc::$entry => Ok($BitFlags::$entry),
             ];
         }
     };
 
     // Munch an ident; covers terminating comma case.
     (@accumulate_entries
+        name: $BitFlags:ident,
         $prefix:tt,
-        [$($entries:tt)*];
-        $entry:ident, $($tail:tt)*
+        [$($entries:tt)*],
+        [$($try_froms:tt)*];
+        $entry:ident,
+        $($tail:tt)*
     ) => {
         libc_enum! {
             @accumulate_entries
+            name: $BitFlags,
             $prefix,
             [
                 $($entries)*
                 $entry = libc::$entry,
+            ],
+            [
+                $($try_froms)*
+                libc::$entry => Ok($BitFlags::$entry),
             ];
             $($tail)*
         }
@@ -202,63 +244,68 @@ macro_rules! libc_enum {
 
     // Munch an ident and cast it to the given type; covers terminating comma.
     (@accumulate_entries
+        name: $BitFlags:ident,
         $prefix:tt,
-        [$($entries:tt)*];
-        $entry:ident as $ty:ty, $($tail:tt)*
+        [$($entries:tt)*],
+        [$($try_froms:tt)*];
+        $entry:ident as $ty:ty,
+        $($tail:tt)*
     ) => {
         libc_enum! {
             @accumulate_entries
+            name: $BitFlags,
             $prefix,
             [
                 $($entries)*
                 $entry = libc::$entry as $ty,
+            ],
+            [
+                $($try_froms)*
+                libc::$entry as $ty => Ok($BitFlags::$entry),
             ];
             $($tail)*
         }
     };
 
-    // (non-pub) Entry rule.
+    // Entry rule.
     (
         $(#[$attr:meta])*
-        enum $BitFlags:ident {
+        $v:vis enum $BitFlags:ident {
             $($vals:tt)*
         }
     ) => {
         libc_enum! {
             @accumulate_entries
+            name: $BitFlags,
             {
-                name: $BitFlags,
+                $v
                 attrs: [$(#[$attr])*],
             },
+            [],
             [];
             $($vals)*
         }
     };
 
-    // (pub) Entry rule.
+    // Entry rule including TryFrom
     (
         $(#[$attr:meta])*
-        pub enum $BitFlags:ident {
+        $v:vis enum $BitFlags:ident {
             $($vals:tt)*
         }
+        impl TryFrom<$repr:path>
     ) => {
         libc_enum! {
             @accumulate_entries
+            name: $BitFlags,
             {
-                pub,
-                name: $BitFlags,
+                $v
                 attrs: [$(#[$attr])*],
+                from_type: $repr,
             },
+            [],
             [];
             $($vals)*
         }
     };
 }
-
-/// A Rust version of the familiar C `offset_of` macro.  It returns the byte
-/// offset of `field` within struct `ty`
-macro_rules! offset_of {
-    ($ty:ty, $field:ident) => {
-        &(*(0 as *const $ty)).$field as *const _ as usize
-    }
-}
diff --git a/third_party/rust/nix/src/mount/bsd.rs b/third_party/rust/nix/src/mount/bsd.rs
new file mode 100644
index 0000000000000..627bfa5ec1092
--- /dev/null
+++ b/third_party/rust/nix/src/mount/bsd.rs
@@ -0,0 +1,426 @@
+use crate::{
+    Error,
+    Errno,
+    NixPath,
+    Result,
+    sys::uio::IoVec
+};
+use libc::{c_char, c_int, c_uint, c_void};
+use std::{
+    borrow::Cow,
+    ffi::{CString, CStr},
+    fmt,
+    io,
+    ptr
+};
+
+
+libc_bitflags!(
+    /// Used with [`Nmount::nmount`].
+    pub struct MntFlags: c_int {
+        /// ACL support enabled.
+        #[cfg(any(target_os = "netbsd", target_os = "freebsd"))]
+        MNT_ACLS;
+        /// All I/O to the file system should be done asynchronously.
+        MNT_ASYNC;
+        /// dir should instead be a file system ID encoded as “FSID:val0:val1”.
+        #[cfg(target_os = "freebsd")]
+        MNT_BYFSID;
+        /// Force a read-write mount even if the file system appears to be
+        /// unclean.
+        MNT_FORCE;
+        /// GEOM journal support enabled.
+        #[cfg(target_os = "freebsd")]
+        MNT_GJOURNAL;
+        /// MAC support for objects.
+        #[cfg(any(target_os = "macos", target_os = "freebsd"))]
+        MNT_MULTILABEL;
+        /// Disable read clustering.
+        #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+        MNT_NOCLUSTERR;
+        /// Disable write clustering.
+        #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+        MNT_NOCLUSTERW;
+        /// Enable NFS version 4 ACLs.
+        #[cfg(target_os = "freebsd")]
+        MNT_NFS4ACLS;
+        /// Do not update access times.
+        MNT_NOATIME;
+        /// Disallow program execution.
+        MNT_NOEXEC;
+        /// Do not honor setuid or setgid bits on files when executing them.
+        MNT_NOSUID;
+        /// Do not follow symlinks.
+        #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+        MNT_NOSYMFOLLOW;
+        /// Mount read-only.
+        MNT_RDONLY;
+        /// Causes the vfs subsystem to update its data structures pertaining to
+        /// the specified already mounted file system.
+        MNT_RELOAD;
+        /// Create a snapshot of the file system.
+        ///
+        /// See [mksnap_ffs(8)](https://www.freebsd.org/cgi/man.cgi?query=mksnap_ffs)
+        #[cfg(any(target_os = "macos", target_os = "freebsd"))]
+        MNT_SNAPSHOT;
+        /// Using soft updates.
+        #[cfg(any(
+                target_os = "dragonfly",
+                target_os = "freebsd",
+                target_os = "netbsd",
+                target_os = "openbsd"
+        ))]
+        MNT_SOFTDEP;
+        /// Directories with the SUID bit set chown new files to their own
+        /// owner.
+        #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+        MNT_SUIDDIR;
+        /// All I/O to the file system should be done synchronously.
+        MNT_SYNCHRONOUS;
+        /// Union with underlying fs.
+        #[cfg(any(
+                target_os = "macos",
+                target_os = "freebsd",
+                target_os = "netbsd"
+        ))]
+        MNT_UNION;
+        /// Indicates that the mount command is being applied to an already
+        /// mounted file system.
+        MNT_UPDATE;
+        /// Check vnode use counts.
+        #[cfg(target_os = "freebsd")]
+        MNT_NONBUSY;
+    }
+);
+
+
+/// The Error type of [`Nmount::nmount`].
+///
+/// It wraps an [`Errno`], but also may contain an additional message returned
+/// by `nmount(2)`.
+#[derive(Debug)]
+pub struct NmountError {
+    errno: Error,
+    errmsg: Option<String>
+}
+
+impl NmountError {
+    /// Returns the additional error string sometimes generated by `nmount(2)`.
+    pub fn errmsg(&self) -> Option<&str> {
+        self.errmsg.as_deref()
+    }
+
+    /// Returns the inner [`Error`]
+    pub const fn error(&self) -> Error {
+        self.errno
+    }
+
+    fn new(error: Error, errmsg: Option<&CStr>) -> Self {
+        Self {
+            errno: error,
+            errmsg: errmsg.map(CStr::to_string_lossy).map(Cow::into_owned)
+        }
+    }
+}
+
+impl std::error::Error for NmountError {}
+
+impl fmt::Display for NmountError {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        if let Some(errmsg) = &self.errmsg {
+            write!(f, "{:?}: {}: {}", self.errno, errmsg, self.errno.desc())
+        } else {
+            write!(f, "{:?}: {}", self.errno, self.errno.desc())
+        }
+    }
+}
+
+impl From<NmountError> for io::Error {
+    fn from(err: NmountError) -> Self {
+        err.errno.into()
+    }
+}
+
+/// Result type of [`Nmount::nmount`].
+pub type NmountResult = std::result::Result<(), NmountError>;
+
+/// Mount a FreeBSD file system.
+///
+/// The `nmount(2)` system call works similarly to the `mount(8)` program; it
+/// takes its options as a series of name-value pairs.  Most of the values are
+/// strings, as are all of the names.  The `Nmount` structure builds up an
+/// argument list and then executes the syscall.
+///
+/// # Examples
+///
+/// To mount `target` onto `mountpoint` with `nullfs`:
+/// ```
+/// # use nix::unistd::Uid;
+/// # use ::sysctl::CtlValue;
+/// # if !Uid::current().is_root() && CtlValue::Int(0) == ::sysctl::value("vfs.usermount").unwrap() {
+/// #     return;
+/// # };
+/// use nix::mount::{MntFlags, Nmount, unmount};
+/// use std::ffi::CString;
+/// use tempfile::tempdir;
+///
+/// let mountpoint = tempdir().unwrap();
+/// let target = tempdir().unwrap();
+///
+/// let fstype = CString::new("fstype").unwrap();
+/// let nullfs = CString::new("nullfs").unwrap();
+/// Nmount::new()
+///     .str_opt(&fstype, &nullfs)
+///     .str_opt_owned("fspath", mountpoint.path().to_str().unwrap())
+///     .str_opt_owned("target", target.path().to_str().unwrap())
+///     .nmount(MntFlags::empty()).unwrap();
+/// 
+/// unmount(mountpoint.path(), MntFlags::empty()).unwrap();
+/// ```
+///
+/// # See Also
+/// * [`nmount(2)`](https://www.freebsd.org/cgi/man.cgi?query=nmount)
+/// * [`nullfs(5)`](https://www.freebsd.org/cgi/man.cgi?query=nullfs)
+#[cfg(target_os = "freebsd")]
+#[derive(Debug, Default)]
+pub struct Nmount<'a>{
+    iov: Vec<IoVec<&'a [u8]>>,
+    is_owned: Vec<bool>,
+}
+
+#[cfg(target_os = "freebsd")]
+impl<'a> Nmount<'a> {
+    /// Add an opaque mount option.
+    ///
+    /// Some file systems take binary-valued mount options.  They can be set
+    /// with this method.
+    ///
+    /// # Safety
+    ///
+    /// Unsafe because it will cause `Nmount::nmount` to dereference a raw
+    /// pointer.  The user is responsible for ensuring that `val` is valid and
+    /// its lifetime outlives `self`!  An easy way to do that is to give the
+    /// value a larger scope than `name`
+    ///
+    /// # Examples
+    /// ```
+    /// use libc::c_void;
+    /// use nix::mount::Nmount;
+    /// use std::ffi::CString;
+    /// use std::mem;
+    ///
+    /// // Note that flags outlives name
+    /// let mut flags: u32 = 0xdeadbeef;
+    /// let name = CString::new("flags").unwrap();
+    /// let p = &mut flags as *mut u32 as *mut c_void;
+    /// let len = mem::size_of_val(&flags);
+    /// let mut nmount = Nmount::new();
+    /// unsafe { nmount.mut_ptr_opt(&name, p, len) };
+    /// ```
+    pub unsafe fn mut_ptr_opt(
+        &mut self,
+        name: &'a CStr,
+        val: *mut c_void,
+        len: usize
+    ) -> &mut Self
+    {
+        self.iov.push(IoVec::from_slice(name.to_bytes_with_nul()));
+        self.is_owned.push(false);
+        self.iov.push(IoVec::from_raw_parts(val, len));
+        self.is_owned.push(false);
+        self
+    }
+
+    /// Add a mount option that does not take a value.
+    ///
+    /// # Examples
+    /// ```
+    /// use nix::mount::Nmount;
+    /// use std::ffi::CString;
+    ///
+    /// let read_only = CString::new("ro").unwrap();
+    /// Nmount::new()
+    ///     .null_opt(&read_only);
+    /// ```
+    pub fn null_opt(&mut self, name: &'a CStr) -> &mut Self {
+        self.iov.push(IoVec::from_slice(name.to_bytes_with_nul()));
+        self.is_owned.push(false);
+        self.iov.push(IoVec::from_raw_parts(ptr::null_mut(), 0));
+        self.is_owned.push(false);
+        self
+    }
+
+    /// Add a mount option that does not take a value, but whose name must be
+    /// owned.
+    ///
+    ///
+    /// This has higher runtime cost than [`Nmount::null_opt`], but is useful
+    /// when the name's lifetime doesn't outlive the `Nmount`, or it's a
+    /// different string type than `CStr`.
+    ///
+    /// # Examples
+    /// ```
+    /// use nix::mount::Nmount;
+    ///
+    /// let read_only = "ro";
+    /// let mut nmount: Nmount<'static> = Nmount::new();
+    /// nmount.null_opt_owned(read_only);
+    /// ```
+    pub fn null_opt_owned<P: ?Sized + NixPath>(&mut self, name: &P) -> &mut Self
+    {
+        name.with_nix_path(|s| {
+            let len = s.to_bytes_with_nul().len();
+            self.iov.push(IoVec::from_raw_parts(
+                // Must free it later
+                s.to_owned().into_raw() as *mut c_void,
+                len
+            ));
+            self.is_owned.push(true);
+        }).unwrap();
+        self.iov.push(IoVec::from_raw_parts(ptr::null_mut(), 0));
+        self.is_owned.push(false);
+        self
+    }
+
+    /// Add a mount option as a [`CStr`].
+    ///
+    /// # Examples
+    /// ```
+    /// use nix::mount::Nmount;
+    /// use std::ffi::CString;
+    ///
+    /// let fstype = CString::new("fstype").unwrap();
+    /// let nullfs = CString::new("nullfs").unwrap();
+    /// Nmount::new()
+    ///     .str_opt(&fstype, &nullfs);
+    /// ```
+    pub fn str_opt(
+        &mut self,
+        name: &'a CStr,
+        val: &'a CStr
+    ) -> &mut Self
+    {
+        self.iov.push(IoVec::from_slice(name.to_bytes_with_nul()));
+        self.is_owned.push(false);
+        self.iov.push(IoVec::from_slice(val.to_bytes_with_nul()));
+        self.is_owned.push(false);
+        self
+    }
+
+    /// Add a mount option as an owned string.
+    ///
+    /// This has higher runtime cost than [`Nmount::str_opt`], but is useful
+    /// when the value's lifetime doesn't outlive the `Nmount`, or it's a
+    /// different string type than `CStr`.
+    ///
+    /// # Examples
+    /// ```
+    /// use nix::mount::Nmount;
+    /// use std::path::Path;
+    ///
+    /// let mountpoint = Path::new("/mnt");
+    /// Nmount::new()
+    ///     .str_opt_owned("fspath", mountpoint.to_str().unwrap());
+    /// ```
+    pub fn str_opt_owned<P1, P2>(&mut self, name: &P1, val: &P2) -> &mut Self
+        where P1: ?Sized + NixPath,
+              P2: ?Sized + NixPath
+    {
+        name.with_nix_path(|s| {
+            let len = s.to_bytes_with_nul().len();
+            self.iov.push(IoVec::from_raw_parts(
+                // Must free it later
+                s.to_owned().into_raw() as *mut c_void,
+                len
+            ));
+            self.is_owned.push(true);
+        }).unwrap();
+        val.with_nix_path(|s| {
+            let len = s.to_bytes_with_nul().len();
+            self.iov.push(IoVec::from_raw_parts(
+                // Must free it later
+                s.to_owned().into_raw() as *mut c_void,
+                len
+            ));
+            self.is_owned.push(true);
+        }).unwrap();
+        self
+    }
+
+    /// Create a new `Nmount` struct with no options
+    pub fn new() -> Self {
+        Self::default()
+    }
+
+    /// Actually mount the file system.
+    pub fn nmount(&mut self, flags: MntFlags) -> NmountResult {
+        // nmount can return extra error information via a "errmsg" return
+        // argument.
+        const ERRMSG_NAME: &[u8] = b"errmsg\0";
+        let mut errmsg = vec![0u8; 255];
+        self.iov.push(IoVec::from_raw_parts(
+                ERRMSG_NAME.as_ptr() as *mut c_void,
+                ERRMSG_NAME.len()
+        ));
+        self.iov.push(IoVec::from_raw_parts(
+                errmsg.as_mut_ptr() as *mut c_void,
+                errmsg.len()
+        ));
+
+        let niov = self.iov.len() as c_uint;
+        let iovp = self.iov.as_mut_ptr() as *mut libc::iovec;
+        let res = unsafe {
+            libc::nmount(iovp, niov, flags.bits)
+        };
+        match Errno::result(res) {
+            Ok(_) => Ok(()),
+            Err(error) => {
+                let errmsg = match errmsg.iter().position(|&x| x == 0) {
+                    None => None,
+                    Some(0) => None,
+                    Some(n) => {
+                        let sl = &errmsg[0..n + 1];
+                        Some(CStr::from_bytes_with_nul(sl).unwrap())
+                    }
+                };
+                Err(NmountError::new(error, errmsg))
+            }
+        }
+    }
+}
+
+#[cfg(target_os = "freebsd")]
+impl<'a> Drop for Nmount<'a> {
+    fn drop(&mut self) {
+        for (iov, is_owned) in self.iov.iter().zip(self.is_owned.iter()) {
+            if *is_owned {
+                // Free the owned string.  Safe because we recorded ownership,
+                // and Nmount does not implement Clone.
+                unsafe {
+                    drop(CString::from_raw(iov.0.iov_base as *mut c_char));
+                }
+            }
+        }
+    }
+}
+
+/// Unmount the file system mounted at `mountpoint`.
+///
+/// Useful flags include
+/// * `MNT_FORCE` -     Unmount even if still in use.
+/// * `MNT_BYFSID` -    `mountpoint` is not a path, but a file system ID
+///                     encoded as `FSID:val0:val1`, where `val0` and `val1`
+///                     are the contents of the `fsid_t val[]` array in decimal.
+///                     The file system that has the specified file system ID
+///                     will be unmounted.  See
+///                     [`statfs`](crate::sys::statfs::statfs) to determine the
+///                     `fsid`.
+pub fn unmount<P>(mountpoint: &P, flags: MntFlags) -> Result<()>
+    where P: ?Sized + NixPath
+{
+    let res = mountpoint.with_nix_path(|cstr| {
+        unsafe { libc::unmount(cstr.as_ptr(), flags.bits) }
+    })?;
+
+    Errno::result(res).map(drop)
+}
diff --git a/third_party/rust/nix/src/mount.rs b/third_party/rust/nix/src/mount/linux.rs
similarity index 68%
rename from third_party/rust/nix/src/mount.rs
rename to third_party/rust/nix/src/mount/linux.rs
index a9902b170ace8..4cb2fa549070c 100644
--- a/third_party/rust/nix/src/mount.rs
+++ b/third_party/rust/nix/src/mount/linux.rs
@@ -1,6 +1,7 @@
+#![allow(missing_docs)]
 use libc::{self, c_ulong, c_int};
-use {Result, NixPath};
-use errno::Errno;
+use crate::{Result, NixPath};
+use crate::errno::Errno;
 
 libc_bitflags!(
     pub struct MsFlags: c_ulong {
@@ -38,6 +39,7 @@ libc_bitflags!(
         MS_KERNMOUNT;
         MS_I_VERSION;
         MS_STRICTATIME;
+        MS_LAZYTIME;
         MS_ACTIVE;
         MS_NOUSER;
         MS_RMT_MASK;
@@ -61,22 +63,33 @@ pub fn mount<P1: ?Sized + NixPath, P2: ?Sized + NixPath, P3: ?Sized + NixPath, P
         flags: MsFlags,
         data: Option<&P4>) -> Result<()> {
 
-    let res =
-        source.with_nix_path(|source| {
-            target.with_nix_path(|target| {
-                fstype.with_nix_path(|fstype| {
-                    data.with_nix_path(|data| {
-                        unsafe {
-                            libc::mount(source.as_ptr(),
-                                       target.as_ptr(),
-                                       fstype.as_ptr(),
-                                       flags.bits,
-                                       data.as_ptr() as *const libc::c_void)
-                        }
-                    })
+    fn with_opt_nix_path<P, T, F>(p: Option<&P>, f: F) -> Result<T>
+        where P: ?Sized + NixPath,
+              F: FnOnce(*const libc::c_char) -> T
+    {
+        match p {
+            Some(path) => path.with_nix_path(|p_str| f(p_str.as_ptr())),
+            None => Ok(f(std::ptr::null()))
+        }
+    }
+
+    let res = with_opt_nix_path(source, |s| {
+        target.with_nix_path(|t| {
+            with_opt_nix_path(fstype, |ty| {
+                with_opt_nix_path(data, |d| {
+                    unsafe {
+                        libc::mount(
+                            s,
+                            t.as_ptr(),
+                            ty,
+                            flags.bits,
+                            d as *const libc::c_void
+                        )
+                    }
                 })
             })
-        })????;
+        })
+    })????;
 
     Errno::result(res).map(drop)
 }
diff --git a/third_party/rust/nix/src/mount/mod.rs b/third_party/rust/nix/src/mount/mod.rs
new file mode 100644
index 0000000000000..14bf2a963607f
--- /dev/null
+++ b/third_party/rust/nix/src/mount/mod.rs
@@ -0,0 +1,21 @@
+//! Mount file systems
+#[cfg(any(target_os = "android", target_os = "linux"))]
+mod linux;
+
+#[cfg(any(target_os = "android", target_os = "linux"))]
+pub use self::linux::*;
+
+#[cfg(any(target_os = "dragonfly",
+          target_os = "freebsd",
+          target_os = "macos",
+          target_os = "netbsd",
+          target_os = "openbsd"))]
+mod bsd;
+
+#[cfg(any(target_os = "dragonfly",
+          target_os = "freebsd",
+          target_os = "macos",
+          target_os = "netbsd",
+          target_os = "openbsd"
+          ))]
+pub use self::bsd::*;
diff --git a/third_party/rust/nix/src/mqueue.rs b/third_party/rust/nix/src/mqueue.rs
index b958b71cddb46..34fd80278589d 100644
--- a/third_party/rust/nix/src/mqueue.rs
+++ b/third_party/rust/nix/src/mqueue.rs
@@ -1,13 +1,13 @@
 //! Posix Message Queue functions
 //!
-//! [Further reading and details on the C API](http://man7.org/linux/man-pages/man7/mq_overview.7.html)
+//! [Further reading and details on the C API](https://man7.org/linux/man-pages/man7/mq_overview.7.html)
 
-use Result;
-use errno::Errno;
+use crate::Result;
+use crate::errno::Errno;
 
-use libc::{self, c_char, c_long, mqd_t, size_t};
+use libc::{self, c_char, mqd_t, size_t};
 use std::ffi::CString;
-use sys::stat::Mode;
+use crate::sys::stat::Mode;
 use std::mem;
 
 libc_bitflags!{
@@ -34,21 +34,32 @@ pub struct MqAttr {
     mq_attr: libc::mq_attr,
 }
 
+// x32 compatibility
+// See https://sourceware.org/bugzilla/show_bug.cgi?id=21279
+#[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+pub type mq_attr_member_t = i64;
+#[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+pub type mq_attr_member_t = libc::c_long;
+
 impl MqAttr {
-    pub fn new(mq_flags: c_long,
-               mq_maxmsg: c_long,
-               mq_msgsize: c_long,
-               mq_curmsgs: c_long)
-               -> MqAttr {
-        let mut attr = unsafe { mem::uninitialized::<libc::mq_attr>() };
-        attr.mq_flags = mq_flags;
-        attr.mq_maxmsg = mq_maxmsg;
-        attr.mq_msgsize = mq_msgsize;
-        attr.mq_curmsgs = mq_curmsgs;
-        MqAttr { mq_attr: attr }
+    pub fn new(mq_flags: mq_attr_member_t,
+               mq_maxmsg: mq_attr_member_t,
+               mq_msgsize: mq_attr_member_t,
+               mq_curmsgs: mq_attr_member_t)
+               -> MqAttr
+    {
+        let mut attr = mem::MaybeUninit::<libc::mq_attr>::uninit();
+        unsafe {
+            let p = attr.as_mut_ptr();
+            (*p).mq_flags = mq_flags;
+            (*p).mq_maxmsg = mq_maxmsg;
+            (*p).mq_msgsize = mq_msgsize;
+            (*p).mq_curmsgs = mq_curmsgs;
+            MqAttr { mq_attr: attr.assume_init() }
+        }
     }
 
-    pub fn flags(&self) -> c_long {
+    pub const fn flags(&self) -> mq_attr_member_t {
         self.mq_attr.mq_flags
     }
 }
@@ -56,7 +67,9 @@ impl MqAttr {
 
 /// Open a message queue
 ///
-/// See also [`mq_open(2)`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_open.html)
+/// See also [`mq_open(2)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_open.html)
+// The mode.bits cast is only lossless on some OSes
+#[allow(clippy::cast_lossless)]
 pub fn mq_open(name: &CString,
                oflag: MQ_OFlag,
                mode: Mode,
@@ -76,7 +89,7 @@ pub fn mq_open(name: &CString,
 
 /// Remove a message queue
 ///
-/// See also [`mq_unlink(2)`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_unlink.html)
+/// See also [`mq_unlink(2)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_unlink.html)
 pub fn mq_unlink(name: &CString) -> Result<()> {
     let res = unsafe { libc::mq_unlink(name.as_ptr()) };
     Errno::result(res).map(drop)
@@ -84,7 +97,7 @@ pub fn mq_unlink(name: &CString) -> Result<()> {
 
 /// Close a message queue
 ///
-/// See also [`mq_close(2)`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_close.html)
+/// See also [`mq_close(2)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_close.html)
 pub fn mq_close(mqdes: mqd_t) -> Result<()> {
     let res = unsafe { libc::mq_close(mqdes) };
     Errno::result(res).map(drop)
@@ -92,7 +105,7 @@ pub fn mq_close(mqdes: mqd_t) -> Result<()> {
 
 /// Receive a message from a message queue
 ///
-/// See also [`mq_receive(2)`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_receive.html)
+/// See also [`mq_receive(2)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_receive.html)
 pub fn mq_receive(mqdes: mqd_t, message: &mut [u8], msg_prio: &mut u32) -> Result<usize> {
     let len = message.len() as size_t;
     let res = unsafe {
@@ -106,7 +119,7 @@ pub fn mq_receive(mqdes: mqd_t, message: &mut [u8], msg_prio: &mut u32) -> Resul
 
 /// Send a message to a message queue
 ///
-/// See also [`mq_send(2)`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_send.html)
+/// See also [`mq_send(2)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_send.html)
 pub fn mq_send(mqdes: mqd_t, message: &[u8], msq_prio: u32) -> Result<()> {
     let res = unsafe {
         libc::mq_send(mqdes,
@@ -119,30 +132,33 @@ pub fn mq_send(mqdes: mqd_t, message: &[u8], msq_prio: u32) -> Result<()> {
 
 /// Get message queue attributes
 ///
-/// See also [`mq_getattr(2)`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_getattr.html)
+/// See also [`mq_getattr(2)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_getattr.html)
 pub fn mq_getattr(mqd: mqd_t) -> Result<MqAttr> {
-    let mut attr = unsafe { mem::uninitialized::<libc::mq_attr>() };
-    let res = unsafe { libc::mq_getattr(mqd, &mut attr) };
-    Errno::result(res).map(|_| MqAttr { mq_attr: attr })
+    let mut attr = mem::MaybeUninit::<libc::mq_attr>::uninit();
+    let res = unsafe { libc::mq_getattr(mqd, attr.as_mut_ptr()) };
+    Errno::result(res).map(|_| unsafe{MqAttr { mq_attr: attr.assume_init() }})
 }
 
 /// Set the attributes of the message queue. Only `O_NONBLOCK` can be set, everything else will be ignored
 /// Returns the old attributes
 /// It is recommend to use the `mq_set_nonblock()` and `mq_remove_nonblock()` convenience functions as they are easier to use
 ///
-/// [Further reading](http://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_setattr.html)
+/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_setattr.html)
 pub fn mq_setattr(mqd: mqd_t, newattr: &MqAttr) -> Result<MqAttr> {
-    let mut attr = unsafe { mem::uninitialized::<libc::mq_attr>() };
-    let res = unsafe { libc::mq_setattr(mqd, &newattr.mq_attr as *const libc::mq_attr, &mut attr) };
-    Errno::result(res).map(|_| MqAttr { mq_attr: attr })
+    let mut attr = mem::MaybeUninit::<libc::mq_attr>::uninit();
+    let res = unsafe {
+        libc::mq_setattr(mqd, &newattr.mq_attr as *const libc::mq_attr, attr.as_mut_ptr())
+    };
+    Errno::result(res).map(|_| unsafe{ MqAttr { mq_attr: attr.assume_init() }})
 }
 
 /// Convenience function.
 /// Sets the `O_NONBLOCK` attribute for a given message queue descriptor
 /// Returns the old attributes
-pub fn mq_set_nonblock(mqd: mqd_t) -> Result<(MqAttr)> {
+#[allow(clippy::useless_conversion)]    // Not useless on all OSes
+pub fn mq_set_nonblock(mqd: mqd_t) -> Result<MqAttr> {
     let oldattr = mq_getattr(mqd)?;
-    let newattr = MqAttr::new(MQ_OFlag::O_NONBLOCK.bits() as c_long,
+    let newattr = MqAttr::new(mq_attr_member_t::from(MQ_OFlag::O_NONBLOCK.bits()),
                               oldattr.mq_attr.mq_maxmsg,
                               oldattr.mq_attr.mq_msgsize,
                               oldattr.mq_attr.mq_curmsgs);
@@ -152,7 +168,7 @@ pub fn mq_set_nonblock(mqd: mqd_t) -> Result<(MqAttr)> {
 /// Convenience function.
 /// Removes `O_NONBLOCK` attribute for a given message queue descriptor
 /// Returns the old attributes
-pub fn mq_remove_nonblock(mqd: mqd_t) -> Result<(MqAttr)> {
+pub fn mq_remove_nonblock(mqd: mqd_t) -> Result<MqAttr> {
     let oldattr = mq_getattr(mqd)?;
     let newattr = MqAttr::new(0,
                               oldattr.mq_attr.mq_maxmsg,
diff --git a/third_party/rust/nix/src/net/if_.rs b/third_party/rust/nix/src/net/if_.rs
index 58d677ae343d1..bc00a4328b4eb 100644
--- a/third_party/rust/nix/src/net/if_.rs
+++ b/third_party/rust/nix/src/net/if_.rs
@@ -3,9 +3,8 @@
 //! Uses Linux and/or POSIX functions to resolve interface names like "eth0"
 //! or "socan1" into device numbers.
 
-use libc;
+use crate::{Error, NixPath, Result};
 use libc::c_uint;
-use {Result, Error, NixPath};
 
 /// Resolve an interface into a interface number.
 pub fn if_nametoindex<P: ?Sized + NixPath>(name: &P) -> Result<c_uint> {
@@ -22,39 +21,41 @@ libc_bitflags!(
     /// Standard interface flags, used by `getifaddrs`
     pub struct InterfaceFlags: libc::c_int {
         /// Interface is running. (see
-        /// [`netdevice(7)`](http://man7.org/linux/man-pages/man7/netdevice.7.html))
+        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))
         IFF_UP;
         /// Valid broadcast address set. (see
-        /// [`netdevice(7)`](http://man7.org/linux/man-pages/man7/netdevice.7.html))
+        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))
         IFF_BROADCAST;
         /// Internal debugging flag. (see
-        /// [`netdevice(7)`](http://man7.org/linux/man-pages/man7/netdevice.7.html))
+        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))
         IFF_DEBUG;
         /// Interface is a loopback interface. (see
-        /// [`netdevice(7)`](http://man7.org/linux/man-pages/man7/netdevice.7.html))
+        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))
         IFF_LOOPBACK;
         /// Interface is a point-to-point link. (see
-        /// [`netdevice(7)`](http://man7.org/linux/man-pages/man7/netdevice.7.html))
+        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))
         IFF_POINTOPOINT;
         /// Avoid use of trailers. (see
-        /// [`netdevice(7)`](http://man7.org/linux/man-pages/man7/netdevice.7.html))
+        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))
         #[cfg(any(target_os = "android",
                   target_os = "fuchsia",
                   target_os = "ios",
                   target_os = "linux",
                   target_os = "macos",
                   target_os = "netbsd",
+                  target_os = "illumos",
                   target_os = "solaris"))]
         IFF_NOTRAILERS;
         /// Interface manages own routes.
         #[cfg(any(target_os = "dragonfly"))]
         IFF_SMART;
         /// Resources allocated. (see
-        /// [`netdevice(7)`](http://man7.org/linux/man-pages/man7/netdevice.7.html))
+        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))
         #[cfg(any(target_os = "android",
                   target_os = "dragonfly",
                   target_os = "freebsd",
                   target_os = "fuchsia",
+                  target_os = "illumos",
                   target_os = "ios",
                   target_os = "linux",
                   target_os = "macos",
@@ -63,16 +64,16 @@ libc_bitflags!(
                   target_os = "solaris"))]
         IFF_RUNNING;
         /// No arp protocol, L2 destination address not set. (see
-        /// [`netdevice(7)`](http://man7.org/linux/man-pages/man7/netdevice.7.html))
+        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))
         IFF_NOARP;
         /// Interface is in promiscuous mode. (see
-        /// [`netdevice(7)`](http://man7.org/linux/man-pages/man7/netdevice.7.html))
+        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))
         IFF_PROMISC;
         /// Receive all multicast packets. (see
-        /// [`netdevice(7)`](http://man7.org/linux/man-pages/man7/netdevice.7.html))
+        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))
         IFF_ALLMULTI;
         /// Master of a load balancing bundle. (see
-        /// [`netdevice(7)`](http://man7.org/linux/man-pages/man7/netdevice.7.html))
+        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))
         #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
         IFF_MASTER;
         /// transmission in progress, tx hardware queue is full
@@ -83,10 +84,10 @@ libc_bitflags!(
                   target_os = "ios"))]
         IFF_OACTIVE;
         /// Protocol code on board.
-        #[cfg(target_os = "solaris")]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
         IFF_INTELLIGENT;
         /// Slave of a load balancing bundle. (see
-        /// [`netdevice(7)`](http://man7.org/linux/man-pages/man7/netdevice.7.html))
+        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))
         #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
         IFF_SLAVE;
         /// Can't hear own transmissions.
@@ -98,7 +99,7 @@ libc_bitflags!(
                   target_os = "osx"))]
         IFF_SIMPLEX;
         /// Supports multicast. (see
-        /// [`netdevice(7)`](http://man7.org/linux/man-pages/man7/netdevice.7.html))
+        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))
         IFF_MULTICAST;
         /// Per link layer defined bit.
         #[cfg(any(target_os = "dragonfly",
@@ -109,10 +110,10 @@ libc_bitflags!(
                   target_os = "ios"))]
         IFF_LINK0;
         /// Multicast using broadcast.
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
         IFF_MULTI_BCAST;
         /// Is able to select media type via ifmap. (see
-        /// [`netdevice(7)`](http://man7.org/linux/man-pages/man7/netdevice.7.html))
+        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))
         #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
         IFF_PORTSEL;
         /// Per link layer defined bit.
@@ -124,10 +125,10 @@ libc_bitflags!(
                   target_os = "ios"))]
         IFF_LINK1;
         /// Non-unique address.
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
         IFF_UNNUMBERED;
         /// Auto media selection active. (see
-        /// [`netdevice(7)`](http://man7.org/linux/man-pages/man7/netdevice.7.html))
+        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))
         #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
         IFF_AUTOMEDIA;
         /// Per link layer defined bit.
@@ -144,15 +145,15 @@ libc_bitflags!(
                   target_os = "macos",
                   target_os = "ios"))]
         IFF_ALTPHYS;
-        /// DHCP controlls interface.
-        #[cfg(any(target_os = "solaris"))]
+        /// DHCP controls interface.
+        #[cfg(any(target_os = "solaris", target_os = "illumos"))]
         IFF_DHCPRUNNING;
         /// The addresses are lost when the interface goes down. (see
-        /// [`netdevice(7)`](http://man7.org/linux/man-pages/man7/netdevice.7.html))
+        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))
         #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
         IFF_DYNAMIC;
         /// Do not advertise.
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
         IFF_PRIVATE;
         /// Driver signals L1 up. Volatile.
         #[cfg(any(target_os = "fuchsia", target_os = "linux"))]
@@ -164,7 +165,7 @@ libc_bitflags!(
         #[cfg(any(target_os = "freebsd"))]
         IFF_CANTCONFIG;
         /// Do not transmit packets.
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
         IFF_NOXMIT;
         /// Driver signals dormant. Volatile.
         #[cfg(any(target_os = "fuchsia", target_os = "linux"))]
@@ -173,7 +174,7 @@ libc_bitflags!(
         #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
         IFF_PPROMISC;
         /// Just on-link subnet.
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
         IFF_NOLOCAL;
         /// Echo sent packets. Volatile.
         #[cfg(any(target_os = "fuchsia", target_os = "linux"))]
@@ -182,19 +183,19 @@ libc_bitflags!(
         #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
         IFF_MONITOR;
         /// Address is deprecated.
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
         IFF_DEPRECATED;
         /// Static ARP.
         #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
         IFF_STATICARP;
         /// Address from stateless addrconf.
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
         IFF_ADDRCONF;
         /// Interface is in polling mode.
         #[cfg(any(target_os = "dragonfly"))]
         IFF_NPOLLING;
         /// Router on interface.
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
         IFF_ROUTER;
         /// Interface is in polling mode.
         #[cfg(any(target_os = "dragonfly"))]
@@ -203,66 +204,208 @@ libc_bitflags!(
         #[cfg(any(target_os = "freebsd"))]
         IFF_DYING;
         /// No NUD on interface.
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
         IFF_NONUD;
         /// Interface is being renamed
         #[cfg(any(target_os = "freebsd"))]
         IFF_RENAMING;
         /// Anycast address.
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
         IFF_ANYCAST;
         /// Don't exchange routing info.
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
         IFF_NORTEXCH;
         /// Do not provide packet information
         #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
         IFF_NO_PI as libc::c_int;
-        /// TUN device (no Ethernet headers) 
+        /// TUN device (no Ethernet headers)
         #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
         IFF_TUN as libc::c_int;
         /// TAP device
         #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
         IFF_TAP as libc::c_int;
         /// IPv4 interface.
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
         IFF_IPV4;
         /// IPv6 interface.
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
         IFF_IPV6;
         /// in.mpathd test address
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
         IFF_NOFAILOVER;
         /// Interface has failed
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
         IFF_FAILED;
         /// Interface is a hot-spare
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
         IFF_STANDBY;
         /// Functioning but not used
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
         IFF_INACTIVE;
         /// Interface is offline
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
         IFF_OFFLINE;
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(target_os = "solaris")]
         IFF_COS_ENABLED;
         /// Prefer as source addr.
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(target_os = "solaris")]
         IFF_PREFERRED;
         /// RFC3041
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(target_os = "solaris")]
         IFF_TEMPORARY;
         /// MTU set with SIOCSLIFMTU
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(target_os = "solaris")]
         IFF_FIXEDMTU;
         /// Cannot send / receive packets
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(target_os = "solaris")]
         IFF_VIRTUAL;
         /// Local address in use
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(target_os = "solaris")]
         IFF_DUPLICATE;
         /// IPMP IP interface
-        #[cfg(any(target_os = "solaris"))]
+        #[cfg(target_os = "solaris")]
         IFF_IPMP;
     }
 );
+
+#[cfg(any(
+    target_os = "dragonfly",
+    target_os = "freebsd",
+    target_os = "fuchsia",
+    target_os = "ios",
+    target_os = "linux",
+    target_os = "macos",
+    target_os = "netbsd",
+    target_os = "openbsd",
+))]
+mod if_nameindex {
+    use super::*;
+
+    use std::ffi::CStr;
+    use std::fmt;
+    use std::marker::PhantomData;
+    use std::ptr::NonNull;
+
+    /// A network interface. Has a name like "eth0" or "wlp4s0" or "wlan0", as well as an index
+    /// (1, 2, 3, etc) that identifies it in the OS's networking stack.
+    #[allow(missing_copy_implementations)]
+    #[repr(transparent)]
+    pub struct Interface(libc::if_nameindex);
+
+    impl Interface {
+        /// Obtain the index of this interface.
+        pub fn index(&self) -> c_uint {
+            self.0.if_index
+        }
+
+        /// Obtain the name of this interface.
+        pub fn name(&self) -> &CStr {
+            unsafe { CStr::from_ptr(self.0.if_name) }
+        }
+    }
+
+    impl fmt::Debug for Interface {
+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+            f.debug_struct("Interface")
+                .field("index", &self.index())
+                .field("name", &self.name())
+                .finish()
+        }
+    }
+
+    /// A list of the network interfaces available on this system. Obtained from [`if_nameindex()`].
+    pub struct Interfaces {
+        ptr: NonNull<libc::if_nameindex>,
+    }
+
+    impl Interfaces {
+        /// Iterate over the interfaces in this list.
+        #[inline]
+        pub fn iter(&self) -> InterfacesIter<'_> {
+            self.into_iter()
+        }
+
+        /// Convert this to a slice of interfaces. Note that the underlying interfaces list is
+        /// null-terminated, so calling this calculates the length. If random access isn't needed,
+        /// [`Interfaces::iter()`] should be used instead.
+        pub fn to_slice(&self) -> &[Interface] {
+            let ifs = self.ptr.as_ptr() as *const Interface;
+            let len = self.iter().count();
+            unsafe { std::slice::from_raw_parts(ifs, len) }
+        }
+    }
+
+    impl Drop for Interfaces {
+        fn drop(&mut self) {
+            unsafe { libc::if_freenameindex(self.ptr.as_ptr()) };
+        }
+    }
+
+    impl fmt::Debug for Interfaces {
+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+            self.to_slice().fmt(f)
+        }
+    }
+
+    impl<'a> IntoIterator for &'a Interfaces {
+        type IntoIter = InterfacesIter<'a>;
+        type Item = &'a Interface;
+        #[inline]
+        fn into_iter(self) -> Self::IntoIter {
+            InterfacesIter {
+                ptr: self.ptr.as_ptr(),
+                _marker: PhantomData,
+            }
+        }
+    }
+
+    /// An iterator over the interfaces in an [`Interfaces`].
+    #[derive(Debug)]
+    pub struct InterfacesIter<'a> {
+        ptr: *const libc::if_nameindex,
+        _marker: PhantomData<&'a Interfaces>,
+    }
+
+    impl<'a> Iterator for InterfacesIter<'a> {
+        type Item = &'a Interface;
+        #[inline]
+        fn next(&mut self) -> Option<Self::Item> {
+            unsafe {
+                if (*self.ptr).if_index == 0 {
+                    None
+                } else {
+                    let ret = &*(self.ptr as *const Interface);
+                    self.ptr = self.ptr.add(1);
+                    Some(ret)
+                }
+            }
+        }
+    }
+
+    /// Retrieve a list of the network interfaces available on the local system.
+    ///
+    /// ```
+    /// let interfaces = nix::net::if_::if_nameindex().unwrap();
+    /// for iface in &interfaces {
+    ///     println!("Interface #{} is called {}", iface.index(), iface.name().to_string_lossy());
+    /// }
+    /// ```
+    pub fn if_nameindex() -> Result<Interfaces> {
+        unsafe {
+            let ifs = libc::if_nameindex();
+            let ptr = NonNull::new(ifs).ok_or_else(Error::last)?;
+            Ok(Interfaces { ptr })
+        }
+    }
+}
+#[cfg(any(
+    target_os = "dragonfly",
+    target_os = "freebsd",
+    target_os = "fuchsia",
+    target_os = "ios",
+    target_os = "linux",
+    target_os = "macos",
+    target_os = "netbsd",
+    target_os = "openbsd",
+))]
+pub use if_nameindex::*;
diff --git a/third_party/rust/nix/src/poll.rs b/third_party/rust/nix/src/poll.rs
index c603611e3176f..8556c1bb748df 100644
--- a/third_party/rust/nix/src/poll.rs
+++ b/third_party/rust/nix/src/poll.rs
@@ -1,13 +1,12 @@
 //! Wait for events to trigger on specific file descriptors
 #[cfg(any(target_os = "android", target_os = "dragonfly", target_os = "freebsd", target_os = "linux"))]
-use sys::time::TimeSpec;
+use crate::sys::time::TimeSpec;
 #[cfg(any(target_os = "android", target_os = "dragonfly", target_os = "freebsd", target_os = "linux"))]
-use sys::signal::SigSet;
-use std::os::unix::io::RawFd;
+use crate::sys::signal::SigSet;
+use std::os::unix::io::{AsRawFd, RawFd};
 
-use libc;
-use Result;
-use errno::Errno;
+use crate::Result;
+use crate::errno::Errno;
 
 /// This is a wrapper around `libc::pollfd`.
 ///
@@ -17,7 +16,7 @@ use errno::Errno;
 ///
 /// After a call to `poll` or `ppoll`, the events that occured can be
 /// retrieved by calling [`revents()`](#method.revents) on the `PollFd`.
-#[repr(C)]
+#[repr(transparent)]
 #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
 pub struct PollFd {
     pollfd: libc::pollfd,
@@ -26,20 +25,37 @@ pub struct PollFd {
 impl PollFd {
     /// Creates a new `PollFd` specifying the events of interest
     /// for a given file descriptor.
-    pub fn new(fd: RawFd, events: PollFlags) -> PollFd {
+    pub const fn new(fd: RawFd, events: PollFlags) -> PollFd {
         PollFd {
             pollfd: libc::pollfd {
-                fd: fd,
+                fd,
                 events: events.bits(),
                 revents: PollFlags::empty().bits(),
             },
         }
     }
 
-    /// Returns the events that occured in the last call to `poll` or `ppoll`.
-    pub fn revents(&self) -> Option<PollFlags> {
+    /// Returns the events that occured in the last call to `poll` or `ppoll`.  Will only return
+    /// `None` if the kernel provides status flags that Nix does not know about.
+    pub fn revents(self) -> Option<PollFlags> {
         PollFlags::from_bits(self.pollfd.revents)
     }
+
+    /// The events of interest for this `PollFd`.
+    pub fn events(self) -> PollFlags {
+        PollFlags::from_bits(self.pollfd.events).unwrap()
+    }
+
+    /// Modify the events of interest for this `PollFd`.
+    pub fn set_events(&mut self, events: PollFlags) {
+        self.pollfd.events = events.bits();
+    }
+}
+
+impl AsRawFd for PollFd {
+    fn as_raw_fd(&self) -> RawFd {
+        self.pollfd.fd
+    }
 }
 
 libc_bitflags! {
@@ -52,24 +68,28 @@ libc_bitflags! {
         /// Possibilities include:
         ///
         /// *  There is out-of-band data on a TCP socket (see
-        ///    [tcp(7)](http://man7.org/linux/man-pages/man7/tcp.7.html)).
+        ///    [tcp(7)](https://man7.org/linux/man-pages/man7/tcp.7.html)).
         /// *  A pseudoterminal master in packet mode has seen a state
         ///    change on the slave (see
-        ///    [ioctl_tty(2)](http://man7.org/linux/man-pages/man2/ioctl_tty.2.html)).
+        ///    [ioctl_tty(2)](https://man7.org/linux/man-pages/man2/ioctl_tty.2.html)).
         /// *  A cgroup.events file has been modified (see
-        ///    [cgroups(7)](http://man7.org/linux/man-pages/man7/cgroups.7.html)).
+        ///    [cgroups(7)](https://man7.org/linux/man-pages/man7/cgroups.7.html)).
         POLLPRI;
         /// Writing is now possible, though a write larger that the
         /// available space in a socket or pipe will still block (unless
         /// `O_NONBLOCK` is set).
         POLLOUT;
         /// Equivalent to [`POLLIN`](constant.POLLIN.html)
+        #[cfg(not(target_os = "redox"))]
         POLLRDNORM;
+        #[cfg(not(target_os = "redox"))]
         /// Equivalent to [`POLLOUT`](constant.POLLOUT.html)
         POLLWRNORM;
         /// Priority band data can be read (generally unused on Linux).
+        #[cfg(not(target_os = "redox"))]
         POLLRDBAND;
         /// Priority data may be written.
+        #[cfg(not(target_os = "redox"))]
         POLLWRBAND;
         /// Error condition (only returned in
         /// [`PollFd::revents`](struct.PollFd.html#method.revents);
@@ -93,7 +113,7 @@ libc_bitflags! {
 }
 
 /// `poll` waits for one of a set of file descriptors to become ready to perform I/O.
-/// ([`poll(2)`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/poll.html))
+/// ([`poll(2)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/poll.html))
 ///
 /// `fds` contains all [`PollFd`](struct.PollFd.html) to poll.
 /// The function will return as soon as any event occur for any of these `PollFd`s.
@@ -124,19 +144,19 @@ pub fn poll(fds: &mut [PollFd], timeout: libc::c_int) -> Result<libc::c_int> {
 
 /// `ppoll()` allows an application to safely wait until either a file
 /// descriptor becomes ready or until a signal is caught.
-/// ([`poll(2)`](http://man7.org/linux/man-pages/man2/poll.2.html))
+/// ([`poll(2)`](https://man7.org/linux/man-pages/man2/poll.2.html))
 ///
 /// `ppoll` behaves like `poll`, but let you specify what signals may interrupt it
-/// with the `sigmask` argument.
+/// with the `sigmask` argument. If you want `ppoll` to block indefinitely,
+/// specify `None` as `timeout` (it is like `timeout = -1` for `poll`).
 ///
 #[cfg(any(target_os = "android", target_os = "dragonfly", target_os = "freebsd", target_os = "linux"))]
-pub fn ppoll(fds: &mut [PollFd], timeout: TimeSpec, sigmask: SigSet) -> Result<libc::c_int> {
-
-
+pub fn ppoll(fds: &mut [PollFd], timeout: Option<TimeSpec>, sigmask: SigSet) -> Result<libc::c_int> {
+    let timeout = timeout.as_ref().map_or(core::ptr::null(), |r| r.as_ref());
     let res = unsafe {
         libc::ppoll(fds.as_mut_ptr() as *mut libc::pollfd,
                     fds.len() as libc::nfds_t,
-                    timeout.as_ref(),
+                    timeout,
                     sigmask.as_ref())
     };
     Errno::result(res)
diff --git a/third_party/rust/nix/src/pty.rs b/third_party/rust/nix/src/pty.rs
index db012d8158c53..facc9aaf4006e 100644
--- a/third_party/rust/nix/src/pty.rs
+++ b/third_party/rust/nix/src/pty.rs
@@ -1,18 +1,17 @@
 //! Create master and slave virtual pseudo-terminals (PTYs)
 
-use libc;
-
 pub use libc::pid_t as SessionId;
 pub use libc::winsize as Winsize;
 
 use std::ffi::CStr;
+use std::io;
 use std::mem;
 use std::os::unix::prelude::*;
 
-use sys::termios::Termios;
-use unistd::ForkResult;
-use {Result, Error, fcntl};
-use errno::Errno;
+use crate::sys::termios::Termios;
+use crate::unistd::{self, ForkResult, Pid};
+use crate::{Result, fcntl};
+use crate::errno::Errno;
 
 /// Representation of a master/slave pty pair
 ///
@@ -44,7 +43,7 @@ pub struct ForkptyResult {
 /// While this datatype is a thin wrapper around `RawFd`, it enforces that the available PTY
 /// functions are given the correct file descriptor. Additionally this type implements `Drop`,
 /// so that when it's consumed or goes out of scope, it's automatically cleaned-up.
-#[derive(Clone, Debug, Eq, Hash, PartialEq)]
+#[derive(Debug, Eq, Hash, PartialEq)]
 pub struct PtyMaster(RawFd);
 
 impl AsRawFd for PtyMaster {
@@ -70,29 +69,44 @@ impl Drop for PtyMaster {
         // invalid file descriptor.  That frequently indicates a double-close
         // condition, which can cause confusing errors for future I/O
         // operations.
-        let e = ::unistd::close(self.0);
-        if e == Err(Error::Sys(Errno::EBADF)) {
+        let e = unistd::close(self.0);
+        if e == Err(Errno::EBADF) {
             panic!("Closing an invalid file descriptor!");
         };
     }
 }
 
+impl io::Read for PtyMaster {
+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
+        unistd::read(self.0, buf).map_err(io::Error::from)
+    }
+}
+
+impl io::Write for PtyMaster {
+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
+        unistd::write(self.0, buf).map_err(io::Error::from)
+    }
+    fn flush(&mut self) -> io::Result<()> {
+        Ok(())
+    }
+}
+
 /// Grant access to a slave pseudoterminal (see
-/// [`grantpt(3)`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/grantpt.html))
+/// [`grantpt(3)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/grantpt.html))
 ///
 /// `grantpt()` changes the mode and owner of the slave pseudoterminal device corresponding to the
 /// master pseudoterminal referred to by `fd`. This is a necessary step towards opening the slave.
 #[inline]
 pub fn grantpt(fd: &PtyMaster) -> Result<()> {
     if unsafe { libc::grantpt(fd.as_raw_fd()) } < 0 {
-        return Err(Error::last());
+        return Err(Errno::last());
     }
 
     Ok(())
 }
 
 /// Open a pseudoterminal device (see
-/// [`posix_openpt(3)`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_openpt.html))
+/// [`posix_openpt(3)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_openpt.html))
 ///
 /// `posix_openpt()` returns a file descriptor to an existing unused pseuterminal master device.
 ///
@@ -131,14 +145,14 @@ pub fn posix_openpt(flags: fcntl::OFlag) -> Result<PtyMaster> {
     };
 
     if fd < 0 {
-        return Err(Error::last());
+        return Err(Errno::last());
     }
 
     Ok(PtyMaster(fd))
 }
 
 /// Get the name of the slave pseudoterminal (see
-/// [`ptsname(3)`](http://man7.org/linux/man-pages/man3/ptsname.3.html))
+/// [`ptsname(3)`](https://man7.org/linux/man-pages/man3/ptsname.3.html))
 ///
 /// `ptsname()` returns the name of the slave pseudoterminal device corresponding to the master
 /// referred to by `fd`.
@@ -157,7 +171,7 @@ pub fn posix_openpt(flags: fcntl::OFlag) -> Result<PtyMaster> {
 pub unsafe fn ptsname(fd: &PtyMaster) -> Result<String> {
     let name_ptr = libc::ptsname(fd.as_raw_fd());
     if name_ptr.is_null() {
-        return Err(Error::last());
+        return Err(Errno::last());
     }
 
     let name = CStr::from_ptr(name_ptr);
@@ -165,7 +179,7 @@ pub unsafe fn ptsname(fd: &PtyMaster) -> Result<String> {
 }
 
 /// Get the name of the slave pseudoterminal (see
-/// [`ptsname(3)`](http://man7.org/linux/man-pages/man3/ptsname.3.html))
+/// [`ptsname(3)`](https://man7.org/linux/man-pages/man3/ptsname.3.html))
 ///
 /// `ptsname_r()` returns the name of the slave pseudoterminal device corresponding to the master
 /// referred to by `fd`. This is the threadsafe version of `ptsname()`, but it is not part of the
@@ -176,23 +190,22 @@ pub unsafe fn ptsname(fd: &PtyMaster) -> Result<String> {
 #[cfg(any(target_os = "android", target_os = "linux"))]
 #[inline]
 pub fn ptsname_r(fd: &PtyMaster) -> Result<String> {
-    let mut name_buf = vec![0u8; 64];
-    let name_buf_ptr = name_buf.as_mut_ptr() as *mut libc::c_char;
-    if unsafe { libc::ptsname_r(fd.as_raw_fd(), name_buf_ptr, name_buf.capacity()) } != 0 {
-        return Err(Error::last());
-    }
-
-    // Find the first null-character terminating this string. This is guaranteed to succeed if the
-    // return value of `libc::ptsname_r` is 0.
-    let null_index = name_buf.iter().position(|c| *c == b'\0').unwrap();
-    name_buf.truncate(null_index);
+    let mut name_buf = Vec::<libc::c_char>::with_capacity(64);
+    let name_buf_ptr = name_buf.as_mut_ptr();
+    let cname = unsafe {
+        let cap = name_buf.capacity();
+        if libc::ptsname_r(fd.as_raw_fd(), name_buf_ptr, cap) != 0 {
+            return Err(crate::Error::last());
+        }
+        CStr::from_ptr(name_buf.as_ptr())
+    };
 
-    let name = String::from_utf8(name_buf)?;
+    let name = cname.to_string_lossy().into_owned();
     Ok(name)
 }
 
 /// Unlock a pseudoterminal master/slave pseudoterminal pair (see
-/// [`unlockpt(3)`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/unlockpt.html))
+/// [`unlockpt(3)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/unlockpt.html))
 ///
 /// `unlockpt()` unlocks the slave pseudoterminal device corresponding to the master pseudoterminal
 /// referred to by `fd`. This must be called before trying to open the slave side of a
@@ -200,7 +213,7 @@ pub fn ptsname_r(fd: &PtyMaster) -> Result<String> {
 #[inline]
 pub fn unlockpt(fd: &PtyMaster) -> Result<()> {
     if unsafe { libc::unlockpt(fd.as_raw_fd()) } < 0 {
-        return Err(Error::last());
+        return Err(Errno::last());
     }
 
     Ok(())
@@ -209,7 +222,7 @@ pub fn unlockpt(fd: &PtyMaster) -> Result<()> {
 
 /// Create a new pseudoterminal, returning the slave and master file descriptors
 /// in `OpenptyResult`
-/// (see [`openpty`](http://man7.org/linux/man-pages/man3/openpty.3.html)).
+/// (see [`openpty`](https://man7.org/linux/man-pages/man3/openpty.3.html)).
 ///
 /// If `winsize` is not `None`, the window size of the slave will be set to
 /// the values in `winsize`. If `termios` is not `None`, the pseudoterminal's
@@ -218,16 +231,16 @@ pub fn unlockpt(fd: &PtyMaster) -> Result<()> {
 pub fn openpty<'a, 'b, T: Into<Option<&'a Winsize>>, U: Into<Option<&'b Termios>>>(winsize: T, termios: U) -> Result<OpenptyResult> {
     use std::ptr;
 
-    let mut slave: libc::c_int = unsafe { mem::uninitialized() };
-    let mut master: libc::c_int = unsafe { mem::uninitialized() };
+    let mut slave = mem::MaybeUninit::<libc::c_int>::uninit();
+    let mut master = mem::MaybeUninit::<libc::c_int>::uninit();
     let ret = {
         match (termios.into(), winsize.into()) {
             (Some(termios), Some(winsize)) => {
                 let inner_termios = termios.get_libc_termios();
                 unsafe {
                     libc::openpty(
-                        &mut master,
-                        &mut slave,
+                        master.as_mut_ptr(),
+                        slave.as_mut_ptr(),
                         ptr::null_mut(),
                         &*inner_termios as *const libc::termios as *mut _,
                         winsize as *const Winsize as *mut _,
@@ -237,8 +250,8 @@ pub fn openpty<'a, 'b, T: Into<Option<&'a Winsize>>, U: Into<Option<&'b Termios>
             (None, Some(winsize)) => {
                 unsafe {
                     libc::openpty(
-                        &mut master,
-                        &mut slave,
+                        master.as_mut_ptr(),
+                        slave.as_mut_ptr(),
                         ptr::null_mut(),
                         ptr::null_mut(),
                         winsize as *const Winsize as *mut _,
@@ -249,8 +262,8 @@ pub fn openpty<'a, 'b, T: Into<Option<&'a Winsize>>, U: Into<Option<&'b Termios>
                 let inner_termios = termios.get_libc_termios();
                 unsafe {
                     libc::openpty(
-                        &mut master,
-                        &mut slave,
+                        master.as_mut_ptr(),
+                        slave.as_mut_ptr(),
                         ptr::null_mut(),
                         &*inner_termios as *const libc::termios as *mut _,
                         ptr::null_mut(),
@@ -260,8 +273,8 @@ pub fn openpty<'a, 'b, T: Into<Option<&'a Winsize>>, U: Into<Option<&'b Termios>
             (None, None) => {
                 unsafe {
                     libc::openpty(
-                        &mut master,
-                        &mut slave,
+                        master.as_mut_ptr(),
+                        slave.as_mut_ptr(),
                         ptr::null_mut(),
                         ptr::null_mut(),
                         ptr::null_mut(),
@@ -273,28 +286,40 @@ pub fn openpty<'a, 'b, T: Into<Option<&'a Winsize>>, U: Into<Option<&'b Termios>
 
     Errno::result(ret)?;
 
-    Ok(OpenptyResult {
-        master: master,
-        slave: slave,
-    })
+    unsafe {
+        Ok(OpenptyResult {
+            master: master.assume_init(),
+            slave: slave.assume_init(),
+        })
+    }
 }
 
 /// Create a new pseudoterminal, returning the master file descriptor and forked pid.
 /// in `ForkptyResult`
-/// (see [`forkpty`](http://man7.org/linux/man-pages/man3/forkpty.3.html)).
+/// (see [`forkpty`](https://man7.org/linux/man-pages/man3/forkpty.3.html)).
 ///
 /// If `winsize` is not `None`, the window size of the slave will be set to
 /// the values in `winsize`. If `termios` is not `None`, the pseudoterminal's
 /// terminal settings of the slave will be set to the values in `termios`.
-pub fn forkpty<'a, 'b, T: Into<Option<&'a Winsize>>, U: Into<Option<&'b Termios>>>(
+///
+/// # Safety
+///
+/// In a multithreaded program, only [async-signal-safe] functions like `pause`
+/// and `_exit` may be called by the child (the parent isn't restricted). Note
+/// that memory allocation may **not** be async-signal-safe and thus must be
+/// prevented.
+///
+/// Those functions are only a small subset of your operating system's API, so
+/// special care must be taken to only invoke code you can control and audit.
+///
+/// [async-signal-safe]: https://man7.org/linux/man-pages/man7/signal-safety.7.html
+pub unsafe fn forkpty<'a, 'b, T: Into<Option<&'a Winsize>>, U: Into<Option<&'b Termios>>>(
     winsize: T,
     termios: U,
 ) -> Result<ForkptyResult> {
     use std::ptr;
-    use unistd::Pid;
-    use unistd::ForkResult::*;
 
-    let mut master: libc::c_int = unsafe { mem::uninitialized() };
+    let mut master = mem::MaybeUninit::<libc::c_int>::uninit();
 
     let term = match termios.into() {
         Some(termios) => {
@@ -309,18 +334,15 @@ pub fn forkpty<'a, 'b, T: Into<Option<&'a Winsize>>, U: Into<Option<&'b Termios>
         .map(|ws| ws as *const Winsize as *mut _)
         .unwrap_or(ptr::null_mut());
 
-    let res = unsafe {
-        libc::forkpty(&mut master, ptr::null_mut(), term, win)
-    };
+    let res = libc::forkpty(master.as_mut_ptr(), ptr::null_mut(), term, win);
 
     let fork_result = Errno::result(res).map(|res| match res {
-        0 => Child,
-        res => Parent { child: Pid::from_raw(res) },
+        0 => ForkResult::Child,
+        res => ForkResult::Parent { child: Pid::from_raw(res) },
     })?;
 
     Ok(ForkptyResult {
-        master: master,
-        fork_result: fork_result,
+        master: master.assume_init(),
+        fork_result,
     })
 }
-
diff --git a/third_party/rust/nix/src/sched.rs b/third_party/rust/nix/src/sched.rs
index 67188c57eef7d..c2dd7b84ce777 100644
--- a/third_party/rust/nix/src/sched.rs
+++ b/third_party/rust/nix/src/sched.rs
@@ -1,51 +1,96 @@
-use libc;
-use {Errno, Result};
+//! Execution scheduling
+//!
+//! See Also
+//! [sched.h](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sched.h.html)
+use crate::{Errno, Result};
 
 #[cfg(any(target_os = "android", target_os = "linux"))]
 pub use self::sched_linux_like::*;
 
 #[cfg(any(target_os = "android", target_os = "linux"))]
 mod sched_linux_like {
-    use errno::Errno;
+    use crate::errno::Errno;
     use libc::{self, c_int, c_void};
     use std::mem;
     use std::option::Option;
     use std::os::unix::io::RawFd;
-    use unistd::Pid;
-    use {Error, Result};
+    use crate::unistd::Pid;
+    use crate::Result;
 
     // For some functions taking with a parameter of type CloneFlags,
     // only a subset of these flags have an effect.
     libc_bitflags! {
+        /// Options for use with [`clone`]
         pub struct CloneFlags: c_int {
+            /// The calling process and the child process run in the same
+            /// memory space.
             CLONE_VM;
+            /// The caller and the child process share the same  filesystem
+            /// information.
             CLONE_FS;
+            /// The calling process and the child process share the same file
+            /// descriptor table.
             CLONE_FILES;
+            /// The calling process and the child process share the same table
+            /// of signal handlers.
             CLONE_SIGHAND;
+            /// If the calling process is being traced, then trace the child
+            /// also.
             CLONE_PTRACE;
+            /// The execution of the calling process is suspended until the
+            /// child releases its virtual memory resources via a call to
+            /// execve(2) or _exit(2) (as with vfork(2)).
             CLONE_VFORK;
+            /// The parent of the new child  (as returned by getppid(2))
+            /// will be the same as that of the calling process.
             CLONE_PARENT;
+            /// The child is placed in the same thread group as the calling
+            /// process.
             CLONE_THREAD;
+            /// The cloned child is started in a new mount namespace.
             CLONE_NEWNS;
+            /// The child and the calling process share a single list of System
+            /// V semaphore adjustment values
             CLONE_SYSVSEM;
-            CLONE_SETTLS;
-            CLONE_PARENT_SETTID;
-            CLONE_CHILD_CLEARTID;
+            // Not supported by Nix due to lack of varargs support in Rust FFI
+            // CLONE_SETTLS;
+            // Not supported by Nix due to lack of varargs support in Rust FFI
+            // CLONE_PARENT_SETTID;
+            // Not supported by Nix due to lack of varargs support in Rust FFI
+            // CLONE_CHILD_CLEARTID;
+            /// Unused since Linux 2.6.2
+            #[deprecated(since = "0.23.0", note = "Deprecated by Linux 2.6.2")]
             CLONE_DETACHED;
+            /// A tracing process cannot force `CLONE_PTRACE` on this child
+            /// process.
             CLONE_UNTRACED;
-            CLONE_CHILD_SETTID;
+            // Not supported by Nix due to lack of varargs support in Rust FFI
+            // CLONE_CHILD_SETTID;
+            /// Create the process in a new cgroup namespace.
             CLONE_NEWCGROUP;
+            /// Create the process in a new UTS namespace.
             CLONE_NEWUTS;
+            /// Create the process in a new IPC namespace.
             CLONE_NEWIPC;
+            /// Create the process in a new user namespace.
             CLONE_NEWUSER;
+            /// Create the process in a new PID namespace.
             CLONE_NEWPID;
+            /// Create the process in a new network namespace.
             CLONE_NEWNET;
+            /// The new process shares an I/O context with the calling process.
             CLONE_IO;
         }
     }
 
+    /// Type for the function executed by [`clone`].
     pub type CloneCb<'a> = Box<dyn FnMut() -> isize + 'a>;
 
+    /// CpuSet represent a bit-mask of CPUs.
+    /// CpuSets are used by sched_setaffinity and
+    /// sched_getaffinity for example.
+    ///
+    /// This is a wrapper around `libc::cpu_set_t`.
     #[repr(C)]
     #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
     pub struct CpuSet {
@@ -53,37 +98,78 @@ mod sched_linux_like {
     }
 
     impl CpuSet {
+        /// Create a new and empty CpuSet.
         pub fn new() -> CpuSet {
             CpuSet {
                 cpu_set: unsafe { mem::zeroed() },
             }
         }
 
+        /// Test to see if a CPU is in the CpuSet.
+        /// `field` is the CPU id to test
         pub fn is_set(&self, field: usize) -> Result<bool> {
-            if field >= 8 * mem::size_of::<libc::cpu_set_t>() {
-                Err(Error::Sys(Errno::EINVAL))
+            if field >= CpuSet::count() {
+                Err(Errno::EINVAL)
             } else {
                 Ok(unsafe { libc::CPU_ISSET(field, &self.cpu_set) })
             }
         }
 
+        /// Add a CPU to CpuSet.
+        /// `field` is the CPU id to add
         pub fn set(&mut self, field: usize) -> Result<()> {
-            if field >= 8 * mem::size_of::<libc::cpu_set_t>() {
-                Err(Error::Sys(Errno::EINVAL))
+            if field >= CpuSet::count() {
+                Err(Errno::EINVAL)
             } else {
-                Ok(unsafe { libc::CPU_SET(field, &mut self.cpu_set) })
+                unsafe { libc::CPU_SET(field, &mut self.cpu_set); }
+                Ok(())
             }
         }
 
+        /// Remove a CPU from CpuSet.
+        /// `field` is the CPU id to remove
         pub fn unset(&mut self, field: usize) -> Result<()> {
-            if field >= 8 * mem::size_of::<libc::cpu_set_t>() {
-                Err(Error::Sys(Errno::EINVAL))
+            if field >= CpuSet::count() {
+                Err(Errno::EINVAL)
             } else {
-                Ok(unsafe { libc::CPU_CLR(field, &mut self.cpu_set) })
+                unsafe { libc::CPU_CLR(field, &mut self.cpu_set);}
+                Ok(())
             }
         }
+
+        /// Return the maximum number of CPU in CpuSet
+        pub const fn count() -> usize {
+            8 * mem::size_of::<libc::cpu_set_t>()
+        }
     }
 
+    impl Default for CpuSet {
+        fn default() -> Self {
+            Self::new()
+        }
+    }
+
+    /// `sched_setaffinity` set a thread's CPU affinity mask
+    /// ([`sched_setaffinity(2)`](https://man7.org/linux/man-pages/man2/sched_setaffinity.2.html))
+    ///
+    /// `pid` is the thread ID to update.
+    /// If pid is zero, then the calling thread is updated.
+    ///
+    /// The `cpuset` argument specifies the set of CPUs on which the thread
+    /// will be eligible to run.
+    ///
+    /// # Example
+    ///
+    /// Binding the current thread to CPU 0 can be done as follows:
+    ///
+    /// ```rust,no_run
+    /// use nix::sched::{CpuSet, sched_setaffinity};
+    /// use nix::unistd::Pid;
+    ///
+    /// let mut cpu_set = CpuSet::new();
+    /// cpu_set.set(0);
+    /// sched_setaffinity(Pid::from_raw(0), &cpu_set);
+    /// ```
     pub fn sched_setaffinity(pid: Pid, cpuset: &CpuSet) -> Result<()> {
         let res = unsafe {
             libc::sched_setaffinity(
@@ -96,6 +182,49 @@ mod sched_linux_like {
         Errno::result(res).map(drop)
     }
 
+    /// `sched_getaffinity` get a thread's CPU affinity mask
+    /// ([`sched_getaffinity(2)`](https://man7.org/linux/man-pages/man2/sched_getaffinity.2.html))
+    ///
+    /// `pid` is the thread ID to check.
+    /// If pid is zero, then the calling thread is checked.
+    ///
+    /// Returned `cpuset` is the set of CPUs on which the thread
+    /// is eligible to run.
+    ///
+    /// # Example
+    ///
+    /// Checking if the current thread can run on CPU 0 can be done as follows:
+    ///
+    /// ```rust,no_run
+    /// use nix::sched::sched_getaffinity;
+    /// use nix::unistd::Pid;
+    ///
+    /// let cpu_set = sched_getaffinity(Pid::from_raw(0)).unwrap();
+    /// if cpu_set.is_set(0).unwrap() {
+    ///     println!("Current thread can run on CPU 0");
+    /// }
+    /// ```
+    pub fn sched_getaffinity(pid: Pid) -> Result<CpuSet> {
+        let mut cpuset = CpuSet::new();
+        let res = unsafe {
+            libc::sched_getaffinity(
+                pid.into(),
+                mem::size_of::<CpuSet>() as libc::size_t,
+                &mut cpuset.cpu_set,
+            )
+        };
+
+        Errno::result(res).and(Ok(cpuset))
+    }
+
+    /// `clone` create a child process
+    /// ([`clone(2)`](https://man7.org/linux/man-pages/man2/clone.2.html))
+    ///
+    /// `stack` is a reference to an array which will hold the stack of the new
+    /// process.  Unlike when calling `clone(2)` from C, the provided stack
+    /// address need not be the highest address of the region.  Nix will take
+    /// care of that requirement.  The user only needs to provide a reference to
+    /// a normally allocated buffer.
     pub fn clone(
         mut cb: CloneCb,
         stack: &mut [u8],
@@ -109,8 +238,8 @@ mod sched_linux_like {
 
         let res = unsafe {
             let combined = flags.bits() | signal.unwrap_or(0);
-            let ptr = stack.as_mut_ptr().offset(stack.len() as isize);
-            let ptr_aligned = ptr.offset((ptr as usize % 16) as isize * -1);
+            let ptr = stack.as_mut_ptr().add(stack.len());
+            let ptr_aligned = ptr.sub(ptr as usize % 16);
             libc::clone(
                 mem::transmute(
                     callback as extern "C" fn(*mut Box<dyn FnMut() -> isize>) -> i32,
@@ -124,12 +253,18 @@ mod sched_linux_like {
         Errno::result(res).map(Pid::from_raw)
     }
 
+    /// disassociate parts of the process execution context
+    ///
+    /// See also [unshare(2)](https://man7.org/linux/man-pages/man2/unshare.2.html)
     pub fn unshare(flags: CloneFlags) -> Result<()> {
         let res = unsafe { libc::unshare(flags.bits()) };
 
         Errno::result(res).map(drop)
     }
 
+    /// reassociate thread with a namespace
+    ///
+    /// See also [setns(2)](https://man7.org/linux/man-pages/man2/setns.2.html)
     pub fn setns(fd: RawFd, nstype: CloneFlags) -> Result<()> {
         let res = unsafe { libc::setns(fd, nstype.bits()) };
 
@@ -139,7 +274,7 @@ mod sched_linux_like {
 
 /// Explicitly yield the processor to other threads.
 ///
-/// [Further reading](http://pubs.opengroup.org/onlinepubs/9699919799/functions/sched_yield.html)
+/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/sched_yield.html)
 pub fn sched_yield() -> Result<()> {
     let res = unsafe { libc::sched_yield() };
 
diff --git a/third_party/rust/nix/src/sys/aio.rs b/third_party/rust/nix/src/sys/aio.rs
index 9258a0657cc8a..e64a2a823a643 100644
--- a/third_party/rust/nix/src/sys/aio.rs
+++ b/third_party/rust/nix/src/sys/aio.rs
@@ -21,25 +21,25 @@
 //! [`aio_cancel_all`](fn.aio_cancel_all.html), though the operating system may
 //! not support this for all filesystems and devices.
 
-use {Error, Result};
-use errno::Errno;
+use crate::Result;
+use crate::errno::Errno;
 use std::os::unix::io::RawFd;
 use libc::{c_void, off_t, size_t};
-use libc;
-use std::borrow::{Borrow, BorrowMut};
 use std::fmt;
 use std::fmt::Debug;
 use std::marker::PhantomData;
 use std::mem;
+use std::pin::Pin;
 use std::ptr::{null, null_mut};
-use sys::signal::*;
+use crate::sys::signal::*;
 use std::thread;
-use sys::time::TimeSpec;
+use crate::sys::time::TimeSpec;
 
 libc_enum! {
     /// Mode for `AioCb::fsync`.  Controls whether only data or both data and
     /// metadata are synced.
     #[repr(i32)]
+    #[non_exhaustive]
     pub enum AioFsyncMode {
         /// do it like `fsync`
         O_SYNC,
@@ -58,9 +58,13 @@ libc_enum! {
     /// given `aiocb` should be used for a read operation, a write operation, or
     /// ignored.  Has no effect for any other aio functions.
     #[repr(i32)]
+    #[non_exhaustive]
     pub enum LioOpcode {
+        /// No operation
         LIO_NOP,
+        /// Write data as if by a call to [`AioCb::write`]
         LIO_WRITE,
+        /// Write data as if by a call to [`AioCb::read`]
         LIO_READ,
     }
 }
@@ -91,120 +95,31 @@ pub enum AioCancelStat {
     AioAllDone = libc::AIO_ALLDONE,
 }
 
-/// Owns (uniquely or shared) a memory buffer to keep it from `Drop`ing while
-/// the kernel has a pointer to it.
-pub enum Buffer<'a> {
-    /// No buffer to own.
-    ///
-    /// Used for operations like `aio_fsync` that have no data, or for unsafe
-    /// operations that work with raw pointers.
-    None,
-    /// Keeps a reference to a slice
-    Phantom(PhantomData<&'a mut [u8]>),
-    /// Generic thing that keeps a buffer from dropping
-    BoxedSlice(Box<dyn Borrow<[u8]>>),
-    /// Generic thing that keeps a mutable buffer from dropping
-    BoxedMutSlice(Box<dyn BorrowMut<[u8]>>),
-}
+/// Newtype that adds Send and Sync to libc::aiocb, which contains raw pointers
+#[repr(transparent)]
+struct LibcAiocb(libc::aiocb);
 
-impl<'a> Debug for Buffer<'a> {
-    // Note: someday it may be possible to Derive Debug for a trait object, but
-    // not today.
-    // https://github.com/rust-lang/rust/issues/1563
-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
-        match *self {
-            Buffer::None => write!(fmt, "None"),
-            Buffer::Phantom(p) => p.fmt(fmt),
-            Buffer::BoxedSlice(ref bs) => {
-                let borrowed : &dyn Borrow<[u8]> = bs.borrow();
-                write!(fmt, "BoxedSlice({:?})",
-                    borrowed as *const dyn Borrow<[u8]>)
-            },
-            Buffer::BoxedMutSlice(ref bms) => {
-                let borrowed : &dyn BorrowMut<[u8]> = bms.borrow();
-                write!(fmt, "BoxedMutSlice({:?})",
-                    borrowed as *const dyn BorrowMut<[u8]>)
-            }
-        }
-    }
-}
+unsafe impl Send for LibcAiocb {}
+unsafe impl Sync for LibcAiocb {}
 
 /// AIO Control Block.
 ///
 /// The basic structure used by all aio functions.  Each `AioCb` represents one
 /// I/O request.
 pub struct AioCb<'a> {
-    aiocb: libc::aiocb,
+    aiocb: LibcAiocb,
     /// Tracks whether the buffer pointed to by `libc::aiocb.aio_buf` is mutable
     mutable: bool,
     /// Could this `AioCb` potentially have any in-kernel state?
     in_progress: bool,
-    /// Optionally keeps a reference to the data.
-    ///
-    /// Used to keep buffers from `Drop`'ing, and may be returned once the
-    /// `AioCb` is completed by [`buffer`](#method.buffer).
-    buffer: Buffer<'a>
+    _buffer: std::marker::PhantomData<&'a [u8]>,
+    _pin: std::marker::PhantomPinned
 }
 
 impl<'a> AioCb<'a> {
-    /// Remove the inner `Buffer` and return it
-    ///
-    /// It is an error to call this method while the `AioCb` is still in
-    /// progress.
-    pub fn buffer(&mut self) -> Buffer<'a> {
-        assert!(!self.in_progress);
-        let mut x = Buffer::None;
-        mem::swap(&mut self.buffer, &mut x);
-        x
-    }
-
-    /// Remove the inner boxed slice, if any, and return it.
-    ///
-    /// The returned value will be the argument that was passed to
-    /// `from_boxed_slice` when this `AioCb` was created.
-    ///
-    /// It is an error to call this method while the `AioCb` is still in
-    /// progress.
-    pub fn boxed_slice(&mut self) -> Option<Box<dyn Borrow<[u8]>>> {
-        assert!(!self.in_progress, "Can't remove the buffer from an AioCb that's still in-progress.  Did you forget to call aio_return?");
-        if let Buffer::BoxedSlice(_) = self.buffer {
-            let mut oldbuffer = Buffer::None;
-            mem::swap(&mut self.buffer, &mut oldbuffer);
-            if let Buffer::BoxedSlice(inner) = oldbuffer {
-                Some(inner)
-            } else {
-                unreachable!();
-            }
-        } else {
-            None
-        }
-    }
-
-    /// Remove the inner boxed mutable slice, if any, and return it.
-    ///
-    /// The returned value will be the argument that was passed to
-    /// `from_boxed_mut_slice` when this `AioCb` was created.
-    ///
-    /// It is an error to call this method while the `AioCb` is still in
-    /// progress.
-    pub fn boxed_mut_slice(&mut self) -> Option<Box<dyn BorrowMut<[u8]>>> {
-        assert!(!self.in_progress, "Can't remove the buffer from an AioCb that's still in-progress.  Did you forget to call aio_return?");
-        if let Buffer::BoxedMutSlice(_) = self.buffer {
-            let mut oldbuffer = Buffer::None;
-            mem::swap(&mut self.buffer, &mut oldbuffer);
-            if let Buffer::BoxedMutSlice(inner) = oldbuffer {
-                Some(inner)
-            } else {
-                unreachable!();
-            }
-        } else {
-            None
-        }
-    }
-
     /// Returns the underlying file descriptor associated with the `AioCb`
     pub fn fd(&self) -> RawFd {
-        self.aiocb.aio_fildes
+        self.aiocb.0.aio_fildes
     }
 
     /// Constructs a new `AioCb` with no associated buffer.
@@ -226,8 +141,6 @@ impl<'a> AioCb<'a> {
     /// [`fsync`](#method.fsync) operation.
     ///
     /// ```
-    /// # extern crate tempfile;
-    /// # extern crate nix;
     /// # use nix::errno::Errno;
     /// # use nix::Error;
     /// # use nix::sys::aio::*;
@@ -235,28 +148,48 @@ impl<'a> AioCb<'a> {
     /// # use std::{thread, time};
     /// # use std::os::unix::io::AsRawFd;
     /// # use tempfile::tempfile;
-    /// # fn main() {
     /// let f = tempfile().unwrap();
     /// let mut aiocb = AioCb::from_fd( f.as_raw_fd(), 0, SigevNone);
     /// aiocb.fsync(AioFsyncMode::O_SYNC).expect("aio_fsync failed early");
-    /// while (aiocb.error() == Err(Error::from(Errno::EINPROGRESS))) {
+    /// while (aiocb.error() == Err(Errno::EINPROGRESS)) {
     ///     thread::sleep(time::Duration::from_millis(10));
     /// }
     /// aiocb.aio_return().expect("aio_fsync failed late");
-    /// # }
     /// ```
     pub fn from_fd(fd: RawFd, prio: libc::c_int,
-                    sigev_notify: SigevNotify) -> AioCb<'a> {
+                    sigev_notify: SigevNotify) -> Pin<Box<AioCb<'a>>> {
         let mut a = AioCb::common_init(fd, prio, sigev_notify);
-        a.aio_offset = 0;
-        a.aio_nbytes = 0;
-        a.aio_buf = null_mut();
+        a.0.aio_offset = 0;
+        a.0.aio_nbytes = 0;
+        a.0.aio_buf = null_mut();
 
-        AioCb {
+        Box::pin(AioCb {
             aiocb: a,
             mutable: false,
             in_progress: false,
-            buffer: Buffer::None
+            _buffer: PhantomData,
+            _pin: std::marker::PhantomPinned
+        })
+    }
+
+    // Private helper
+    #[cfg(not(any(target_os = "ios", target_os = "macos")))]
+    fn from_mut_slice_unpinned(fd: RawFd, offs: off_t, buf: &'a mut [u8],
+                          prio: libc::c_int, sigev_notify: SigevNotify,
+                          opcode: LioOpcode) -> AioCb<'a>
+    {
+        let mut a = AioCb::common_init(fd, prio, sigev_notify);
+        a.0.aio_offset = offs;
+        a.0.aio_nbytes = buf.len() as size_t;
+        a.0.aio_buf = buf.as_ptr() as *mut c_void;
+        a.0.aio_lio_opcode = opcode as libc::c_int;
+
+        AioCb {
+            aiocb: a,
+            mutable: true,
+            in_progress: false,
+            _buffer: PhantomData,
+            _pin: std::marker::PhantomPinned
         }
     }
 
@@ -265,8 +198,7 @@ impl<'a> AioCb<'a> {
     /// The resulting `AioCb` will be suitable for both read and write
     /// operations, but only if the borrow checker can guarantee that the slice
     /// will outlive the `AioCb`.  That will usually be the case if the `AioCb`
-    /// is stack-allocated.  If the borrow checker gives you trouble, try using
-    /// [`from_boxed_mut_slice`](#method.from_boxed_mut_slice) instead.
+    /// is stack-allocated.
     ///
     /// # Parameters
     ///
@@ -287,8 +219,6 @@ impl<'a> AioCb<'a> {
     /// Create an `AioCb` from a mutable slice and read into it.
     ///
     /// ```
-    /// # extern crate tempfile;
-    /// # extern crate nix;
     /// # use nix::errno::Errno;
     /// # use nix::Error;
     /// # use nix::sys::aio::*;
@@ -297,7 +227,6 @@ impl<'a> AioCb<'a> {
     /// # use std::io::Write;
     /// # use std::os::unix::io::AsRawFd;
     /// # use tempfile::tempfile;
-    /// # fn main() {
     /// const INITIAL: &[u8] = b"abcdef123456";
     /// const LEN: usize = 4;
     /// let mut rbuf = vec![0; LEN];
@@ -311,230 +240,29 @@ impl<'a> AioCb<'a> {
     ///         SigevNotify::SigevNone,
     ///         LioOpcode::LIO_NOP);
     ///     aiocb.read().unwrap();
-    ///     while (aiocb.error() == Err(Error::from(Errno::EINPROGRESS))) {
+    ///     while (aiocb.error() == Err(Errno::EINPROGRESS)) {
     ///         thread::sleep(time::Duration::from_millis(10));
     ///     }
     ///     assert_eq!(aiocb.aio_return().unwrap() as usize, LEN);
     /// }
     /// assert_eq!(rbuf, b"cdef");
-    /// # }
     /// ```
     pub fn from_mut_slice(fd: RawFd, offs: off_t, buf: &'a mut [u8],
                           prio: libc::c_int, sigev_notify: SigevNotify,
-                          opcode: LioOpcode) -> AioCb<'a> {
-        let mut a = AioCb::common_init(fd, prio, sigev_notify);
-        a.aio_offset = offs;
-        a.aio_nbytes = buf.len() as size_t;
-        a.aio_buf = buf.as_ptr() as *mut c_void;
-        a.aio_lio_opcode = opcode as libc::c_int;
-
-        AioCb {
-            aiocb: a,
-            mutable: true,
-            in_progress: false,
-            buffer: Buffer::Phantom(PhantomData),
-        }
-    }
-
-    /// The safest and most flexible way to create an `AioCb`.
-    ///
-    /// Unlike [`from_slice`], this method returns a structure suitable for
-    /// placement on the heap.  It may be used for write operations, but not
-    /// read operations.  Unlike `from_ptr`, this method will ensure that the
-    /// buffer doesn't `drop` while the kernel is still processing it.  Any
-    /// object that can be borrowed as a boxed slice will work.
-    ///
-    /// # Parameters
-    ///
-    /// * `fd`:           File descriptor.  Required for all aio functions.
-    /// * `offs`:         File offset
-    /// * `buf`:          A boxed slice-like object
-    /// * `prio`:         If POSIX Prioritized IO is supported, then the
-    ///                   operation will be prioritized at the process's
-    ///                   priority level minus `prio`
-    /// * `sigev_notify`: Determines how you will be notified of event
-    ///                   completion.
-    /// * `opcode`:       This field is only used for `lio_listio`.  It
-    ///                   determines which operation to use for this individual
-    ///                   aiocb
-    ///
-    /// # Examples
-    ///
-    /// Create an `AioCb` from a Vector and use it for writing
-    ///
-    /// ```
-    /// # extern crate tempfile;
-    /// # extern crate nix;
-    /// # use nix::errno::Errno;
-    /// # use nix::Error;
-    /// # use nix::sys::aio::*;
-    /// # use nix::sys::signal::SigevNotify;
-    /// # use std::{thread, time};
-    /// # use std::io::Write;
-    /// # use std::os::unix::io::AsRawFd;
-    /// # use tempfile::tempfile;
-    /// # fn main() {
-    /// let wbuf = Box::new(Vec::from("CDEF"));
-    /// let expected_len = wbuf.len();
-    /// let mut f = tempfile().unwrap();
-    /// let mut aiocb = AioCb::from_boxed_slice( f.as_raw_fd(),
-    ///     2,   //offset
-    ///     wbuf,
-    ///     0,   //priority
-    ///     SigevNotify::SigevNone,
-    ///     LioOpcode::LIO_NOP);
-    /// aiocb.write().unwrap();
-    /// while (aiocb.error() == Err(Error::from(Errno::EINPROGRESS))) {
-    ///     thread::sleep(time::Duration::from_millis(10));
-    /// }
-    /// assert_eq!(aiocb.aio_return().unwrap() as usize, expected_len);
-    /// # }
-    /// ```
-    ///
-    /// Create an `AioCb` from a `Bytes` object
-    ///
-    /// ```
-    /// # extern crate bytes;
-    /// # extern crate tempfile;
-    /// # extern crate nix;
-    /// # use bytes::Bytes;
-    /// # use nix::sys::aio::*;
-    /// # use nix::sys::signal::SigevNotify;
-    /// # use std::os::unix::io::AsRawFd;
-    /// # use tempfile::tempfile;
-    /// # fn main() {
-    /// let wbuf = Box::new(Bytes::from(&b"CDEF"[..]));
-    /// let mut f = tempfile().unwrap();
-    /// let mut aiocb = AioCb::from_boxed_slice( f.as_raw_fd(),
-    ///     2,   //offset
-    ///     wbuf,
-    ///     0,   //priority
-    ///     SigevNotify::SigevNone,
-    ///     LioOpcode::LIO_NOP);
-    /// # }
-    /// ```
-    ///
-    /// If a library needs to work with buffers that aren't `Box`ed, it can
-    /// create a `Box`ed container for use with this method.  Here's an example
-    /// using an un`Box`ed `Bytes` object.
-    ///
-    /// ```
-    /// # extern crate bytes;
-    /// # extern crate tempfile;
-    /// # extern crate nix;
-    /// # use bytes::Bytes;
-    /// # use nix::sys::aio::*;
-    /// # use nix::sys::signal::SigevNotify;
-    /// # use std::borrow::Borrow;
-    /// # use std::os::unix::io::AsRawFd;
-    /// # use tempfile::tempfile;
-    /// struct BytesContainer(Bytes);
-    /// impl Borrow<[u8]> for BytesContainer {
-    ///     fn borrow(&self) -> &[u8] {
-    ///         self.0.as_ref()
-    ///     }
-    /// }
-    /// fn main() {
-    ///     let wbuf = Bytes::from(&b"CDEF"[..]);
-    ///     let boxed_wbuf = Box::new(BytesContainer(wbuf));
-    ///     let mut f = tempfile().unwrap();
-    ///     let mut aiocb = AioCb::from_boxed_slice( f.as_raw_fd(),
-    ///         2,   //offset
-    ///         boxed_wbuf,
-    ///         0,   //priority
-    ///         SigevNotify::SigevNone,
-    ///         LioOpcode::LIO_NOP);
-    /// }
-    /// ```
-    ///
-    /// [`from_slice`]: #method.from_slice
-    pub fn from_boxed_slice(fd: RawFd, offs: off_t, buf: Box<dyn Borrow<[u8]>>,
-                      prio: libc::c_int, sigev_notify: SigevNotify,
-                      opcode: LioOpcode) -> AioCb<'a> {
-        let mut a = AioCb::common_init(fd, prio, sigev_notify);
-        {
-            let borrowed : &dyn Borrow<[u8]> = buf.borrow();
-            let slice : &[u8] = borrowed.borrow();
-            a.aio_nbytes = slice.len() as size_t;
-            a.aio_buf = slice.as_ptr() as *mut c_void;
-        }
-        a.aio_offset = offs;
-        a.aio_lio_opcode = opcode as libc::c_int;
-
-        AioCb {
-            aiocb: a,
-            mutable: false,
-            in_progress: false,
-            buffer: Buffer::BoxedSlice(buf),
-        }
-    }
-
-    /// The safest and most flexible way to create an `AioCb` for reading.
-    ///
-    /// Like [`from_boxed_slice`], but the slice is a mutable one.  More
-    /// flexible than [`from_mut_slice`], because a wide range of objects can be
-    /// used.
-    ///
-    /// # Examples
-    ///
-    /// Create an `AioCb` from a Vector and use it for reading
-    ///
-    /// ```
-    /// # extern crate tempfile;
-    /// # extern crate nix;
-    /// # use nix::errno::Errno;
-    /// # use nix::Error;
-    /// # use nix::sys::aio::*;
-    /// # use nix::sys::signal::SigevNotify;
-    /// # use std::{thread, time};
-    /// # use std::io::Write;
-    /// # use std::os::unix::io::AsRawFd;
-    /// # use tempfile::tempfile;
-    /// # fn main() {
-    /// const INITIAL: &[u8] = b"abcdef123456";
-    /// const LEN: usize = 4;
-    /// let rbuf = Box::new(vec![0; LEN]);
-    /// let mut f = tempfile().unwrap();
-    /// f.write_all(INITIAL).unwrap();
-    /// let mut aiocb = AioCb::from_boxed_mut_slice( f.as_raw_fd(),
-    ///     2,   //offset
-    ///     rbuf,
-    ///     0,   //priority
-    ///     SigevNotify::SigevNone,
-    ///     LioOpcode::LIO_NOP);
-    /// aiocb.read().unwrap();
-    /// while (aiocb.error() == Err(Error::from(Errno::EINPROGRESS))) {
-    ///     thread::sleep(time::Duration::from_millis(10));
-    /// }
-    /// assert_eq!(aiocb.aio_return().unwrap() as usize, LEN);
-    /// let mut buffer = aiocb.boxed_mut_slice().unwrap();
-    /// const EXPECT: &[u8] = b"cdef";
-    /// assert_eq!(buffer.borrow_mut(), EXPECT);
-    /// # }
-    /// ```
-    ///
-    /// [`from_boxed_slice`]: #method.from_boxed_slice
-    /// [`from_mut_slice`]: #method.from_mut_slice
-    pub fn from_boxed_mut_slice(fd: RawFd, offs: off_t,
-                                mut buf: Box<dyn BorrowMut<[u8]>>,
-                                prio: libc::c_int, sigev_notify: SigevNotify,
-                                opcode: LioOpcode) -> AioCb<'a> {
+                          opcode: LioOpcode) -> Pin<Box<AioCb<'a>>> {
         let mut a = AioCb::common_init(fd, prio, sigev_notify);
-        {
-            let borrowed : &mut dyn BorrowMut<[u8]> = buf.borrow_mut();
-            let slice : &mut [u8] = borrowed.borrow_mut();
-            a.aio_nbytes = slice.len() as size_t;
-            a.aio_buf = slice.as_mut_ptr() as *mut c_void;
-        }
-        a.aio_offset = offs;
-        a.aio_lio_opcode = opcode as libc::c_int;
+        a.0.aio_offset = offs;
+        a.0.aio_nbytes = buf.len() as size_t;
+        a.0.aio_buf = buf.as_ptr() as *mut c_void;
+        a.0.aio_lio_opcode = opcode as libc::c_int;
 
-        AioCb {
+        Box::pin(AioCb {
             aiocb: a,
             mutable: true,
             in_progress: false,
-            buffer: Buffer::BoxedMutSlice(buf),
-        }
+            _buffer: PhantomData,
+            _pin: std::marker::PhantomPinned
+        })
     }
 
     /// Constructs a new `AioCb` from a mutable raw pointer
@@ -542,8 +270,7 @@ impl<'a> AioCb<'a> {
     /// Unlike `from_mut_slice`, this method returns a structure suitable for
     /// placement on the heap.  It may be used for both reads and writes.  Due
     /// to its unsafety, this method is not recommended.  It is most useful when
-    /// heap allocation is required but for some reason the data cannot be
-    /// wrapped in a `struct` that implements `BorrowMut<[u8]>`
+    /// heap allocation is required.
     ///
     /// # Parameters
     ///
@@ -567,28 +294,27 @@ impl<'a> AioCb<'a> {
     pub unsafe fn from_mut_ptr(fd: RawFd, offs: off_t,
                            buf: *mut c_void, len: usize,
                            prio: libc::c_int, sigev_notify: SigevNotify,
-                           opcode: LioOpcode) -> AioCb<'a> {
+                           opcode: LioOpcode) -> Pin<Box<AioCb<'a>>> {
         let mut a = AioCb::common_init(fd, prio, sigev_notify);
-        a.aio_offset = offs;
-        a.aio_nbytes = len;
-        a.aio_buf = buf;
-        a.aio_lio_opcode = opcode as libc::c_int;
+        a.0.aio_offset = offs;
+        a.0.aio_nbytes = len;
+        a.0.aio_buf = buf;
+        a.0.aio_lio_opcode = opcode as libc::c_int;
 
-        AioCb {
+        Box::pin(AioCb {
             aiocb: a,
             mutable: true,
             in_progress: false,
-            buffer: Buffer::None
-        }
+            _buffer: PhantomData,
+            _pin: std::marker::PhantomPinned,
+        })
     }
 
     /// Constructs a new `AioCb` from a raw pointer.
     ///
     /// Unlike `from_slice`, this method returns a structure suitable for
     /// placement on the heap.  Due to its unsafety, this method is not
-    /// recommended.  It is most useful when heap allocation is required but for
-    /// some reason the data cannot be wrapped in a `struct` that implements
-    /// `Borrow<[u8]>`
+    /// recommended.  It is most useful when heap allocation is required.
     ///
     /// # Parameters
     ///
@@ -612,24 +338,49 @@ impl<'a> AioCb<'a> {
     pub unsafe fn from_ptr(fd: RawFd, offs: off_t,
                            buf: *const c_void, len: usize,
                            prio: libc::c_int, sigev_notify: SigevNotify,
-                           opcode: LioOpcode) -> AioCb<'a> {
+                           opcode: LioOpcode) -> Pin<Box<AioCb<'a>>> {
         let mut a = AioCb::common_init(fd, prio, sigev_notify);
-        a.aio_offset = offs;
-        a.aio_nbytes = len;
+        a.0.aio_offset = offs;
+        a.0.aio_nbytes = len;
         // casting a const ptr to a mutable ptr here is ok, because we set the
         // AioCb's mutable field to false
-        a.aio_buf = buf as *mut c_void;
-        a.aio_lio_opcode = opcode as libc::c_int;
+        a.0.aio_buf = buf as *mut c_void;
+        a.0.aio_lio_opcode = opcode as libc::c_int;
+
+        Box::pin(AioCb {
+            aiocb: a,
+            mutable: false,
+            in_progress: false,
+            _buffer: PhantomData,
+            _pin: std::marker::PhantomPinned
+        })
+    }
+
+    // Private helper
+    fn from_slice_unpinned(fd: RawFd, offs: off_t, buf: &'a [u8],
+                           prio: libc::c_int, sigev_notify: SigevNotify,
+                           opcode: LioOpcode) -> AioCb
+    {
+        let mut a = AioCb::common_init(fd, prio, sigev_notify);
+        a.0.aio_offset = offs;
+        a.0.aio_nbytes = buf.len() as size_t;
+        // casting an immutable buffer to a mutable pointer looks unsafe,
+        // but technically its only unsafe to dereference it, not to create
+        // it.
+        a.0.aio_buf = buf.as_ptr() as *mut c_void;
+        assert!(opcode != LioOpcode::LIO_READ, "Can't read into an immutable buffer");
+        a.0.aio_lio_opcode = opcode as libc::c_int;
 
         AioCb {
             aiocb: a,
             mutable: false,
             in_progress: false,
-            buffer: Buffer::None
+            _buffer: PhantomData,
+            _pin: std::marker::PhantomPinned
         }
     }
 
-    /// Like `from_mut_slice`, but works on constant slices rather than
+    /// Like [`AioCb::from_mut_slice`], but works on constant slices rather than
     /// mutable slices.
     ///
     /// An `AioCb` created this way cannot be used with `read`, and its
@@ -642,8 +393,6 @@ impl<'a> AioCb<'a> {
     /// Construct an `AioCb` from a slice and use it for writing.
     ///
     /// ```
-    /// # extern crate tempfile;
-    /// # extern crate nix;
     /// # use nix::errno::Errno;
     /// # use nix::Error;
     /// # use nix::sys::aio::*;
@@ -651,7 +400,6 @@ impl<'a> AioCb<'a> {
     /// # use std::{thread, time};
     /// # use std::os::unix::io::AsRawFd;
     /// # use tempfile::tempfile;
-    /// # fn main() {
     /// const WBUF: &[u8] = b"abcdef123456";
     /// let mut f = tempfile().unwrap();
     /// let mut aiocb = AioCb::from_slice( f.as_raw_fd(),
@@ -661,11 +409,10 @@ impl<'a> AioCb<'a> {
     ///     SigevNotify::SigevNone,
     ///     LioOpcode::LIO_NOP);
     /// aiocb.write().unwrap();
-    /// while (aiocb.error() == Err(Error::from(Errno::EINPROGRESS))) {
+    /// while (aiocb.error() == Err(Errno::EINPROGRESS)) {
     ///     thread::sleep(time::Duration::from_millis(10));
     /// }
     /// assert_eq!(aiocb.aio_return().unwrap() as usize, WBUF.len());
-    /// # }
     /// ```
     // Note: another solution to the problem of writing const buffers would be
     // to genericize AioCb for both &mut [u8] and &[u8] buffers.  AioCb::read
@@ -674,27 +421,14 @@ impl<'a> AioCb<'a> {
     // AioCb, and they must all be of the same type.
     pub fn from_slice(fd: RawFd, offs: off_t, buf: &'a [u8],
                       prio: libc::c_int, sigev_notify: SigevNotify,
-                      opcode: LioOpcode) -> AioCb {
-        let mut a = AioCb::common_init(fd, prio, sigev_notify);
-        a.aio_offset = offs;
-        a.aio_nbytes = buf.len() as size_t;
-        // casting an immutable buffer to a mutable pointer looks unsafe,
-        // but technically its only unsafe to dereference it, not to create
-        // it.
-        a.aio_buf = buf.as_ptr() as *mut c_void;
-        assert!(opcode != LioOpcode::LIO_READ, "Can't read into an immutable buffer");
-        a.aio_lio_opcode = opcode as libc::c_int;
-
-        AioCb {
-            aiocb: a,
-            mutable: false,
-            in_progress: false,
-            buffer: Buffer::None,
-        }
+                      opcode: LioOpcode) -> Pin<Box<AioCb>>
+    {
+        Box::pin(AioCb::from_slice_unpinned(fd, offs, buf, prio, sigev_notify,
+                                            opcode))
     }
 
     fn common_init(fd: RawFd, prio: libc::c_int,
-                   sigev_notify: SigevNotify) -> libc::aiocb {
+                   sigev_notify: SigevNotify) -> LibcAiocb {
         // Use mem::zeroed instead of explicitly zeroing each field, because the
         // number and name of reserved fields is OS-dependent.  On some OSes,
         // some reserved fields are used the kernel for state, and must be
@@ -703,12 +437,18 @@ impl<'a> AioCb<'a> {
         a.aio_fildes = fd;
         a.aio_reqprio = prio;
         a.aio_sigevent = SigEvent::new(sigev_notify).sigevent();
-        a
+        LibcAiocb(a)
     }
 
     /// Update the notification settings for an existing `aiocb`
-    pub fn set_sigev_notify(&mut self, sigev_notify: SigevNotify) {
-        self.aiocb.aio_sigevent = SigEvent::new(sigev_notify).sigevent();
+    pub fn set_sigev_notify(self: &mut Pin<Box<Self>>,
+                            sigev_notify: SigevNotify)
+    {
+        // Safe because we don't move any of the data
+        let selfp = unsafe {
+            self.as_mut().get_unchecked_mut()
+        };
+        selfp.aiocb.0.aio_sigevent = SigEvent::new(sigev_notify).sigevent();
     }
 
     /// Cancels an outstanding AIO request.
@@ -726,8 +466,6 @@ impl<'a> AioCb<'a> {
     /// result.
     ///
     /// ```
-    /// # extern crate tempfile;
-    /// # extern crate nix;
     /// # use nix::errno::Errno;
     /// # use nix::Error;
     /// # use nix::sys::aio::*;
@@ -736,7 +474,6 @@ impl<'a> AioCb<'a> {
     /// # use std::io::Write;
     /// # use std::os::unix::io::AsRawFd;
     /// # use tempfile::tempfile;
-    /// # fn main() {
     /// let wbuf = b"CDEF";
     /// let mut f = tempfile().unwrap();
     /// let mut aiocb = AioCb::from_slice( f.as_raw_fd(),
@@ -748,28 +485,43 @@ impl<'a> AioCb<'a> {
     /// aiocb.write().unwrap();
     /// let cs = aiocb.cancel().unwrap();
     /// if cs == AioCancelStat::AioNotCanceled {
-    ///     while (aiocb.error() == Err(Error::from(Errno::EINPROGRESS))) {
+    ///     while (aiocb.error() == Err(Errno::EINPROGRESS)) {
     ///         thread::sleep(time::Duration::from_millis(10));
     ///     }
     /// }
     /// // Must call `aio_return`, but ignore the result
     /// let _ = aiocb.aio_return();
-    /// # }
     /// ```
     ///
     /// # References
     ///
-    /// [aio_cancel](http://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_cancel.html)
-    pub fn cancel(&mut self) -> Result<AioCancelStat> {
-        match unsafe { libc::aio_cancel(self.aiocb.aio_fildes, &mut self.aiocb) } {
+    /// [aio_cancel](https://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_cancel.html)
+    pub fn cancel(self: &mut Pin<Box<Self>>) -> Result<AioCancelStat> {
+        let r = unsafe {
+            let selfp = self.as_mut().get_unchecked_mut();
+            libc::aio_cancel(selfp.aiocb.0.aio_fildes, &mut selfp.aiocb.0)
+        };
+        match r {
             libc::AIO_CANCELED => Ok(AioCancelStat::AioCanceled),
             libc::AIO_NOTCANCELED => Ok(AioCancelStat::AioNotCanceled),
             libc::AIO_ALLDONE => Ok(AioCancelStat::AioAllDone),
-            -1 => Err(Error::last()),
+            -1 => Err(Errno::last()),
             _ => panic!("unknown aio_cancel return value")
         }
     }
 
+    fn error_unpinned(&mut self) -> Result<()> {
+        let r = unsafe {
+            libc::aio_error(&mut self.aiocb.0 as *mut libc::aiocb)
+        };
+        match r {
+            0 => Ok(()),
+            num if num > 0 => Err(Errno::from_i32(num)),
+            -1 => Err(Errno::last()),
+            num => panic!("unknown aio_error return value {:?}", num)
+        }
+    }
+
     /// Retrieve error status of an asynchronous operation.
     ///
     /// If the request has not yet completed, returns `EINPROGRESS`.  Otherwise,
@@ -781,8 +533,6 @@ impl<'a> AioCb<'a> {
     /// is an alternative to `aio_suspend`, used by most of the other examples.
     ///
     /// ```
-    /// # extern crate tempfile;
-    /// # extern crate nix;
     /// # use nix::errno::Errno;
     /// # use nix::Error;
     /// # use nix::sys::aio::*;
@@ -790,7 +540,6 @@ impl<'a> AioCb<'a> {
     /// # use std::{thread, time};
     /// # use std::os::unix::io::AsRawFd;
     /// # use tempfile::tempfile;
-    /// # fn main() {
     /// const WBUF: &[u8] = b"abcdef123456";
     /// let mut f = tempfile().unwrap();
     /// let mut aiocb = AioCb::from_slice( f.as_raw_fd(),
@@ -800,37 +549,39 @@ impl<'a> AioCb<'a> {
     ///     SigevNotify::SigevNone,
     ///     LioOpcode::LIO_NOP);
     /// aiocb.write().unwrap();
-    /// while (aiocb.error() == Err(Error::from(Errno::EINPROGRESS))) {
+    /// while (aiocb.error() == Err(Errno::EINPROGRESS)) {
     ///     thread::sleep(time::Duration::from_millis(10));
     /// }
     /// assert_eq!(aiocb.aio_return().unwrap() as usize, WBUF.len());
-    /// # }
     /// ```
     ///
     /// # References
     ///
-    /// [aio_error](http://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_error.html)
-    pub fn error(&mut self) -> Result<()> {
-        match unsafe { libc::aio_error(&mut self.aiocb as *mut libc::aiocb) } {
-            0 => Ok(()),
-            num if num > 0 => Err(Error::from_errno(Errno::from_i32(num))),
-            -1 => Err(Error::last()),
-            num => panic!("unknown aio_error return value {:?}", num)
-        }
+    /// [aio_error](https://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_error.html)
+    pub fn error(self: &mut Pin<Box<Self>>) -> Result<()> {
+        // Safe because error_unpinned doesn't move the data
+        let selfp = unsafe {
+            self.as_mut().get_unchecked_mut()
+        };
+        selfp.error_unpinned()
     }
 
     /// An asynchronous version of `fsync(2)`.
     ///
     /// # References
     ///
-    /// [aio_fsync](http://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_fsync.html)
-    pub fn fsync(&mut self, mode: AioFsyncMode) -> Result<()> {
-        let p: *mut libc::aiocb = &mut self.aiocb;
-        Errno::result(unsafe {
+    /// [aio_fsync](https://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_fsync.html)
+    pub fn fsync(self: &mut Pin<Box<Self>>, mode: AioFsyncMode) -> Result<()> {
+        // Safe because we don't move the libc::aiocb
+        unsafe {
+            let selfp = self.as_mut().get_unchecked_mut();
+            Errno::result({
+                let p: *mut libc::aiocb = &mut selfp.aiocb.0;
                 libc::aio_fsync(mode as libc::c_int, p)
-        }).map(|_| {
-            self.in_progress = true;
-        })
+            }).map(|_| {
+                selfp.in_progress = true;
+            })
+        }
     }
 
     /// Returns the `aiocb`'s `LioOpcode` field
@@ -838,7 +589,7 @@ impl<'a> AioCb<'a> {
     /// If the value cannot be represented as an `LioOpcode`, returns `None`
     /// instead.
     pub fn lio_opcode(&self) -> Option<LioOpcode> {
-        match self.aiocb.aio_lio_opcode {
+        match self.aiocb.0.aio_lio_opcode {
             libc::LIO_READ => Some(LioOpcode::LIO_READ),
             libc::LIO_WRITE => Some(LioOpcode::LIO_WRITE),
             libc::LIO_NOP => Some(LioOpcode::LIO_NOP),
@@ -852,37 +603,49 @@ impl<'a> AioCb<'a> {
     /// number of bytes actually read or written by a completed operation, use
     /// `aio_return` instead.
     pub fn nbytes(&self) -> usize {
-        self.aiocb.aio_nbytes
+        self.aiocb.0.aio_nbytes
     }
 
     /// Returns the file offset stored in the `AioCb`
     pub fn offset(&self) -> off_t {
-        self.aiocb.aio_offset
+        self.aiocb.0.aio_offset
     }
 
     /// Returns the priority of the `AioCb`
     pub fn priority(&self) -> libc::c_int {
-        self.aiocb.aio_reqprio
+        self.aiocb.0.aio_reqprio
     }
 
     /// Asynchronously reads from a file descriptor into a buffer
     ///
     /// # References
     ///
-    /// [aio_read](http://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_read.html)
-    pub fn read(&mut self) -> Result<()> {
+    /// [aio_read](https://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_read.html)
+    pub fn read(self: &mut Pin<Box<Self>>) -> Result<()> {
         assert!(self.mutable, "Can't read into an immutable buffer");
-        let p: *mut libc::aiocb = &mut self.aiocb;
-        Errno::result(unsafe {
-            libc::aio_read(p)
+        // Safe because we don't move anything
+        let selfp = unsafe {
+            self.as_mut().get_unchecked_mut()
+        };
+        Errno::result({
+            let p: *mut libc::aiocb = &mut selfp.aiocb.0;
+            unsafe { libc::aio_read(p) }
         }).map(|_| {
-            self.in_progress = true;
+            selfp.in_progress = true;
         })
     }
 
     /// Returns the `SigEvent` stored in the `AioCb`
     pub fn sigevent(&self) -> SigEvent {
-        SigEvent::from(&self.aiocb.aio_sigevent)
+        SigEvent::from(&self.aiocb.0.aio_sigevent)
+    }
+
+    fn aio_return_unpinned(&mut self) -> Result<isize> {
+        unsafe {
+            let p: *mut libc::aiocb = &mut self.aiocb.0;
+            self.in_progress = false;
+            Errno::result(libc::aio_return(p))
+        }
     }
 
     /// Retrieve return status of an asynchronous operation.
@@ -893,28 +656,33 @@ impl<'a> AioCb<'a> {
     ///
     /// # References
     ///
-    /// [aio_return](http://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_return.html)
+    /// [aio_return](https://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_return.html)
     // Note: this should be just `return`, but that's a reserved word
-    pub fn aio_return(&mut self) -> Result<isize> {
-        let p: *mut libc::aiocb = &mut self.aiocb;
-        self.in_progress = false;
-        Errno::result(unsafe { libc::aio_return(p) })
+    pub fn aio_return(self: &mut Pin<Box<Self>>) -> Result<isize> {
+        // Safe because aio_return_unpinned does not move the data
+        let selfp = unsafe {
+            self.as_mut().get_unchecked_mut()
+        };
+        selfp.aio_return_unpinned()
     }
 
     /// Asynchronously writes from a buffer to a file descriptor
     ///
     /// # References
     ///
-    /// [aio_write](http://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_write.html)
-    pub fn write(&mut self) -> Result<()> {
-        let p: *mut libc::aiocb = &mut self.aiocb;
-        Errno::result(unsafe {
-            libc::aio_write(p)
+    /// [aio_write](https://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_write.html)
+    pub fn write(self: &mut Pin<Box<Self>>) -> Result<()> {
+        // Safe because we don't move anything
+        let selfp = unsafe {
+            self.as_mut().get_unchecked_mut()
+        };
+        Errno::result({
+            let p: *mut libc::aiocb = &mut selfp.aiocb.0;
+            unsafe{ libc::aio_write(p) }
         }).map(|_| {
-            self.in_progress = true;
+            selfp.in_progress = true;
         })
     }
-
 }
 
 /// Cancels outstanding AIO requests for a given file descriptor.
@@ -925,8 +693,6 @@ impl<'a> AioCb<'a> {
 /// descriptor.
 ///
 /// ```
-/// # extern crate tempfile;
-/// # extern crate nix;
 /// # use nix::errno::Errno;
 /// # use nix::Error;
 /// # use nix::sys::aio::*;
@@ -935,7 +701,6 @@ impl<'a> AioCb<'a> {
 /// # use std::io::Write;
 /// # use std::os::unix::io::AsRawFd;
 /// # use tempfile::tempfile;
-/// # fn main() {
 /// let wbuf = b"CDEF";
 /// let mut f = tempfile().unwrap();
 /// let mut aiocb = AioCb::from_slice( f.as_raw_fd(),
@@ -947,24 +712,23 @@ impl<'a> AioCb<'a> {
 /// aiocb.write().unwrap();
 /// let cs = aio_cancel_all(f.as_raw_fd()).unwrap();
 /// if cs == AioCancelStat::AioNotCanceled {
-///     while (aiocb.error() == Err(Error::from(Errno::EINPROGRESS))) {
+///     while (aiocb.error() == Err(Errno::EINPROGRESS)) {
 ///         thread::sleep(time::Duration::from_millis(10));
 ///     }
 /// }
 /// // Must call `aio_return`, but ignore the result
 /// let _ = aiocb.aio_return();
-/// # }
 /// ```
 ///
 /// # References
 ///
-/// [`aio_cancel`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_cancel.html)
+/// [`aio_cancel`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_cancel.html)
 pub fn aio_cancel_all(fd: RawFd) -> Result<AioCancelStat> {
     match unsafe { libc::aio_cancel(fd, null_mut()) } {
         libc::AIO_CANCELED => Ok(AioCancelStat::AioCanceled),
         libc::AIO_NOTCANCELED => Ok(AioCancelStat::AioNotCanceled),
         libc::AIO_ALLDONE => Ok(AioCancelStat::AioAllDone),
-        -1 => Err(Error::last()),
+        -1 => Err(Errno::last()),
         _ => panic!("unknown aio_cancel return value")
     }
 }
@@ -978,18 +742,11 @@ pub fn aio_cancel_all(fd: RawFd) -> Result<AioCancelStat> {
 ///
 /// Use `aio_suspend` to block until an aio operation completes.
 ///
-// Disable doctest due to a known bug in FreeBSD's 32-bit emulation.  The fix
-// will be included in release 11.2.
-// FIXME reenable the doc test when the CI machine gets upgraded to that release.
-// https://svnweb.freebsd.org/base?view=revision&revision=325018
-/// ```no_run
-/// # extern crate tempfile;
-/// # extern crate nix;
+/// ```
 /// # use nix::sys::aio::*;
 /// # use nix::sys::signal::SigevNotify;
 /// # use std::os::unix::io::AsRawFd;
 /// # use tempfile::tempfile;
-/// # fn main() {
 /// const WBUF: &[u8] = b"abcdef123456";
 /// let mut f = tempfile().unwrap();
 /// let mut aiocb = AioCb::from_slice( f.as_raw_fd(),
@@ -999,15 +756,14 @@ pub fn aio_cancel_all(fd: RawFd) -> Result<AioCancelStat> {
 ///     SigevNotify::SigevNone,
 ///     LioOpcode::LIO_NOP);
 /// aiocb.write().unwrap();
-/// aio_suspend(&[&aiocb], None).expect("aio_suspend failed");
+/// aio_suspend(&[aiocb.as_ref()], None).expect("aio_suspend failed");
 /// assert_eq!(aiocb.aio_return().unwrap() as usize, WBUF.len());
-/// # }
 /// ```
 /// # References
 ///
-/// [`aio_suspend`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_suspend.html)
-pub fn aio_suspend(list: &[&AioCb], timeout: Option<TimeSpec>) -> Result<()> {
-    let plist = list as *const [&AioCb] as *const [*const libc::aiocb];
+/// [`aio_suspend`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_suspend.html)
+pub fn aio_suspend(list: &[Pin<&AioCb>], timeout: Option<TimeSpec>) -> Result<()> {
+    let plist = list as *const [Pin<&AioCb>] as *const [*const libc::aiocb];
     let p = plist as *const *const libc::aiocb;
     let timep = match timeout {
         None    => null::<libc::timespec>(),
@@ -1021,7 +777,7 @@ pub fn aio_suspend(list: &[&AioCb], timeout: Option<TimeSpec>) -> Result<()> {
 impl<'a> Debug for AioCb<'a> {
     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
         fmt.debug_struct("AioCb")
-            .field("aiocb", &self.aiocb)
+            .field("aiocb", &self.aiocb.0)
             .field("mutable", &self.mutable)
             .field("in_progress", &self.in_progress)
             .finish()
@@ -1047,7 +803,9 @@ pub struct LioCb<'a> {
     ///
     /// [`AioCb`]: struct.AioCb.html
     /// [`listio`]: #method.listio
-    pub aiocbs: Vec<AioCb<'a>>,
+    // Their locations in memory must be fixed once they are passed to the
+    // kernel.  So this field must be non-public so the user can't swap.
+    aiocbs: Box<[AioCb<'a>]>,
 
     /// The actual list passed to `libc::lio_listio`.
     ///
@@ -1061,15 +819,24 @@ pub struct LioCb<'a> {
     results: Vec<Option<Result<isize>>>
 }
 
+/// LioCb can't automatically impl Send and Sync just because of the raw
+/// pointers in list.  But that's stupid.  There's no reason that raw pointers
+/// should automatically be non-Send
+#[cfg(not(any(target_os = "ios", target_os = "macos")))]
+unsafe impl<'a> Send for LioCb<'a> {}
+#[cfg(not(any(target_os = "ios", target_os = "macos")))]
+unsafe impl<'a> Sync for LioCb<'a> {}
+
 #[cfg(not(any(target_os = "ios", target_os = "macos")))]
 impl<'a> LioCb<'a> {
-    /// Initialize an empty `LioCb`
-    pub fn with_capacity(capacity: usize) -> LioCb<'a> {
-        LioCb {
-            aiocbs: Vec::with_capacity(capacity),
-            list: Vec::with_capacity(capacity),
-            results: Vec::with_capacity(capacity)
-        }
+    /// Are no [`AioCb`]s contained?
+    pub fn is_empty(&self) -> bool {
+        self.aiocbs.is_empty()
+    }
+
+    /// Return the number of individual [`AioCb`]s contained.
+    pub fn len(&self) -> usize {
+        self.aiocbs.len()
     }
 
     /// Submits multiple asynchronous I/O requests with a single system call.
@@ -1091,31 +858,29 @@ impl<'a> LioCb<'a> {
     /// [`AioCb::error`] to poll.
     ///
     /// ```
-    /// # extern crate tempfile;
-    /// # extern crate nix;
     /// # use nix::sys::aio::*;
     /// # use nix::sys::signal::SigevNotify;
     /// # use std::os::unix::io::AsRawFd;
     /// # use tempfile::tempfile;
-    /// # fn main() {
     /// const WBUF: &[u8] = b"abcdef123456";
     /// let mut f = tempfile().unwrap();
-    /// let mut liocb = LioCb::with_capacity(1);
-    /// liocb.aiocbs.push(AioCb::from_slice( f.as_raw_fd(),
-    ///     2,   //offset
-    ///     WBUF,
-    ///     0,   //priority
-    ///     SigevNotify::SigevNone,
-    ///     LioOpcode::LIO_WRITE));
+    /// let mut liocb = LioCbBuilder::with_capacity(1)
+    ///     .emplace_slice(
+    ///         f.as_raw_fd(),
+    ///         2,   //offset
+    ///         WBUF,
+    ///         0,   //priority
+    ///         SigevNotify::SigevNone,
+    ///         LioOpcode::LIO_WRITE
+    ///     ).finish();
     /// liocb.listio(LioMode::LIO_WAIT,
     ///              SigevNotify::SigevNone).unwrap();
     /// assert_eq!(liocb.aio_return(0).unwrap() as usize, WBUF.len());
-    /// # }
     /// ```
     ///
     /// # References
     ///
-    /// [`lio_listio`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lio_listio.html)
+    /// [`lio_listio`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/lio_listio.html)
     ///
     /// [`aio_suspend`]: fn.aio_suspend.html
     /// [`AioCb::error`]: struct.AioCb.html#method.error
@@ -1124,7 +889,7 @@ impl<'a> LioCb<'a> {
         let sigev = SigEvent::new(sigev_notify);
         let sigevp = &mut sigev.sigevent() as *mut libc::sigevent;
         self.list.clear();
-        for a in &mut self.aiocbs {
+        for a in &mut self.aiocbs.iter_mut() {
             a.in_progress = true;
             self.list.push(a as *mut AioCb<'a>
                              as *mut libc::aiocb);
@@ -1148,8 +913,6 @@ impl<'a> LioCb<'a> {
     ///
     /// # Examples
     /// ```no_run
-    /// # extern crate tempfile;
-    /// # extern crate nix;
     /// # use nix::Error;
     /// # use nix::errno::Errno;
     /// # use nix::sys::aio::*;
@@ -1157,31 +920,31 @@ impl<'a> LioCb<'a> {
     /// # use std::os::unix::io::AsRawFd;
     /// # use std::{thread, time};
     /// # use tempfile::tempfile;
-    /// # fn main() {
     /// const WBUF: &[u8] = b"abcdef123456";
     /// let mut f = tempfile().unwrap();
-    /// let mut liocb = LioCb::with_capacity(1);
-    /// liocb.aiocbs.push(AioCb::from_slice( f.as_raw_fd(),
-    ///     2,   //offset
-    ///     WBUF,
-    ///     0,   //priority
-    ///     SigevNotify::SigevNone,
-    ///     LioOpcode::LIO_WRITE));
+    /// let mut liocb = LioCbBuilder::with_capacity(1)
+    ///     .emplace_slice(
+    ///         f.as_raw_fd(),
+    ///         2,   //offset
+    ///         WBUF,
+    ///         0,   //priority
+    ///         SigevNotify::SigevNone,
+    ///         LioOpcode::LIO_WRITE
+    ///     ).finish();
     /// let mut err = liocb.listio(LioMode::LIO_WAIT, SigevNotify::SigevNone);
-    /// while err == Err(Error::Sys(Errno::EIO)) ||
-    ///       err == Err(Error::Sys(Errno::EAGAIN)) {
+    /// while err == Err(Errno::EIO) ||
+    ///       err == Err(Errno::EAGAIN) {
     ///     thread::sleep(time::Duration::from_millis(10));
     ///     err = liocb.listio_resubmit(LioMode::LIO_WAIT, SigevNotify::SigevNone);
     /// }
     /// assert_eq!(liocb.aio_return(0).unwrap() as usize, WBUF.len());
-    /// # }
     /// ```
     ///
     /// # References
     ///
-    /// [`lio_listio`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lio_listio.html)
+    /// [`lio_listio`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/lio_listio.html)
     ///
-    /// [`lio_listio`]: http://pubs.opengroup.org/onlinepubs/9699919799/functions/lio_listio.html
+    /// [`lio_listio`]: https://pubs.opengroup.org/onlinepubs/9699919799/functions/lio_listio.html
     /// [`LioCb::aio_return`]: struct.LioCb.html#method.aio_return
     // Note: the addresses of any EINPROGRESS or EOK aiocbs _must_ not be
     // changed by this method, because the kernel relies on their addresses
@@ -1203,19 +966,18 @@ impl<'a> LioCb<'a> {
                 // Already collected final status for this operation
                 continue;
             }
-            match a.error() {
+            match a.error_unpinned() {
                 Ok(()) => {
                     // aiocb is complete; collect its status and don't resubmit
-                    self.results[i] = Some(a.aio_return());
+                    self.results[i] = Some(a.aio_return_unpinned());
                 },
-                Err(Error::Sys(Errno::EAGAIN)) => {
+                Err(Errno::EAGAIN) => {
                     self.list.push(a as *mut AioCb<'a> as *mut libc::aiocb);
                 },
-                Err(Error::Sys(Errno::EINPROGRESS)) => {
+                Err(Errno::EINPROGRESS) => {
                     // aiocb is was successfully queued; no need to do anything
-                    ()
                 },
-                Err(Error::Sys(Errno::EINVAL)) => panic!(
+                Err(Errno::EINVAL) => panic!(
                     "AioCb was never submitted, or already finalized"),
                 _ => unreachable!()
             }
@@ -1236,7 +998,7 @@ impl<'a> LioCb<'a> {
     /// [`LioCb::listio_resubmit`]: #method.listio_resubmit
     pub fn aio_return(&mut self, i: usize) -> Result<isize> {
         if i >= self.results.len() || self.results[i].is_none() {
-            self.aiocbs[i].aio_return()
+            self.aiocbs[i].aio_return_unpinned()
         } else {
             self.results[i].unwrap()
         }
@@ -1252,7 +1014,7 @@ impl<'a> LioCb<'a> {
     /// [`LioCb::listio_resubmit`]: #method.listio_resubmit
     pub fn error(&mut self, i: usize) -> Result<()> {
         if i >= self.results.len() || self.results[i].is_none() {
-            self.aiocbs[i].error()
+            self.aiocbs[i].error_unpinned()
         } else {
             Ok(())
         }
@@ -1268,13 +1030,93 @@ impl<'a> Debug for LioCb<'a> {
     }
 }
 
+/// Used to construct `LioCb`
+// This must be a separate class from LioCb due to pinning constraints.  LioCb
+// must use a boxed slice of AioCbs so they will have stable storage, but
+// LioCbBuilder must use a Vec to make construction possible when the final size
+// is unknown.
 #[cfg(not(any(target_os = "ios", target_os = "macos")))]
-impl<'a> From<Vec<AioCb<'a>>> for LioCb<'a> {
-    fn from(src: Vec<AioCb<'a>>) -> LioCb<'a> {
+#[derive(Debug)]
+pub struct LioCbBuilder<'a> {
+    /// A collection of [`AioCb`]s.
+    ///
+    /// [`AioCb`]: struct.AioCb.html
+    pub aiocbs: Vec<AioCb<'a>>,
+}
+
+#[cfg(not(any(target_os = "ios", target_os = "macos")))]
+impl<'a> LioCbBuilder<'a> {
+    /// Initialize an empty `LioCb`
+    pub fn with_capacity(capacity: usize) -> LioCbBuilder<'a> {
+        LioCbBuilder {
+            aiocbs: Vec::with_capacity(capacity),
+        }
+    }
+
+    /// Add a new operation on an immutable slice to the [`LioCb`] under
+    /// construction.
+    ///
+    /// Arguments are the same as for [`AioCb::from_slice`]
+    ///
+    /// [`LioCb`]: struct.LioCb.html
+    /// [`AioCb::from_slice`]: struct.AioCb.html#method.from_slice
+    pub fn emplace_slice(mut self, fd: RawFd, offs: off_t, buf: &'a [u8],
+                         prio: libc::c_int, sigev_notify: SigevNotify,
+                         opcode: LioOpcode) -> Self
+    {
+        self.aiocbs.push(AioCb::from_slice_unpinned(fd, offs, buf, prio,
+                                                    sigev_notify, opcode));
+        self
+    }
+
+    /// Add a new operation on a mutable slice to the [`LioCb`] under
+    /// construction.
+    ///
+    /// Arguments are the same as for [`AioCb::from_mut_slice`]
+    ///
+    /// [`LioCb`]: struct.LioCb.html
+    /// [`AioCb::from_mut_slice`]: struct.AioCb.html#method.from_mut_slice
+    pub fn emplace_mut_slice(mut self, fd: RawFd, offs: off_t,
+                             buf: &'a mut [u8], prio: libc::c_int,
+                             sigev_notify: SigevNotify, opcode: LioOpcode)
+        -> Self
+    {
+        self.aiocbs.push(AioCb::from_mut_slice_unpinned(fd, offs, buf, prio,
+                                                        sigev_notify, opcode));
+        self
+    }
+
+    /// Finalize this [`LioCb`].
+    ///
+    /// Afterwards it will be possible to issue the operations with
+    /// [`LioCb::listio`].  Conversely, it will no longer be possible to add new
+    /// operations with [`LioCbBuilder::emplace_slice`] or
+    /// [`LioCbBuilder::emplace_mut_slice`].
+    ///
+    /// [`LioCb::listio`]: struct.LioCb.html#method.listio
+    /// [`LioCb::from_mut_slice`]: struct.LioCb.html#method.from_mut_slice
+    /// [`LioCb::from_slice`]: struct.LioCb.html#method.from_slice
+    pub fn finish(self) -> LioCb<'a> {
+        let len = self.aiocbs.len();
         LioCb {
-            list: Vec::with_capacity(src.capacity()),
-            results: Vec::with_capacity(src.capacity()),
-            aiocbs: src,
+            aiocbs: self.aiocbs.into(),
+            list: Vec::with_capacity(len),
+            results: Vec::with_capacity(len)
         }
     }
 }
+
+#[cfg(not(any(target_os = "ios", target_os = "macos")))]
+#[cfg(test)]
+mod t {
+    use super::*;
+
+    // It's important that `LioCb` be `UnPin`.  The tokio-file crate relies on
+    // it.
+    #[test]
+    fn liocb_is_unpin() {
+        use assert_impl::assert_impl;
+
+        assert_impl!(Unpin: LioCb);
+    }
+}
diff --git a/third_party/rust/nix/src/sys/epoll.rs b/third_party/rust/nix/src/sys/epoll.rs
index fef6f4e3ec92c..6bc2a2539eb2b 100644
--- a/third_party/rust/nix/src/sys/epoll.rs
+++ b/third_party/rust/nix/src/sys/epoll.rs
@@ -1,10 +1,9 @@
-use Result;
-use errno::Errno;
+use crate::Result;
+use crate::errno::Errno;
 use libc::{self, c_int};
 use std::os::unix::io::RawFd;
 use std::ptr;
 use std::mem;
-use ::Error;
 
 libc_bitflags!(
     pub struct EpollFlags: c_int {
@@ -30,6 +29,7 @@ libc_bitflags!(
 
 #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
 #[repr(i32)]
+#[non_exhaustive]
 pub enum EpollOp {
     EpollCtlAdd = libc::EPOLL_CTL_ADD,
     EpollCtlDel = libc::EPOLL_CTL_DEL,
@@ -43,7 +43,7 @@ libc_bitflags!{
 }
 
 #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
-#[repr(C)]
+#[repr(transparent)]
 pub struct EpollEvent {
     event: libc::epoll_event,
 }
@@ -86,7 +86,7 @@ pub fn epoll_ctl<'a, T>(epfd: RawFd, op: EpollOp, fd: RawFd, event: T) -> Result
 {
     let mut event: Option<&mut EpollEvent> = event.into();
     if event.is_none() && op != EpollOp::EpollCtlDel {
-        Err(Error::Sys(Errno::EINVAL))
+        Err(Errno::EINVAL)
     } else {
         let res = unsafe {
             if let Some(ref mut event) = event {
diff --git a/third_party/rust/nix/src/sys/event.rs b/third_party/rust/nix/src/sys/event.rs
index 8cd7372f88188..c648f5ebc8617 100644
--- a/third_party/rust/nix/src/sys/event.rs
+++ b/third_party/rust/nix/src/sys/event.rs
@@ -1,15 +1,14 @@
 /* TOOD: Implement for other kqueue based systems
  */
 
-use {Errno, Result};
+use crate::{Errno, Result};
 #[cfg(not(target_os = "netbsd"))]
 use libc::{timespec, time_t, c_int, c_long, intptr_t, uintptr_t};
 #[cfg(target_os = "netbsd")]
 use libc::{timespec, time_t, c_long, intptr_t, uintptr_t, size_t};
-use libc;
+use std::convert::TryInto;
 use std::os::unix::io::RawFd;
 use std::ptr;
-use std::mem;
 
 // Redefine kevent in terms of programmer-friendly enums and bitfields.
 #[repr(C)]
@@ -28,7 +27,7 @@ type type_of_data = intptr_t;
 #[cfg(any(target_os = "netbsd"))]
 type type_of_udata = intptr_t;
 #[cfg(any(target_os = "netbsd", target_os = "openbsd"))]
-type type_of_data = libc::int64_t;
+type type_of_data = i64;
 
 #[cfg(target_os = "netbsd")]
 type type_of_event_filter = u32;
@@ -37,6 +36,7 @@ type type_of_event_filter = i16;
 libc_enum! {
     #[cfg_attr(target_os = "netbsd", repr(u32))]
     #[cfg_attr(not(target_os = "netbsd"), repr(i16))]
+    #[non_exhaustive]
     pub enum EventFilter {
         EVFILT_AIO,
         /// Returns whenever there is no remaining data in the write buffer
@@ -76,6 +76,7 @@ libc_enum! {
         EVFILT_VNODE,
         EVFILT_WRITE,
     }
+    impl TryFrom<type_of_event_filter>
 }
 
 #[cfg(any(target_os = "dragonfly", target_os = "freebsd",
@@ -90,14 +91,9 @@ libc_bitflags!{
         EV_CLEAR;
         EV_DELETE;
         EV_DISABLE;
-        // No released version of OpenBSD supports EV_DISPATCH or EV_RECEIPT.
-        // These have been commited to the -current branch though and are
-        // expected to be part of the OpenBSD 6.2 release in Nov 2017.
-        // See: https://marc.info/?l=openbsd-tech&m=149621427511219&w=2
-        // https://github.com/rust-lang/libc/pull/613
         #[cfg(any(target_os = "dragonfly", target_os = "freebsd",
                   target_os = "ios", target_os = "macos",
-                  target_os = "netbsd"))]
+                  target_os = "netbsd", target_os = "openbsd"))]
         EV_DISPATCH;
         #[cfg(target_os = "freebsd")]
         EV_DROP;
@@ -116,7 +112,7 @@ libc_bitflags!{
         EV_POLL;
         #[cfg(any(target_os = "dragonfly", target_os = "freebsd",
                   target_os = "ios", target_os = "macos",
-                  target_os = "netbsd"))]
+                  target_os = "netbsd", target_os = "openbsd"))]
         EV_RECEIPT;
         EV_SYSFLAGS;
     }
@@ -134,10 +130,6 @@ libc_bitflags!(
         NOTE_EXEC;
         NOTE_EXIT;
         #[cfg(any(target_os = "macos", target_os = "ios"))]
-        #[deprecated( since="0.14.0", note="Deprecated since OSX 10.9")]
-        #[allow(deprecated)]
-        NOTE_EXIT_REPARENTED;
-        #[cfg(any(target_os = "macos", target_os = "ios"))]
         NOTE_EXITSTATUS;
         NOTE_EXTEND;
         #[cfg(any(target_os = "macos",
@@ -183,11 +175,6 @@ libc_bitflags!(
         NOTE_OOB;
         NOTE_PCTRLMASK;
         NOTE_PDATAMASK;
-        #[cfg(any(target_os = "macos", target_os = "ios"))]
-        #[cfg(any(target_os = "macos", target_os = "ios"))]
-        #[deprecated( since="0.14.0", note="Deprecated since OSX 10.9")]
-        #[allow(deprecated)]
-        NOTE_REAP;
         NOTE_RENAME;
         NOTE_REVOKE;
         #[cfg(any(target_os = "macos", target_os = "ios", target_os = "freebsd"))]
@@ -234,7 +221,7 @@ impl KEvent {
     pub fn new(ident: uintptr_t, filter: EventFilter, flags: EventFlag,
                fflags:FilterFlag, data: intptr_t, udata: intptr_t) -> KEvent {
         KEvent { kevent: libc::kevent {
-            ident: ident,
+            ident,
             filter: filter as type_of_event_filter,
             flags: flags.bits(),
             fflags: fflags.bits(),
@@ -247,8 +234,8 @@ impl KEvent {
         self.kevent.ident
     }
 
-    pub fn filter(&self) -> EventFilter {
-        unsafe { mem::transmute(self.kevent.filter as type_of_event_filter) }
+    pub fn filter(&self) -> Result<EventFilter> {
+        self.kevent.filter.try_into()
     }
 
     pub fn flags(&self) -> EventFlag {
@@ -327,25 +314,35 @@ pub fn ev_set(ev: &mut KEvent,
 
 #[test]
 fn test_struct_kevent() {
+    use std::mem;
+
+    let udata : intptr_t = 12345;
+
+    let actual = KEvent::new(0xdead_beef,
+                             EventFilter::EVFILT_READ,
+                             EventFlag::EV_ONESHOT | EventFlag::EV_ADD,
+                             FilterFlag::NOTE_CHILD | FilterFlag::NOTE_EXIT,
+                             0x1337,
+                             udata);
+    assert_eq!(0xdead_beef, actual.ident());
+    let filter = actual.kevent.filter;
+    assert_eq!(libc::EVFILT_READ, filter);
+    assert_eq!(libc::EV_ONESHOT | libc::EV_ADD, actual.flags().bits());
+    assert_eq!(libc::NOTE_CHILD | libc::NOTE_EXIT, actual.fflags().bits());
+    assert_eq!(0x1337, actual.data() as type_of_data);
+    assert_eq!(udata as type_of_udata, actual.udata() as type_of_udata);
+    assert_eq!(mem::size_of::<libc::kevent>(), mem::size_of::<KEvent>());
+}
+
+#[test]
+fn test_kevent_filter() {
     let udata : intptr_t = 12345;
 
-    let expected = libc::kevent{ident: 0xdead_beef,
-                                filter: libc::EVFILT_READ,
-                                flags: libc::EV_ONESHOT | libc::EV_ADD,
-                                fflags: libc::NOTE_CHILD | libc::NOTE_EXIT,
-                                data: 0x1337,
-                                udata: udata as type_of_udata};
     let actual = KEvent::new(0xdead_beef,
                              EventFilter::EVFILT_READ,
                              EventFlag::EV_ONESHOT | EventFlag::EV_ADD,
                              FilterFlag::NOTE_CHILD | FilterFlag::NOTE_EXIT,
                              0x1337,
                              udata);
-    assert!(expected.ident == actual.ident());
-    assert!(expected.filter == actual.filter() as type_of_event_filter);
-    assert!(expected.flags == actual.flags().bits());
-    assert!(expected.fflags == actual.fflags().bits());
-    assert!(expected.data == actual.data() as type_of_data);
-    assert!(expected.udata == actual.udata() as type_of_udata);
-    assert!(mem::size_of::<libc::kevent>() == mem::size_of::<KEvent>());
+    assert_eq!(EventFilter::EVFILT_READ, actual.filter().unwrap());
 }
diff --git a/third_party/rust/nix/src/sys/eventfd.rs b/third_party/rust/nix/src/sys/eventfd.rs
index c5a54e46a1735..c54f952f09a9e 100644
--- a/third_party/rust/nix/src/sys/eventfd.rs
+++ b/third_party/rust/nix/src/sys/eventfd.rs
@@ -1,7 +1,6 @@
-use libc;
 use std::os::unix::io::RawFd;
-use Result;
-use errno::Errno;
+use crate::Result;
+use crate::errno::Errno;
 
 libc_bitflags! {
     pub struct EfdFlags: libc::c_int {
diff --git a/third_party/rust/nix/src/sys/inotify.rs b/third_party/rust/nix/src/sys/inotify.rs
index e6c2cf64d29dc..3f5ae22abc3e2 100644
--- a/third_party/rust/nix/src/sys/inotify.rs
+++ b/third_party/rust/nix/src/sys/inotify.rs
@@ -2,8 +2,8 @@
 //!
 //! Inotify is a Linux-only API to monitor filesystems events.
 //!
-//! For more documentation, please read [inotify(7)](http://man7.org/linux/man-pages/man7/inotify.7.html).
-//! 
+//! For more documentation, please read [inotify(7)](https://man7.org/linux/man-pages/man7/inotify.7.html).
+//!
 //! # Examples
 //!
 //! Monitor all events happening in directory "test":
@@ -23,19 +23,19 @@
 //! }
 //! ```
 
-use libc;
 use libc::{
     c_char,
     c_int,
 };
 use std::ffi::{OsString,OsStr,CStr};
 use std::os::unix::ffi::OsStrExt;
-use std::mem::size_of;
+use std::mem::{MaybeUninit, size_of};
 use std::os::unix::io::{RawFd,AsRawFd,FromRawFd};
-use unistd::read;
-use Result;
-use NixPath;
-use errno::Errno;
+use std::ptr;
+use crate::unistd::read;
+use crate::Result;
+use crate::NixPath;
+use crate::errno::Errno;
 
 libc_bitflags! {
     /// Configuration options for [`inotify_add_watch`](fn.inotify_add_watch.html).
@@ -86,7 +86,7 @@ pub struct Inotify {
 
 /// This object is returned when you create a new watch on an inotify instance.
 /// It is then returned as part of an event once triggered. It allows you to
-/// know which watch triggered which event. 
+/// know which watch triggered which event.
 #[derive(Debug, Clone, Copy, Hash, Eq, PartialEq, Ord, PartialOrd)]
 pub struct WatchDescriptor {
     wd: i32
@@ -94,18 +94,18 @@ pub struct WatchDescriptor {
 
 /// A single inotify event.
 ///
-/// For more documentation see, [inotify(7)](http://man7.org/linux/man-pages/man7/inotify.7.html).
+/// For more documentation see, [inotify(7)](https://man7.org/linux/man-pages/man7/inotify.7.html).
 #[derive(Debug)]
 pub struct InotifyEvent {
     /// Watch descriptor. This field corresponds to the watch descriptor you
     /// were issued when calling add_watch. It allows you to know which watch
-    /// this event comes from. 
+    /// this event comes from.
     pub wd: WatchDescriptor,
     /// Event mask. This field is a bitfield describing the exact event that
     /// occured.
     pub mask: AddWatchFlags,
     /// This cookie is a number that allows you to connect related events. For
-    /// now only IN_MOVED_FROM and IN_MOVED_TO can be connected. 
+    /// now only IN_MOVED_FROM and IN_MOVED_TO can be connected.
     pub cookie: u32,
     /// Filename. This field exists only if the event was triggered for a file
     /// inside the watched directory.
@@ -117,7 +117,7 @@ impl Inotify {
     ///
     /// Returns a Result containing an inotify instance.
     ///
-    /// For more information see, [inotify_init(2)](http://man7.org/linux/man-pages/man2/inotify_init.2.html).
+    /// For more information see, [inotify_init(2)](https://man7.org/linux/man-pages/man2/inotify_init.2.html).
     pub fn init(flags: InitFlags) -> Result<Inotify> {
         let res = Errno::result(unsafe {
             libc::inotify_init1(flags.bits())
@@ -126,14 +126,14 @@ impl Inotify {
         res.map(|fd| Inotify { fd })
     }
 
-    /// Adds a new watch on the target file or directory. 
+    /// Adds a new watch on the target file or directory.
     ///
-    /// Returns a watch descriptor. This is not a File Descriptor! 
+    /// Returns a watch descriptor. This is not a File Descriptor!
     ///
-    /// For more information see, [inotify_add_watch(2)](http://man7.org/linux/man-pages/man2/inotify_add_watch.2.html).
-    pub fn add_watch<P: ?Sized + NixPath>(&self,
+    /// For more information see, [inotify_add_watch(2)](https://man7.org/linux/man-pages/man2/inotify_add_watch.2.html).
+    pub fn add_watch<P: ?Sized + NixPath>(self,
                                           path: &P,
-                                          mask: AddWatchFlags) 
+                                          mask: AddWatchFlags)
                                             -> Result<WatchDescriptor>
     {
         let res = path.with_nix_path(|cstr| {
@@ -150,16 +150,16 @@ impl Inotify {
     ///
     /// Returns an EINVAL error if the watch descriptor is invalid.
     ///
-    /// For more information see, [inotify_rm_watch(2)](http://man7.org/linux/man-pages/man2/inotify_rm_watch.2.html).
+    /// For more information see, [inotify_rm_watch(2)](https://man7.org/linux/man-pages/man2/inotify_rm_watch.2.html).
     #[cfg(target_os = "linux")]
-    pub fn rm_watch(&self, wd: WatchDescriptor) -> Result<()> {
+    pub fn rm_watch(self, wd: WatchDescriptor) -> Result<()> {
         let res = unsafe { libc::inotify_rm_watch(self.fd, wd.wd) };
 
         Errno::result(res).map(drop)
     }
 
     #[cfg(target_os = "android")]
-    pub fn rm_watch(&self, wd: WatchDescriptor) -> Result<()> {
+    pub fn rm_watch(self, wd: WatchDescriptor) -> Result<()> {
         let res = unsafe { libc::inotify_rm_watch(self.fd, wd.wd as u32) };
 
         Errno::result(res).map(drop)
@@ -167,13 +167,14 @@ impl Inotify {
 
     /// Reads a collection of events from the inotify file descriptor. This call
     /// can either be blocking or non blocking depending on whether IN_NONBLOCK
-    /// was set at initialization. 
-    /// 
+    /// was set at initialization.
+    ///
     /// Returns as many events as available. If the call was non blocking and no
     /// events could be read then the EAGAIN error is returned.
-    pub fn read_events(&self) -> Result<Vec<InotifyEvent>> {
+    pub fn read_events(self) -> Result<Vec<InotifyEvent>> {
         let header_size = size_of::<libc::inotify_event>();
-        let mut buffer = [0u8; 4096];
+        const BUFSIZ: usize = 4096;
+        let mut buffer = [0u8; BUFSIZ];
         let mut events = Vec::new();
         let mut offset = 0;
 
@@ -181,24 +182,26 @@ impl Inotify {
 
         while (nread - offset) >= header_size {
             let event = unsafe {
-                &*(
-                    buffer
-                        .as_ptr()
-                        .offset(offset as isize) as *const libc::inotify_event
-                )
+                let mut event = MaybeUninit::<libc::inotify_event>::uninit();
+                ptr::copy_nonoverlapping(
+                    buffer.as_ptr().add(offset),
+                    event.as_mut_ptr() as *mut u8,
+                    (BUFSIZ - offset).min(header_size)
+                );
+                event.assume_init()
             };
 
             let name = match event.len {
                 0 => None,
                 _ => {
-                    let ptr = unsafe { 
+                    let ptr = unsafe {
                         buffer
                             .as_ptr()
-                            .offset(offset as isize + header_size as isize)
+                            .add(offset + header_size)
                             as *const c_char
                     };
                     let cstr = unsafe { CStr::from_ptr(ptr) };
-                
+
                     Some(OsStr::from_bytes(cstr.to_bytes()).to_owned())
                 }
             };
diff --git a/third_party/rust/nix/src/sys/ioctl/bsd.rs b/third_party/rust/nix/src/sys/ioctl/bsd.rs
index 9b8b0ff1a155f..4ce4d332a8269 100644
--- a/third_party/rust/nix/src/sys/ioctl/bsd.rs
+++ b/third_party/rust/nix/src/sys/ioctl/bsd.rs
@@ -1,20 +1,27 @@
 /// The datatype used for the ioctl number
 #[doc(hidden)]
+#[cfg(not(target_os = "illumos"))]
 pub type ioctl_num_type = ::libc::c_ulong;
+
+#[doc(hidden)]
+#[cfg(target_os = "illumos")]
+pub type ioctl_num_type = ::libc::c_int;
+
 /// The datatype used for the 3rd argument
 #[doc(hidden)]
 pub type ioctl_param_type = ::libc::c_int;
 
 mod consts {
-    use ::sys::ioctl::ioctl_num_type;
+    use crate::sys::ioctl::ioctl_num_type;
     #[doc(hidden)]
     pub const VOID: ioctl_num_type = 0x2000_0000;
     #[doc(hidden)]
     pub const OUT: ioctl_num_type = 0x4000_0000;
     #[doc(hidden)]
+    #[allow(overflowing_literals)]
     pub const IN: ioctl_num_type = 0x8000_0000;
     #[doc(hidden)]
-    pub const INOUT: ioctl_num_type = (IN|OUT);
+    pub const INOUT: ioctl_num_type = IN|OUT;
     #[doc(hidden)]
     pub const IOCPARM_MASK: ioctl_num_type = 0x1fff;
 }
diff --git a/third_party/rust/nix/src/sys/ioctl/linux.rs b/third_party/rust/nix/src/sys/ioctl/linux.rs
index 9cdac72a4b80b..68ebaba9bf496 100644
--- a/third_party/rust/nix/src/sys/ioctl/linux.rs
+++ b/third_party/rust/nix/src/sys/ioctl/linux.rs
@@ -33,7 +33,8 @@ mod consts {
           target_arch = "arm",
           target_arch = "s390x",
           target_arch = "x86_64",
-          target_arch = "aarch64"))]
+          target_arch = "aarch64",
+          target_arch = "riscv64"))]
 mod consts {
     #[doc(hidden)]
     pub const NONE: u8 = 0;
diff --git a/third_party/rust/nix/src/sys/ioctl/mod.rs b/third_party/rust/nix/src/sys/ioctl/mod.rs
index 4513bf877434a..203b7d06f31f1 100644
--- a/third_party/rust/nix/src/sys/ioctl/mod.rs
+++ b/third_party/rust/nix/src/sys/ioctl/mod.rs
@@ -29,7 +29,7 @@
 //! Historically `ioctl` numbers were arbitrary hard-coded values. In Linux (before 2.6) and some
 //! unices this has changed to a more-ordered system where the ioctl numbers are partitioned into
 //! subcomponents (For linux this is documented in
-//! [`Documentation/ioctl/ioctl-number.txt`](http://elixir.free-electrons.com/linux/latest/source/Documentation/ioctl/ioctl-number.txt)):
+//! [`Documentation/ioctl/ioctl-number.rst`](https://elixir.bootlin.com/linux/latest/source/Documentation/userspace-api/ioctl/ioctl-number.rst)):
 //!
 //!   * Number: The actual ioctl ID
 //!   * Type: A grouping of ioctls for a common purpose or driver
@@ -104,7 +104,7 @@
 //! respectively. To determine the specific `write_` variant to use you'll need to find
 //! what the argument type is supposed to be. If it's an `int`, then `write_int` should be used,
 //! otherwise it should be a pointer and `write_ptr` should be used. On Linux the
-//! [`ioctl_list` man page](http://man7.org/linux/man-pages/man2/ioctl_list.2.html) describes a
+//! [`ioctl_list` man page](https://man7.org/linux/man-pages/man2/ioctl_list.2.html) describes a
 //! large number of `ioctl`s and describes their argument data type.
 //!
 //! Using "bad" `ioctl`s
@@ -221,15 +221,18 @@
 //!
 //! # fn main() {}
 //! ```
-#[cfg(any(target_os = "android", target_os = "linux"))]
+use cfg_if::cfg_if;
+
+#[cfg(any(target_os = "android", target_os = "linux", target_os = "redox"))]
 #[macro_use]
 mod linux;
 
-#[cfg(any(target_os = "android", target_os = "linux"))]
+#[cfg(any(target_os = "android", target_os = "linux", target_os = "redox"))]
 pub use self::linux::*;
 
 #[cfg(any(target_os = "dragonfly",
           target_os = "freebsd",
+          target_os = "illumos",
           target_os = "ios",
           target_os = "macos",
           target_os = "netbsd",
@@ -239,6 +242,7 @@ mod bsd;
 
 #[cfg(any(target_os = "dragonfly",
           target_os = "freebsd",
+          target_os = "illumos",
           target_os = "ios",
           target_os = "macos",
           target_os = "netbsd",
@@ -317,7 +321,6 @@ macro_rules! ioctl_none {
 ///
 /// ```no_run
 /// # #[macro_use] extern crate nix;
-/// # extern crate libc;
 /// # use libc::TIOCNXCL;
 /// # use std::fs::File;
 /// # use std::os::unix::io::AsRawFd;
@@ -396,7 +399,6 @@ macro_rules! ioctl_read {
 /// # Example
 ///
 /// ```
-/// # extern crate libc;
 /// # #[macro_use] extern crate nix;
 /// # #[cfg(any(target_os = "android", target_os = "linux"))]
 /// ioctl_read_bad!(tcgets, libc::TCGETS, libc::termios);
@@ -470,7 +472,6 @@ macro_rules! ioctl_write_ptr {
 /// # Example
 ///
 /// ```
-/// # extern crate libc;
 /// # #[macro_use] extern crate nix;
 /// # #[cfg(any(target_os = "android", target_os = "linux"))]
 /// ioctl_write_ptr_bad!(tcsets, libc::TCSETS, libc::termios);
@@ -590,7 +591,6 @@ cfg_if!{
 /// # Examples
 ///
 /// ```
-/// # extern crate libc;
 /// # #[macro_use] extern crate nix;
 /// # #[cfg(any(target_os = "android", target_os = "linux"))]
 /// ioctl_write_int_bad!(tcsbrk, libc::TCSBRK);
diff --git a/third_party/rust/nix/src/sys/memfd.rs b/third_party/rust/nix/src/sys/memfd.rs
index 9672429b31e7f..642676b431d07 100644
--- a/third_party/rust/nix/src/sys/memfd.rs
+++ b/third_party/rust/nix/src/sys/memfd.rs
@@ -1,16 +1,43 @@
-use libc;
+//! Interfaces for managing memory-backed files.
+
 use std::os::unix::io::RawFd;
-use Result;
-use errno::Errno;
+use crate::Result;
+use crate::errno::Errno;
 use std::ffi::CStr;
 
 libc_bitflags!(
+    /// Options that change the behavior of [`memfd_create`].
     pub struct MemFdCreateFlag: libc::c_uint {
+        /// Set the close-on-exec ([`FD_CLOEXEC`]) flag on the new file descriptor.
+        ///
+        /// By default, the new file descriptor is set to remain open across an [`execve`]
+        /// (the `FD_CLOEXEC` flag is initially disabled). This flag can be used to change
+        /// this default. The file offset is set to the beginning of the file (see [`lseek`]).
+        ///
+        /// See also the description of the `O_CLOEXEC` flag in [`open(2)`].
+        ///
+        /// [`execve`]: crate::unistd::execve
+        /// [`lseek`]: crate::unistd::lseek
+        /// [`FD_CLOEXEC`]: crate::fcntl::FdFlag::FD_CLOEXEC
+        /// [`open(2)`]: https://man7.org/linux/man-pages/man2/open.2.html
         MFD_CLOEXEC;
+        /// Allow sealing operations on this file.
+        ///
+        /// See also the file sealing notes given in [`memfd_create(2)`].
+        ///
+        /// [`memfd_create(2)`]: https://man7.org/linux/man-pages/man2/memfd_create.2.html
         MFD_ALLOW_SEALING;
     }
 );
 
+/// Creates an anonymous file that lives in memory, and return a file-descriptor to it.
+///
+/// The file behaves like a regular file, and so can be modified, truncated, memory-mapped, and so on.
+/// However, unlike a regular file, it lives in RAM and has a volatile backing storage.
+///
+/// For more information, see [`memfd_create(2)`].
+///
+/// [`memfd_create(2)`]: https://man7.org/linux/man-pages/man2/memfd_create.2.html
 pub fn memfd_create(name: &CStr, flags: MemFdCreateFlag) -> Result<RawFd> {
     let res = unsafe {
         libc::syscall(libc::SYS_memfd_create, name.as_ptr(), flags.bits())
diff --git a/third_party/rust/nix/src/sys/mman.rs b/third_party/rust/nix/src/sys/mman.rs
index 4e250501dd0f0..0ef1ca8a4f13e 100644
--- a/third_party/rust/nix/src/sys/mman.rs
+++ b/third_party/rust/nix/src/sys/mman.rs
@@ -1,12 +1,14 @@
-use {Error, Result};
+//! Memory management declarations.
+
+use crate::Result;
 #[cfg(not(target_os = "android"))]
-use NixPath;
-use errno::Errno;
+use crate::NixPath;
+use crate::errno::Errno;
 #[cfg(not(target_os = "android"))]
-use fcntl::OFlag;
+use crate::fcntl::OFlag;
 use libc::{self, c_int, c_void, size_t, off_t};
 #[cfg(not(target_os = "android"))]
-use sys::stat::Mode;
+use crate::sys::stat::Mode;
 use std::os::unix::io::RawFd;
 
 libc_bitflags!{
@@ -30,7 +32,7 @@ libc_bitflags!{
 }
 
 libc_bitflags!{
-    /// Additional parameters for `mmap()`.
+    /// Additional parameters for [`mmap`].
     pub struct MapFlags: c_int {
         /// Compatibility flag. Ignored.
         MAP_FILE;
@@ -40,10 +42,13 @@ libc_bitflags!{
         MAP_PRIVATE;
         /// Place the mapping at exactly the address specified in `addr`.
         MAP_FIXED;
+        /// To be used with `MAP_FIXED`, to forbid the system
+        /// to select a different address than the one specified.
+        #[cfg(target_os = "freebsd")]
+        MAP_EXCL;
         /// Synonym for `MAP_ANONYMOUS`.
         MAP_ANON;
         /// The mapping is not backed by any file.
-        #[cfg(any(target_os = "android", target_os = "linux", target_os = "freebsd"))]
         MAP_ANONYMOUS;
         /// Put the mapping into the first 2GB of the process address space.
         #[cfg(any(all(any(target_os = "android", target_os = "linux"),
@@ -65,8 +70,8 @@ libc_bitflags!{
         MAP_LOCKED;
         /// Do not reserve swap space for this mapping.
         ///
-        /// This was removed in FreeBSD 11.
-        #[cfg(not(target_os = "freebsd"))]
+        /// This was removed in FreeBSD 11 and is unused in DragonFlyBSD.
+        #[cfg(not(any(target_os = "dragonfly", target_os = "freebsd")))]
         MAP_NORESERVE;
         /// Populate page tables for a mapping.
         #[cfg(any(target_os = "android", target_os = "linux"))]
@@ -77,6 +82,43 @@ libc_bitflags!{
         /// Allocate the mapping using "huge pages."
         #[cfg(any(target_os = "android", target_os = "linux"))]
         MAP_HUGETLB;
+        /// Make use of 64KB huge page (must be supported by the system)
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_64KB;
+        /// Make use of 512KB huge page (must be supported by the system)
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_512KB;
+        /// Make use of 1MB huge page (must be supported by the system)
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_1MB;
+        /// Make use of 2MB huge page (must be supported by the system)
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_2MB;
+        /// Make use of 8MB huge page (must be supported by the system)
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_8MB;
+        /// Make use of 16MB huge page (must be supported by the system)
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_16MB;
+        /// Make use of 32MB huge page (must be supported by the system)
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_32MB;
+        /// Make use of 256MB huge page (must be supported by the system)
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_256MB;
+        /// Make use of 512MB huge page (must be supported by the system)
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_512MB;
+        /// Make use of 1GB huge page (must be supported by the system)
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_1GB;
+        /// Make use of 2GB huge page (must be supported by the system)
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_2GB;
+        /// Make use of 16GB huge page (must be supported by the system)
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_16GB;
+
         /// Lock the mapped region into memory as with `mlock(2)`.
         #[cfg(target_os = "netbsd")]
         MAP_WIRED;
@@ -85,28 +127,55 @@ libc_bitflags!{
         MAP_NOSYNC;
         /// Rename private pages to a file.
         ///
-        /// This was removed in FreeBSD 11.
-        #[cfg(any(target_os = "dragonfly", target_os = "netbsd", target_os = "openbsd"))]
+        /// This was removed in FreeBSD 11 and is unused in DragonFlyBSD.
+        #[cfg(any(target_os = "netbsd", target_os = "openbsd"))]
         MAP_RENAME;
         /// Region may contain semaphores.
         #[cfg(any(target_os = "dragonfly", target_os = "freebsd", target_os = "netbsd", target_os = "openbsd"))]
         MAP_HASSEMAPHORE;
         /// Region grows down, like a stack.
-        #[cfg(any(target_os = "android", target_os = "dragonfly", target_os = "freebsd", target_os = "linux"))]
+        #[cfg(any(target_os = "android", target_os = "dragonfly", target_os = "freebsd", target_os = "linux", target_os = "openbsd"))]
         MAP_STACK;
         /// Pages in this mapping are not retained in the kernel's memory cache.
         #[cfg(any(target_os = "ios", target_os = "macos"))]
         MAP_NOCACHE;
+        /// Allows the W/X bit on the page, it's necessary on aarch64 architecture.
         #[cfg(any(target_os = "ios", target_os = "macos"))]
         MAP_JIT;
+        /// Allows to use large pages, underlying alignment based on size.
+        #[cfg(target_os = "freebsd")]
+        MAP_ALIGNED_SUPER;
+        /// Pages will be discarded in the core dumps.
+        #[cfg(target_os = "openbsd")]
+        MAP_CONCEAL;
+    }
+}
+
+#[cfg(any(target_os = "linux", target_os = "netbsd"))]
+libc_bitflags!{
+    /// Options for [`mremap`].
+    pub struct MRemapFlags: c_int {
+        /// Permit the kernel to relocate the mapping to a new virtual address, if necessary.
+        #[cfg(target_os = "linux")]
+        MREMAP_MAYMOVE;
+        /// Place the mapping at exactly the address specified in `new_address`.
+        #[cfg(target_os = "linux")]
+        MREMAP_FIXED;
+        /// Permits to use the old and new address as hints to relocate the mapping.
+        #[cfg(target_os = "netbsd")]
+        MAP_FIXED;
+        /// Allows to duplicate the mapping to be able to apply different flags on the copy.
+        #[cfg(target_os = "netbsd")]
+        MAP_REMAPDUP;
     }
 }
 
 libc_enum!{
     /// Usage information for a range of memory to allow for performance optimizations by the kernel.
     ///
-    /// Used by [`madvise`](./fn.madvise.html).
+    /// Used by [`madvise`].
     #[repr(i32)]
+    #[non_exhaustive]
     pub enum MmapAdvise {
         /// No further special treatment. This is the default.
         MADV_NORMAL,
@@ -143,7 +212,8 @@ libc_enum!{
             all(target_os = "linux", any(
                 target_arch = "aarch64",
                 target_arch = "arm",
-                target_arch = "ppc",
+                target_arch = "powerpc",
+                target_arch = "powerpc64",
                 target_arch = "s390x",
                 target_arch = "x86",
                 target_arch = "x86_64",
@@ -196,7 +266,7 @@ libc_enum!{
 }
 
 libc_bitflags!{
-    /// Configuration flags for `msync`.
+    /// Configuration flags for [`msync`].
     pub struct MsFlags: c_int {
         /// Schedule an update but return immediately.
         MS_ASYNC;
@@ -214,7 +284,7 @@ libc_bitflags!{
 }
 
 libc_bitflags!{
-    /// Flags for `mlockall`.
+    /// Flags for [`mlockall`].
     pub struct MlockAllFlags: c_int {
         /// Lock pages that are currently mapped into the address space of the process.
         MCL_CURRENT;
@@ -223,52 +293,128 @@ libc_bitflags!{
     }
 }
 
-/// Locks all memory pages that contain part of the address range with `length` bytes starting at
-/// `addr`. Locked pages never move to the swap area.
+/// Locks all memory pages that contain part of the address range with `length`
+/// bytes starting at `addr`.
+///
+/// Locked pages never move to the swap area.
+///
+/// # Safety
+///
+/// `addr` must meet all the requirements described in the [`mlock(2)`] man page.
+///
+/// [`mlock(2)`]: https://man7.org/linux/man-pages/man2/mlock.2.html
 pub unsafe fn mlock(addr: *const c_void, length: size_t) -> Result<()> {
     Errno::result(libc::mlock(addr, length)).map(drop)
 }
 
-/// Unlocks all memory pages that contain part of the address range with `length` bytes starting at
-/// `addr`.
+/// Unlocks all memory pages that contain part of the address range with
+/// `length` bytes starting at `addr`.
+///
+/// # Safety
+///
+/// `addr` must meet all the requirements described in the [`munlock(2)`] man
+/// page.
+///
+/// [`munlock(2)`]: https://man7.org/linux/man-pages/man2/munlock.2.html
 pub unsafe fn munlock(addr: *const c_void, length: size_t) -> Result<()> {
     Errno::result(libc::munlock(addr, length)).map(drop)
 }
 
-/// Locks all memory pages mapped into this process' address space. Locked pages never move to the
-/// swap area.
+/// Locks all memory pages mapped into this process' address space.
+///
+/// Locked pages never move to the swap area. For more information, see [`mlockall(2)`].
+///
+/// [`mlockall(2)`]: https://man7.org/linux/man-pages/man2/mlockall.2.html
 pub fn mlockall(flags: MlockAllFlags) -> Result<()> {
     unsafe { Errno::result(libc::mlockall(flags.bits())) }.map(drop)
 }
 
 /// Unlocks all memory pages mapped into this process' address space.
+///
+/// For more information, see [`munlockall(2)`].
+///
+/// [`munlockall(2)`]: https://man7.org/linux/man-pages/man2/munlockall.2.html
 pub fn munlockall() -> Result<()> {
     unsafe { Errno::result(libc::munlockall()) }.map(drop)
 }
 
-/// Calls to mmap are inherently unsafe, so they must be made in an unsafe block. Typically
-/// a higher-level abstraction will hide the unsafe interactions with the mmap'd region.
+/// allocate memory, or map files or devices into memory
+///
+/// # Safety
+///
+/// See the [`mmap(2)`] man page for detailed requirements.
+///
+/// [`mmap(2)`]: https://man7.org/linux/man-pages/man2/mmap.2.html
 pub unsafe fn mmap(addr: *mut c_void, length: size_t, prot: ProtFlags, flags: MapFlags, fd: RawFd, offset: off_t) -> Result<*mut c_void> {
     let ret = libc::mmap(addr, length, prot.bits(), flags.bits(), fd, offset);
 
     if ret == libc::MAP_FAILED {
-        Err(Error::Sys(Errno::last()))
+        Err(Errno::last())
     } else {
         Ok(ret)
     }
 }
 
+/// Expands (or shrinks) an existing memory mapping, potentially moving it at
+/// the same time.
+///
+/// # Safety
+///
+/// See the `mremap(2)` [man page](https://man7.org/linux/man-pages/man2/mremap.2.html) for
+/// detailed requirements.
+#[cfg(any(target_os = "linux", target_os = "netbsd"))]
+pub unsafe fn mremap(
+    addr: *mut c_void,
+    old_size: size_t,
+    new_size: size_t,
+    flags: MRemapFlags,
+    new_address: Option<* mut c_void>,
+) -> Result<*mut c_void> {
+    #[cfg(target_os = "linux")]
+    let ret = libc::mremap(addr, old_size, new_size, flags.bits(), new_address.unwrap_or(std::ptr::null_mut()));
+    #[cfg(target_os = "netbsd")]
+    let ret = libc::mremap(
+        addr,
+        old_size,
+        new_address.unwrap_or(std::ptr::null_mut()),
+        new_size,
+        flags.bits(),
+        );
+
+    if ret == libc::MAP_FAILED {
+        Err(Errno::last())
+    } else {
+        Ok(ret)
+    }
+}
+
+/// remove a mapping
+///
+/// # Safety
+///
+/// `addr` must meet all the requirements described in the [`munmap(2)`] man
+/// page.
+///
+/// [`munmap(2)`]: https://man7.org/linux/man-pages/man2/munmap.2.html
 pub unsafe fn munmap(addr: *mut c_void, len: size_t) -> Result<()> {
     Errno::result(libc::munmap(addr, len)).map(drop)
 }
 
+/// give advice about use of memory
+///
+/// # Safety
+///
+/// See the [`madvise(2)`] man page.  Take special care when using
+/// [`MmapAdvise::MADV_FREE`].
+///
+/// [`madvise(2)`]: https://man7.org/linux/man-pages/man2/madvise.2.html
 pub unsafe fn madvise(addr: *mut c_void, length: size_t, advise: MmapAdvise) -> Result<()> {
     Errno::result(libc::madvise(addr, length, advise as i32)).map(drop)
 }
 
 /// Set protection of memory mapping.
 ///
-/// See [`mprotect(3)`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/mprotect.html) for
+/// See [`mprotect(3)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mprotect.html) for
 /// details.
 ///
 /// # Safety
@@ -295,10 +441,23 @@ pub unsafe fn mprotect(addr: *mut c_void, length: size_t, prot: ProtFlags) -> Re
     Errno::result(libc::mprotect(addr, length, prot.bits())).map(drop)
 }
 
+/// synchronize a mapped region
+///
+/// # Safety
+///
+/// `addr` must meet all the requirements described in the [`msync(2)`] man
+/// page.
+///
+/// [`msync(2)`]: https://man7.org/linux/man-pages/man2/msync.2.html
 pub unsafe fn msync(addr: *mut c_void, length: size_t, flags: MsFlags) -> Result<()> {
     Errno::result(libc::msync(addr, length, flags.bits())).map(drop)
 }
 
+/// Creates and opens a new, or opens an existing, POSIX shared memory object.
+///
+/// For more information, see [`shm_open(3)`].
+///
+/// [`shm_open(3)`]: https://man7.org/linux/man-pages/man3/shm_open.3.html
 #[cfg(not(target_os = "android"))]
 pub fn shm_open<P: ?Sized + NixPath>(name: &P, flag: OFlag, mode: Mode) -> Result<RawFd> {
     let ret = name.with_nix_path(|cstr| {
@@ -315,6 +474,11 @@ pub fn shm_open<P: ?Sized + NixPath>(name: &P, flag: OFlag, mode: Mode) -> Resul
     Errno::result(ret)
 }
 
+/// Performs the converse of [`shm_open`], removing an object previously created.
+///
+/// For more information, see [`shm_unlink(3)`].
+///
+/// [`shm_unlink(3)`]: https://man7.org/linux/man-pages/man3/shm_unlink.3.html
 #[cfg(not(target_os = "android"))]
 pub fn shm_unlink<P: ?Sized + NixPath>(name: &P) -> Result<()> {
     let ret = name.with_nix_path(|cstr| {
diff --git a/third_party/rust/nix/src/sys/mod.rs b/third_party/rust/nix/src/sys/mod.rs
index d3c2f92bbaaea..156b0d9d1ce85 100644
--- a/third_party/rust/nix/src/sys/mod.rs
+++ b/third_party/rust/nix/src/sys/mod.rs
@@ -1,3 +1,4 @@
+//! Mostly platform-specific functionality
 #[cfg(any(target_os = "dragonfly",
           target_os = "freebsd",
           target_os = "ios",
@@ -7,6 +8,7 @@
 pub mod aio;
 
 #[cfg(any(target_os = "android", target_os = "linux"))]
+#[allow(missing_docs)]
 pub mod epoll;
 
 #[cfg(any(target_os = "dragonfly",
@@ -15,9 +17,11 @@ pub mod epoll;
           target_os = "macos",
           target_os = "netbsd",
           target_os = "openbsd"))]
+#[allow(missing_docs)]
 pub mod event;
 
-#[cfg(target_os = "linux")]
+#[cfg(any(target_os = "android", target_os = "linux"))]
+#[allow(missing_docs)]
 pub mod eventfd;
 
 #[cfg(any(target_os = "android",
@@ -25,8 +29,10 @@ pub mod eventfd;
           target_os = "freebsd",
           target_os = "ios",
           target_os = "linux",
+          target_os = "redox",
           target_os = "macos",
           target_os = "netbsd",
+          target_os = "illumos",
           target_os = "openbsd"))]
 #[macro_use]
 pub mod ioctl;
@@ -34,8 +40,14 @@ pub mod ioctl;
 #[cfg(target_os = "linux")]
 pub mod memfd;
 
+#[cfg(not(target_os = "redox"))]
+#[allow(missing_docs)]
 pub mod mman;
 
+#[cfg(target_os = "linux")]
+#[allow(missing_docs)]
+pub mod personality;
+
 pub mod pthread;
 
 #[cfg(any(target_os = "android",
@@ -45,14 +57,20 @@ pub mod pthread;
           target_os = "macos",
           target_os = "netbsd",
           target_os = "openbsd"))]
+#[allow(missing_docs)]
 pub mod ptrace;
 
 #[cfg(target_os = "linux")]
 pub mod quota;
 
 #[cfg(any(target_os = "linux"))]
+#[allow(missing_docs)]
 pub mod reboot;
 
+#[cfg(not(any(target_os = "redox", target_os = "fuchsia", target_os = "illumos")))]
+pub mod resource;
+
+#[cfg(not(target_os = "redox"))]
 pub mod select;
 
 #[cfg(any(target_os = "android",
@@ -65,10 +83,14 @@ pub mod sendfile;
 pub mod signal;
 
 #[cfg(any(target_os = "android", target_os = "linux"))]
+#[allow(missing_docs)]
 pub mod signalfd;
 
+#[cfg(not(target_os = "redox"))]
+#[allow(missing_docs)]
 pub mod socket;
 
+#[allow(missing_docs)]
 pub mod stat;
 
 #[cfg(any(target_os = "android",
@@ -84,10 +106,13 @@ pub mod statfs;
 pub mod statvfs;
 
 #[cfg(any(target_os = "android", target_os = "linux"))]
+#[allow(missing_docs)]
 pub mod sysinfo;
 
+#[allow(missing_docs)]
 pub mod termios;
 
+#[allow(missing_docs)]
 pub mod time;
 
 pub mod uio;
@@ -97,4 +122,9 @@ pub mod utsname;
 pub mod wait;
 
 #[cfg(any(target_os = "android", target_os = "linux"))]
+#[allow(missing_docs)]
 pub mod inotify;
+
+#[cfg(any(target_os = "android", target_os = "linux"))]
+#[allow(missing_docs)]
+pub mod timerfd;
diff --git a/third_party/rust/nix/src/sys/personality.rs b/third_party/rust/nix/src/sys/personality.rs
new file mode 100644
index 0000000000000..b15956c469b99
--- /dev/null
+++ b/third_party/rust/nix/src/sys/personality.rs
@@ -0,0 +1,70 @@
+use crate::Result;
+use crate::errno::Errno;
+
+use libc::{self, c_int, c_ulong};
+
+libc_bitflags! {
+    /// Flags used and returned by [`get()`](fn.get.html) and
+    /// [`set()`](fn.set.html).
+    pub struct Persona: c_int {
+        ADDR_COMPAT_LAYOUT;
+        ADDR_NO_RANDOMIZE;
+        ADDR_LIMIT_32BIT;
+        ADDR_LIMIT_3GB;
+        #[cfg(not(target_env = "musl"))]
+        FDPIC_FUNCPTRS;
+        MMAP_PAGE_ZERO;
+        READ_IMPLIES_EXEC;
+        SHORT_INODE;
+        STICKY_TIMEOUTS;
+        #[cfg(not(target_env = "musl"))]
+        UNAME26;
+        WHOLE_SECONDS;
+    }
+}
+
+/// Retrieve the current process personality.
+///
+/// Returns a Result containing a Persona instance.
+///
+/// Example:
+///
+/// ```
+/// # use nix::sys::personality::{self, Persona};
+/// let pers = personality::get().unwrap();
+/// assert!(!pers.contains(Persona::WHOLE_SECONDS));
+/// ```
+pub fn get() -> Result<Persona> {
+    let res = unsafe {
+        libc::personality(0xFFFFFFFF)
+    };
+
+    Errno::result(res).map(Persona::from_bits_truncate)
+}
+
+/// Set the current process personality.
+///
+/// Returns a Result containing the *previous* personality for the
+/// process, as a Persona.
+///
+/// For more information, see [personality(2)](https://man7.org/linux/man-pages/man2/personality.2.html)
+///
+/// **NOTE**: This call **replaces** the current personality entirely.
+/// To **update** the personality, first call `get()` and then `set()`
+/// with the modified persona.
+///
+/// Example:
+///
+/// ```
+/// # use nix::sys::personality::{self, Persona};
+/// let mut pers = personality::get().unwrap();
+/// assert!(!pers.contains(Persona::ADDR_NO_RANDOMIZE));
+/// personality::set(pers | Persona::ADDR_NO_RANDOMIZE);
+/// ```
+pub fn set(persona: Persona) -> Result<Persona> {
+    let res = unsafe {
+        libc::personality(persona.bits() as c_ulong)
+    };
+
+    Errno::result(res).map(Persona::from_bits_truncate)
+}
diff --git a/third_party/rust/nix/src/sys/pthread.rs b/third_party/rust/nix/src/sys/pthread.rs
index a4d98250f2b8b..d42e45d13dcd7 100644
--- a/third_party/rust/nix/src/sys/pthread.rs
+++ b/third_party/rust/nix/src/sys/pthread.rs
@@ -1,9 +1,18 @@
+//! Low level threading primitives
+
+#[cfg(not(target_os = "redox"))]
+use crate::errno::Errno;
+#[cfg(not(target_os = "redox"))]
+use crate::Result;
+#[cfg(not(target_os = "redox"))]
+use crate::sys::signal::Signal;
 use libc::{self, pthread_t};
 
+/// Identifies an individual thread.
 pub type Pthread = pthread_t;
 
 /// Obtain ID of the calling thread (see
-/// [`pthread_self(3)`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_self.html)
+/// [`pthread_self(3)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_self.html)
 ///
 /// The thread ID returned by `pthread_self()` is not the same thing as
 /// the kernel thread ID returned by a call to `gettid(2)`.
@@ -11,3 +20,19 @@ pub type Pthread = pthread_t;
 pub fn pthread_self() -> Pthread {
     unsafe { libc::pthread_self() }
 }
+
+/// Send a signal to a thread (see [`pthread_kill(3)`]).
+///
+/// If `signal` is `None`, `pthread_kill` will only preform error checking and
+/// won't send any signal.
+///
+/// [`pthread_kill(3)`]: https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_kill.html
+#[cfg(not(target_os = "redox"))]
+pub fn pthread_kill<T: Into<Option<Signal>>>(thread: Pthread, signal: T) -> Result<()> {
+    let sig = match signal.into() {
+        Some(s) => s as libc::c_int,
+        None => 0,
+    };
+    let res = unsafe { libc::pthread_kill(thread, sig) };
+    Errno::result(res).map(drop)
+}
diff --git a/third_party/rust/nix/src/sys/ptrace/bsd.rs b/third_party/rust/nix/src/sys/ptrace/bsd.rs
index 7797d10647ef4..a62881ef34b77 100644
--- a/third_party/rust/nix/src/sys/ptrace/bsd.rs
+++ b/third_party/rust/nix/src/sys/ptrace/bsd.rs
@@ -1,9 +1,10 @@
-use errno::Errno;
+use cfg_if::cfg_if;
+use crate::errno::Errno;
 use libc::{self, c_int};
 use std::ptr;
-use sys::signal::Signal;
-use unistd::Pid;
-use Result;
+use crate::sys::signal::Signal;
+use crate::unistd::Pid;
+use crate::Result;
 
 pub type RequestType = c_int;
 
@@ -23,6 +24,7 @@ cfg_if! {
 libc_enum! {
     #[repr(i32)]
     /// Ptrace Request enum defining the action to be taken.
+    #[non_exhaustive]
     pub enum Request {
         PT_TRACE_ME,
         PT_READ_I,
@@ -77,16 +79,23 @@ pub fn traceme() -> Result<()> {
 
 /// Attach to a running process, as with `ptrace(PT_ATTACH, ...)`
 ///
-/// Attaches to the process specified in pid, making it a tracee of the calling process.
+/// Attaches to the process specified by `pid`, making it a tracee of the calling process.
 pub fn attach(pid: Pid) -> Result<()> {
     unsafe { ptrace_other(Request::PT_ATTACH, pid, ptr::null_mut(), 0).map(drop) }
 }
 
 /// Detaches the current running process, as with `ptrace(PT_DETACH, ...)`
 ///
-/// Detaches from the process specified in pid allowing it to run freely
-pub fn detach(pid: Pid) -> Result<()> {
-    unsafe { ptrace_other(Request::PT_DETACH, pid, ptr::null_mut(), 0).map(drop) }
+/// Detaches from the process specified by `pid` allowing it to run freely, optionally delivering a
+/// signal specified by `sig`.
+pub fn detach<T: Into<Option<Signal>>>(pid: Pid, sig: T) -> Result<()> {
+    let data = match sig.into() {
+        Some(s) => s as c_int,
+        None => 0,
+    };
+    unsafe {
+        ptrace_other(Request::PT_DETACH, pid, ptr::null_mut(), data).map(drop)
+    }
 }
 
 /// Restart the stopped tracee process, as with `ptrace(PTRACE_CONT, ...)`
@@ -121,21 +130,18 @@ pub fn kill(pid: Pid) -> Result<()> {
 ///
 /// # Example
 /// ```rust
-/// extern crate nix;
 /// use nix::sys::ptrace::step;
 /// use nix::unistd::Pid;
 /// use nix::sys::signal::Signal;
 /// use nix::sys::wait::*;
-/// fn main() {
-///     // If a process changes state to the stopped state because of a SIGUSR1
-///     // signal, this will step the process forward and forward the user
-///     // signal to the stopped process
-///     match waitpid(Pid::from_raw(-1), None) {
-///         Ok(WaitStatus::Stopped(pid, Signal::SIGUSR1)) => {
-///             let _ = step(pid, Signal::SIGUSR1);
-///         }
-///         _ => {},
+/// // If a process changes state to the stopped state because of a SIGUSR1
+/// // signal, this will step the process forward and forward the user
+/// // signal to the stopped process
+/// match waitpid(Pid::from_raw(-1), None) {
+///     Ok(WaitStatus::Stopped(pid, Signal::SIGUSR1)) => {
+///         let _ = step(pid, Signal::SIGUSR1);
 ///     }
+///     _ => {},
 /// }
 /// ```
 #[cfg(
diff --git a/third_party/rust/nix/src/sys/ptrace/linux.rs b/third_party/rust/nix/src/sys/ptrace/linux.rs
index df15e66527562..37236790b41c1 100644
--- a/third_party/rust/nix/src/sys/ptrace/linux.rs
+++ b/third_party/rust/nix/src/sys/ptrace/linux.rs
@@ -1,18 +1,21 @@
 //! For detailed description of the ptrace requests, consult `man ptrace`.
 
+use cfg_if::cfg_if;
 use std::{mem, ptr};
-use {Error, Result};
-use errno::Errno;
+use crate::Result;
+use crate::errno::Errno;
 use libc::{self, c_void, c_long, siginfo_t};
-use ::unistd::Pid;
-use sys::signal::Signal;
+use crate::unistd::Pid;
+use crate::sys::signal::Signal;
 
 pub type AddressType = *mut ::libc::c_void;
 
-#[cfg(all(target_os = "linux",
-          any(target_arch = "x86_64",
-              target_arch = "x86"),
-          target_env = "gnu"))]
+#[cfg(all(
+    target_os = "linux",
+    any(all(target_arch = "x86_64",
+            any(target_env = "gnu", target_env = "musl")),
+        all(target_arch = "x86", target_env = "gnu"))
+))]
 use libc::user_regs_struct;
 
 cfg_if! {
@@ -30,6 +33,7 @@ libc_enum!{
     #[cfg_attr(not(any(target_env = "musl", target_os = "android")), repr(u32))]
     #[cfg_attr(any(target_env = "musl", target_os = "android"), repr(i32))]
     /// Ptrace Request enum defining the action to be taken.
+    #[non_exhaustive]
     pub enum Request {
         PTRACE_TRACEME,
         PTRACE_PEEKTEXT,
@@ -94,11 +98,9 @@ libc_enum!{
         #[cfg(all(target_os = "linux", not(any(target_arch = "mips",
                                                target_arch = "mips64"))))]
         PTRACE_SETREGSET,
-        #[cfg(all(target_os = "linux", not(any(target_arch = "mips",
-                                               target_arch = "mips64"))))]
+        #[cfg(target_os = "linux")]
         PTRACE_SEIZE,
-        #[cfg(all(target_os = "linux", not(any(target_arch = "mips",
-                                               target_arch = "mips64"))))]
+        #[cfg(target_os = "linux")]
         PTRACE_INTERRUPT,
         #[cfg(all(target_os = "linux", not(any(target_arch = "mips",
                                                target_arch = "mips64"))))]
@@ -106,6 +108,12 @@ libc_enum!{
         #[cfg(all(target_os = "linux", not(any(target_arch = "mips",
                                                target_arch = "mips64"))))]
         PTRACE_PEEKSIGINFO,
+        #[cfg(all(target_os = "linux", target_env = "gnu",
+                  any(target_arch = "x86", target_arch = "x86_64")))]
+        PTRACE_SYSEMU,
+        #[cfg(all(target_os = "linux", target_env = "gnu",
+                  any(target_arch = "x86", target_arch = "x86_64")))]
+        PTRACE_SYSEMU_SINGLESTEP,
     }
 }
 
@@ -114,6 +122,7 @@ libc_enum!{
     /// Using the ptrace options the tracer can configure the tracee to stop
     /// at certain events. This enum is used to define those events as defined
     /// in `man ptrace`.
+    #[non_exhaustive]
     pub enum Event {
         /// Event that stops before a return from fork or clone.
         PTRACE_EVENT_FORK,
@@ -128,9 +137,11 @@ libc_enum!{
         /// Event for a stop before an exit. Unlike the waitpid Exit status program.
         /// registers can still be examined
         PTRACE_EVENT_EXIT,
-        /// STop triggered by a seccomp rule on a tracee.
+        /// Stop triggered by a seccomp rule on a tracee.
         PTRACE_EVENT_SECCOMP,
-        // PTRACE_EVENT_STOP not provided by libc because it's defined in glibc 2.26
+        /// Stop triggered by the `INTERRUPT` syscall, or a group stop,
+        /// or when a new child is attached.
+        PTRACE_EVENT_STOP,
     }
 }
 
@@ -165,47 +176,35 @@ libc_bitflags! {
     }
 }
 
-/// Performs a ptrace request. If the request in question is provided by a specialised function
-/// this function will return an unsupported operation error.
-#[deprecated(
-    since="0.10.0",
-    note="usages of `ptrace()` should be replaced with the specialized helper functions instead"
-)]
-pub unsafe fn ptrace(request: Request, pid: Pid, addr: AddressType, data: *mut c_void) -> Result<c_long> {
-    use self::Request::*;
-    match request {
-        PTRACE_PEEKTEXT | PTRACE_PEEKDATA | PTRACE_GETSIGINFO | 
-            PTRACE_GETEVENTMSG | PTRACE_SETSIGINFO | PTRACE_SETOPTIONS | 
-            PTRACE_POKETEXT | PTRACE_POKEDATA | PTRACE_KILL => Err(Error::UnsupportedOperation),
-        _ => ptrace_other(request, pid, addr, data)
-    }
-}
-
 fn ptrace_peek(request: Request, pid: Pid, addr: AddressType, data: *mut c_void) -> Result<c_long> {
     let ret = unsafe {
         Errno::clear();
         libc::ptrace(request as RequestType, libc::pid_t::from(pid), addr, data)
     };
     match Errno::result(ret) {
-        Ok(..) | Err(Error::Sys(Errno::UnknownErrno)) => Ok(ret),
+        Ok(..) | Err(Errno::UnknownErrno) => Ok(ret),
         err @ Err(..) => err,
     }
 }
 
 /// Get user registers, as with `ptrace(PTRACE_GETREGS, ...)`
-#[cfg(all(target_os = "linux",
-          any(target_arch = "x86_64",
-              target_arch = "x86"),
-          target_env = "gnu"))]
+#[cfg(all(
+    target_os = "linux",
+    any(all(target_arch = "x86_64",
+            any(target_env = "gnu", target_env = "musl")),
+        all(target_arch = "x86", target_env = "gnu"))
+))]
 pub fn getregs(pid: Pid) -> Result<user_regs_struct> {
     ptrace_get_data::<user_regs_struct>(Request::PTRACE_GETREGS, pid)
 }
 
 /// Set user registers, as with `ptrace(PTRACE_SETREGS, ...)`
-#[cfg(all(target_os = "linux",
-          any(target_arch = "x86_64",
-              target_arch = "x86"),
-          target_env = "gnu"))]
+#[cfg(all(
+    target_os = "linux",
+    any(all(target_arch = "x86_64",
+            any(target_env = "gnu", target_env = "musl")),
+        all(target_arch = "x86", target_env = "gnu"))
+))]
 pub fn setregs(pid: Pid, regs: user_regs_struct) -> Result<()> {
     let res = unsafe {
         libc::ptrace(Request::PTRACE_SETREGS as RequestType,
@@ -221,16 +220,15 @@ pub fn setregs(pid: Pid, regs: user_regs_struct) -> Result<()> {
 /// and therefore use the data field to return values. This function handles these
 /// requests.
 fn ptrace_get_data<T>(request: Request, pid: Pid) -> Result<T> {
-    // Creates an uninitialized pointer to store result in
-    let data: T = unsafe { mem::uninitialized() };
+    let mut data = mem::MaybeUninit::uninit();
     let res = unsafe {
         libc::ptrace(request as RequestType,
                      libc::pid_t::from(pid),
                      ptr::null_mut::<T>(),
-                     &data as *const _ as *const c_void)
+                     data.as_mut_ptr() as *const _ as *const c_void)
     };
     Errno::result(res)?;
-    Ok(data)
+    Ok(unsafe{ data.assume_init() })
 }
 
 unsafe fn ptrace_other(request: Request, pid: Pid, addr: AddressType, data: *mut c_void) -> Result<c_long> {
@@ -288,23 +286,45 @@ pub fn traceme() -> Result<()> {
     }
 }
 
-/// Ask for next syscall, as with `ptrace(PTRACE_SYSCALL, ...)`
+/// Continue execution until the next syscall, as with `ptrace(PTRACE_SYSCALL, ...)`
 ///
-/// Arranges for the tracee to be stopped at the next entry to or exit from a system call.
-pub fn syscall(pid: Pid) -> Result<()> {
+/// Arranges for the tracee to be stopped at the next entry to or exit from a system call,
+/// optionally delivering a signal specified by `sig`.
+pub fn syscall<T: Into<Option<Signal>>>(pid: Pid, sig: T) -> Result<()> {
+    let data = match sig.into() {
+        Some(s) => s as i32 as *mut c_void,
+        None => ptr::null_mut(),
+    };
     unsafe {
         ptrace_other(
             Request::PTRACE_SYSCALL,
             pid,
             ptr::null_mut(),
-            ptr::null_mut(),
+            data,
         ).map(drop) // ignore the useless return value
     }
 }
 
+/// Continue execution until the next syscall, as with `ptrace(PTRACE_SYSEMU, ...)`
+///
+/// In contrast to the `syscall` function, the syscall stopped at will not be executed.
+/// Thus the the tracee will only be stopped once per syscall,
+/// optionally delivering a signal specified by `sig`.
+#[cfg(all(target_os = "linux", target_env = "gnu", any(target_arch = "x86", target_arch = "x86_64")))]
+pub fn sysemu<T: Into<Option<Signal>>>(pid: Pid, sig: T) -> Result<()> {
+    let data = match sig.into() {
+        Some(s) => s as i32 as *mut c_void,
+        None => ptr::null_mut(),
+    };
+    unsafe {
+        ptrace_other(Request::PTRACE_SYSEMU, pid, ptr::null_mut(), data).map(drop)
+        // ignore the useless return value
+    }
+}
+
 /// Attach to a running process, as with `ptrace(PTRACE_ATTACH, ...)`
 ///
-/// Attaches to the process specified in pid, making it a tracee of the calling process.
+/// Attaches to the process specified by `pid`, making it a tracee of the calling process.
 pub fn attach(pid: Pid) -> Result<()> {
     unsafe {
         ptrace_other(
@@ -316,16 +336,36 @@ pub fn attach(pid: Pid) -> Result<()> {
     }
 }
 
+/// Attach to a running process, as with `ptrace(PTRACE_SEIZE, ...)`
+///
+/// Attaches to the process specified in pid, making it a tracee of the calling process.
+#[cfg(target_os = "linux")]
+pub fn seize(pid: Pid, options: Options) -> Result<()> {
+    unsafe {
+        ptrace_other(
+            Request::PTRACE_SEIZE,
+            pid,
+            ptr::null_mut(),
+            options.bits() as *mut c_void,
+        ).map(drop) // ignore the useless return value
+    }
+}
+
 /// Detaches the current running process, as with `ptrace(PTRACE_DETACH, ...)`
 ///
-/// Detaches from the process specified in pid allowing it to run freely
-pub fn detach(pid: Pid) -> Result<()> {
+/// Detaches from the process specified by `pid` allowing it to run freely, optionally delivering a
+/// signal specified by `sig`.
+pub fn detach<T: Into<Option<Signal>>>(pid: Pid, sig: T) -> Result<()> {
+    let data = match sig.into() {
+        Some(s) => s as i32 as *mut c_void,
+        None => ptr::null_mut(),
+    };
     unsafe {
         ptrace_other(
             Request::PTRACE_DETACH,
             pid,
             ptr::null_mut(),
-            ptr::null_mut()
+            data
         ).map(drop)
     }
 }
@@ -344,6 +384,16 @@ pub fn cont<T: Into<Option<Signal>>>(pid: Pid, sig: T) -> Result<()> {
     }
 }
 
+/// Stop a tracee, as with `ptrace(PTRACE_INTERRUPT, ...)`
+///
+/// This request is equivalent to `ptrace(PTRACE_INTERRUPT, ...)`
+#[cfg(target_os = "linux")]
+pub fn interrupt(pid: Pid) -> Result<()> {
+    unsafe {
+        ptrace_other(Request::PTRACE_INTERRUPT, pid, ptr::null_mut(), ptr::null_mut()).map(drop)
+    }
+}
+
 /// Issues a kill request as with `ptrace(PTRACE_KILL, ...)`
 ///
 /// This request is equivalent to `ptrace(PTRACE_CONT, ..., SIGKILL);`
@@ -353,7 +403,7 @@ pub fn kill(pid: Pid) -> Result<()> {
     }
 }
 
-/// Move the stopped tracee process forward by a single step as with 
+/// Move the stopped tracee process forward by a single step as with
 /// `ptrace(PTRACE_SINGLESTEP, ...)`
 ///
 /// Advances the execution of the process with PID `pid` by a single step optionally delivering a
@@ -361,21 +411,19 @@ pub fn kill(pid: Pid) -> Result<()> {
 ///
 /// # Example
 /// ```rust
-/// extern crate nix;
 /// use nix::sys::ptrace::step;
 /// use nix::unistd::Pid;
-/// use nix::sys::signal::Signal; 
+/// use nix::sys::signal::Signal;
 /// use nix::sys::wait::*;
-/// fn main() {
-///     // If a process changes state to the stopped state because of a SIGUSR1 
-///     // signal, this will step the process forward and forward the user 
-///     // signal to the stopped process
-///     match waitpid(Pid::from_raw(-1), None) {
-///         Ok(WaitStatus::Stopped(pid, Signal::SIGUSR1)) => {
-///             let _ = step(pid, Signal::SIGUSR1);
-///         }
-///         _ => {},
+///
+/// // If a process changes state to the stopped state because of a SIGUSR1
+/// // signal, this will step the process forward and forward the user
+/// // signal to the stopped process
+/// match waitpid(Pid::from_raw(-1), None) {
+///     Ok(WaitStatus::Stopped(pid, Signal::SIGUSR1)) => {
+///         let _ = step(pid, Signal::SIGUSR1);
 ///     }
+///     _ => {},
 /// }
 /// ```
 pub fn step<T: Into<Option<Signal>>>(pid: Pid, sig: T) -> Result<()> {
@@ -388,6 +436,28 @@ pub fn step<T: Into<Option<Signal>>>(pid: Pid, sig: T) -> Result<()> {
     }
 }
 
+/// Move the stopped tracee process forward by a single step or stop at the next syscall
+/// as with `ptrace(PTRACE_SYSEMU_SINGLESTEP, ...)`
+///
+/// Advances the execution by a single step or until the next syscall.
+/// In case the tracee is stopped at a syscall, the syscall will not be executed.
+/// Optionally, the signal specified by `sig` is delivered to the tracee upon continuation.
+#[cfg(all(target_os = "linux", target_env = "gnu", any(target_arch = "x86", target_arch = "x86_64")))]
+pub fn sysemu_step<T: Into<Option<Signal>>>(pid: Pid, sig: T) -> Result<()> {
+    let data = match sig.into() {
+        Some(s) => s as i32 as *mut c_void,
+        None => ptr::null_mut(),
+    };
+    unsafe {
+        ptrace_other(
+            Request::PTRACE_SYSEMU_SINGLESTEP,
+            pid,
+            ptr::null_mut(),
+            data,
+        )
+        .map(drop) // ignore the useless return value
+    }
+}
 
 /// Reads a word from a processes memory at the given address
 pub fn read(pid: Pid, addr: AddressType) -> Result<c_long> {
@@ -395,8 +465,15 @@ pub fn read(pid: Pid, addr: AddressType) -> Result<c_long> {
 }
 
 /// Writes a word into the processes memory at the given address
-pub fn write(pid: Pid, addr: AddressType, data: *mut c_void) -> Result<()> {
-    unsafe {
-        ptrace_other(Request::PTRACE_POKEDATA, pid, addr, data).map(drop)
-    }
+///
+/// # Safety
+///
+/// The `data` argument is passed directly to `ptrace(2)`.  Read that man page
+/// for guidance.
+pub unsafe fn write(
+    pid: Pid,
+    addr: AddressType,
+    data: *mut c_void) -> Result<()>
+{
+    ptrace_other(Request::PTRACE_POKEDATA, pid, addr, data).map(drop)
 }
diff --git a/third_party/rust/nix/src/sys/quota.rs b/third_party/rust/nix/src/sys/quota.rs
index 8946fca2213c8..6e34e38d2b720 100644
--- a/third_party/rust/nix/src/sys/quota.rs
+++ b/third_party/rust/nix/src/sys/quota.rs
@@ -15,12 +15,13 @@
 use std::default::Default;
 use std::{mem, ptr};
 use libc::{self, c_int, c_char};
-use {Result, NixPath};
-use errno::Errno;
+use crate::{Result, NixPath};
+use crate::errno::Errno;
 
 struct QuotaCmd(QuotaSubCmd, QuotaType);
 
 impl QuotaCmd {
+    #[allow(unused_unsafe)]
     fn as_int(&self) -> c_int {
         unsafe { libc::QCMD(self.0 as i32, self.1 as i32) }
     }
@@ -41,6 +42,7 @@ libc_enum!{
 libc_enum!{
     /// The scope of the quota.
     #[repr(i32)]
+    #[non_exhaustive]
     pub enum QuotaType {
         /// Specify a user quota
         USRQUOTA,
@@ -52,6 +54,7 @@ libc_enum!{
 libc_enum!{
     /// The type of quota format to use.
     #[repr(i32)]
+    #[non_exhaustive]
     pub enum QuotaFmt {
         /// Use the original quota format.
         QFMT_VFS_OLD,
@@ -94,8 +97,7 @@ libc_bitflags!(
 );
 
 /// Wrapper type for `if_dqblk`
-// FIXME: Change to repr(transparent)
-#[repr(C)]
+#[repr(transparent)]
 #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
 pub struct Dqblk(libc::dqblk);
 
@@ -254,15 +256,17 @@ pub fn quotactl_off<P: ?Sized + NixPath>(which: QuotaType, special: &P) -> Resul
 }
 
 /// Update the on-disk copy of quota usages for a filesystem.
+///
+/// If `special` is `None`, then all file systems with active quotas are sync'd.
 pub fn quotactl_sync<P: ?Sized + NixPath>(which: QuotaType, special: Option<&P>) -> Result<()> {
     quotactl(QuotaCmd(QuotaSubCmd::Q_SYNC, which), special, 0, ptr::null_mut())
 }
 
 /// Get disk quota limits and current usage for the given user/group id.
 pub fn quotactl_get<P: ?Sized + NixPath>(which: QuotaType, special: &P, id: c_int) -> Result<Dqblk> {
-    let mut dqblk = unsafe { mem::uninitialized() };
-    quotactl(QuotaCmd(QuotaSubCmd::Q_GETQUOTA, which), Some(special), id, &mut dqblk as *mut _ as *mut c_char)?;
-    dqblk
+    let mut dqblk = mem::MaybeUninit::uninit();
+    quotactl(QuotaCmd(QuotaSubCmd::Q_GETQUOTA, which), Some(special), id, dqblk.as_mut_ptr() as *mut c_char)?;
+    Ok(unsafe{ Dqblk(dqblk.assume_init())})
 }
 
 /// Configure quota values for the specified fields for a given user/group id.
diff --git a/third_party/rust/nix/src/sys/reboot.rs b/third_party/rust/nix/src/sys/reboot.rs
index bafa8fc11996d..46ab68b632062 100644
--- a/third_party/rust/nix/src/sys/reboot.rs
+++ b/third_party/rust/nix/src/sys/reboot.rs
@@ -1,9 +1,8 @@
 //! Reboot/shutdown or enable/disable Ctrl-Alt-Delete.
 
-use {Error, Result};
-use errno::Errno;
-use libc;
-use void::Void;
+use crate::Result;
+use crate::errno::Errno;
+use std::convert::Infallible;
 use std::mem::drop;
 
 libc_enum! {
@@ -12,6 +11,7 @@ libc_enum! {
     /// See [`set_cad_enabled()`](fn.set_cad_enabled.html) for
     /// enabling/disabling Ctrl-Alt-Delete.
     #[repr(i32)]
+    #[non_exhaustive]
     pub enum RebootMode {
         RB_HALT_SYSTEM,
         RB_KEXEC,
@@ -22,11 +22,11 @@ libc_enum! {
     }
 }
 
-pub fn reboot(how: RebootMode) -> Result<Void> {
+pub fn reboot(how: RebootMode) -> Result<Infallible> {
     unsafe {
         libc::reboot(how as libc::c_int)
     };
-    Err(Error::Sys(Errno::last()))
+    Err(Errno::last())
 }
 
 /// Enable or disable the reboot keystroke (Ctrl-Alt-Delete).
diff --git a/third_party/rust/nix/src/sys/resource.rs b/third_party/rust/nix/src/sys/resource.rs
new file mode 100644
index 0000000000000..f3bfb671943a8
--- /dev/null
+++ b/third_party/rust/nix/src/sys/resource.rs
@@ -0,0 +1,233 @@
+//! Configure the process resource limits.
+use cfg_if::cfg_if;
+
+use crate::errno::Errno;
+use crate::Result;
+pub use libc::rlim_t;
+use std::mem;
+
+cfg_if! {
+    if #[cfg(all(target_os = "linux", target_env = "gnu"))]{
+        use libc::{__rlimit_resource_t, rlimit, RLIM_INFINITY};
+    }else if #[cfg(any(
+        target_os = "freebsd",
+        target_os = "openbsd",
+        target_os = "netbsd",
+        target_os = "macos",
+        target_os = "ios",
+        target_os = "android",
+        target_os = "dragonfly",
+        all(target_os = "linux", not(target_env = "gnu"))
+    ))]{
+        use libc::{c_int, rlimit, RLIM_INFINITY};
+    }
+}
+
+libc_enum! {
+    /// The Resource enum is platform dependent. Check different platform
+    /// manuals for more details. Some platform links has been provided for
+    /// earier reference (non-exhaustive).
+    ///
+    /// * [Linux](https://man7.org/linux/man-pages/man2/getrlimit.2.html)
+    /// * [FreeBSD](https://www.freebsd.org/cgi/man.cgi?query=setrlimit)
+
+    // linux-gnu uses u_int as resource enum, which is implemented in libc as
+    // well.
+    //
+    // https://gcc.gnu.org/legacy-ml/gcc/2015-08/msg00441.html
+    // https://github.com/rust-lang/libc/blob/master/src/unix/linux_like/linux/gnu/mod.rs
+    #[cfg_attr(all(target_os = "linux", target_env = "gnu"), repr(u32))]
+    #[cfg_attr(any(
+            target_os = "freebsd",
+            target_os = "openbsd",
+            target_os = "netbsd",
+            target_os = "macos",
+            target_os = "ios",
+            target_os = "android",
+            target_os = "dragonfly",
+            all(target_os = "linux", not(target_env = "gnu"))
+        ), repr(i32))]
+    #[non_exhaustive]
+    pub enum Resource {
+        #[cfg(not(any(
+                    target_os = "freebsd",
+                    target_os = "netbsd",
+                    target_os = "openbsd"
+        )))]
+        /// The maximum amount (in bytes) of virtual memory the process is
+        /// allowed to map.
+        RLIMIT_AS,
+        /// The largest size (in bytes) core(5) file that may be created.
+        RLIMIT_CORE,
+        /// The maximum amount of cpu time (in seconds) to be used by each
+        /// process.
+        RLIMIT_CPU,
+        /// The maximum size (in bytes) of the data segment for a process
+        RLIMIT_DATA,
+        /// The largest size (in bytes) file that may be created.
+        RLIMIT_FSIZE,
+        /// The maximum number of open files for this process.
+        RLIMIT_NOFILE,
+        /// The maximum size (in bytes) of the stack segment for a process.
+        RLIMIT_STACK,
+
+        #[cfg(target_os = "freebsd")]
+        /// The maximum number of kqueues this user id is allowed to create.
+        RLIMIT_KQUEUES,
+
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        /// A limit on the combined number of flock locks and fcntl leases that
+        /// this process may establish.
+        RLIMIT_LOCKS,
+
+        #[cfg(any(target_os = "android", target_os = "freebsd", target_os = "openbsd", target_os = "linux"))]
+        /// The maximum size (in bytes) which a process may lock into memory
+        /// using the mlock(2) system call.
+        RLIMIT_MEMLOCK,
+
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        /// A limit on the number of bytes that can be allocated for POSIX
+        /// message queues  for  the  real  user  ID  of  the  calling process.
+        RLIMIT_MSGQUEUE,
+
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        /// A ceiling to which the process's nice value can be raised using
+        /// setpriority or nice.
+        RLIMIT_NICE,
+
+        #[cfg(any(target_os = "android", target_os = "freebsd", target_os = "openbsd", target_os = "linux"))]
+        /// The maximum number of simultaneous processes for this user id.
+        RLIMIT_NPROC,
+
+        #[cfg(target_os = "freebsd")]
+        /// The maximum number of pseudo-terminals this user id is allowed to
+        /// create.
+        RLIMIT_NPTS,
+
+        #[cfg(any(target_os = "android", target_os = "freebsd", target_os = "openbsd", target_os = "linux"))]
+        /// When there is memory pressure and swap is available, prioritize
+        /// eviction of a process' resident pages beyond this amount (in bytes).
+        RLIMIT_RSS,
+
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        /// A ceiling on the real-time priority that may be set for this process
+        /// using sched_setscheduler and  sched_set‐ param.
+        RLIMIT_RTPRIO,
+
+        #[cfg(any(target_os = "linux"))]
+        /// A limit (in microseconds) on the amount of CPU time that a process
+        /// scheduled under a real-time scheduling policy may con‐ sume without
+        /// making a blocking system call.
+        RLIMIT_RTTIME,
+
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        /// A limit on the number of signals that may be queued for the real
+        /// user ID of the  calling  process.
+        RLIMIT_SIGPENDING,
+
+        #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+        /// The maximum size (in bytes) of socket buffer usage for this user.
+        RLIMIT_SBSIZE,
+
+        #[cfg(target_os = "freebsd")]
+        /// The maximum size (in bytes) of the swap space that may be reserved
+        /// or used by all of this user id's processes.
+        RLIMIT_SWAP,
+
+        #[cfg(target_os = "freebsd")]
+        /// An alias for RLIMIT_AS.
+        RLIMIT_VMEM,
+    }
+}
+
+/// Get the current processes resource limits
+///
+/// A value of `None` indicates the value equals to `RLIM_INFINITY` which means
+/// there is no limit.
+///
+/// # Parameters
+///
+/// * `resource`: The [`Resource`] that we want to get the limits of.
+///
+/// # Examples
+///
+/// ```
+/// # use nix::sys::resource::{getrlimit, Resource};
+///
+/// let (soft_limit, hard_limit) = getrlimit(Resource::RLIMIT_NOFILE).unwrap();
+/// println!("current soft_limit: {:?}", soft_limit);
+/// println!("current hard_limit: {:?}", hard_limit);
+/// ```
+///
+/// # References
+///
+/// [getrlimit(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getrlimit.html#tag_16_215)
+///
+/// [`Resource`]: enum.Resource.html
+pub fn getrlimit(resource: Resource) -> Result<(Option<rlim_t>, Option<rlim_t>)> {
+    let mut old_rlim = mem::MaybeUninit::<rlimit>::uninit();
+
+    cfg_if! {
+        if #[cfg(all(target_os = "linux", target_env = "gnu"))]{
+            let res = unsafe { libc::getrlimit(resource as __rlimit_resource_t, old_rlim.as_mut_ptr()) };
+        }else{
+            let res = unsafe { libc::getrlimit(resource as c_int, old_rlim.as_mut_ptr()) };
+        }
+    }
+
+    Errno::result(res).map(|_| {
+        let rlimit { rlim_cur, rlim_max } = unsafe { old_rlim.assume_init() };
+        (Some(rlim_cur), Some(rlim_max))
+    })
+}
+
+/// Set the current processes resource limits
+///
+/// # Parameters
+///
+/// * `resource`: The [`Resource`] that we want to set the limits of.
+/// * `soft_limit`: The value that the kernel enforces for the corresponding
+///   resource. Note: `None` input will be replaced by constant `RLIM_INFINITY`.
+/// * `hard_limit`: The ceiling for the soft limit. Must be lower or equal to
+///   the current hard limit for non-root users. Note: `None` input will be
+///   replaced by constant `RLIM_INFINITY`.
+///
+/// > Note: for some os (linux_gnu), setting hard_limit to `RLIM_INFINITY` can
+/// > results `EPERM` Error. So you will need to set the number explicitly.
+///
+/// # Examples
+///
+/// ```
+/// # use nix::sys::resource::{setrlimit, Resource};
+///
+/// let soft_limit = Some(512);
+/// let hard_limit = Some(1024);
+/// setrlimit(Resource::RLIMIT_NOFILE, soft_limit, hard_limit).unwrap();
+/// ```
+///
+/// # References
+///
+/// [setrlimit(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getrlimit.html#tag_16_215)
+///
+/// [`Resource`]: enum.Resource.html
+///
+/// Note: `setrlimit` provides a safe wrapper to libc's `setrlimit`.
+pub fn setrlimit(
+    resource: Resource,
+    soft_limit: Option<rlim_t>,
+    hard_limit: Option<rlim_t>,
+) -> Result<()> {
+    let new_rlim = rlimit {
+        rlim_cur: soft_limit.unwrap_or(RLIM_INFINITY),
+        rlim_max: hard_limit.unwrap_or(RLIM_INFINITY),
+    };
+    cfg_if! {
+        if #[cfg(all(target_os = "linux", target_env = "gnu"))]{
+            let res = unsafe { libc::setrlimit(resource as __rlimit_resource_t, &new_rlim as *const rlimit) };
+        }else{
+            let res = unsafe { libc::setrlimit(resource as c_int, &new_rlim as *const rlimit) };
+        }
+    }
+
+    Errno::result(res).map(drop)
+}
diff --git a/third_party/rust/nix/src/sys/select.rs b/third_party/rust/nix/src/sys/select.rs
index 1b518e29f67a6..4d7576a58af95 100644
--- a/third_party/rust/nix/src/sys/select.rs
+++ b/third_party/rust/nix/src/sys/select.rs
@@ -1,38 +1,59 @@
+//! Portably monitor a group of file descriptors for readiness.
+use std::convert::TryFrom;
+use std::iter::FusedIterator;
 use std::mem;
+use std::ops::Range;
 use std::os::unix::io::RawFd;
 use std::ptr::{null, null_mut};
 use libc::{self, c_int};
-use Result;
-use errno::Errno;
-use sys::signal::SigSet;
-use sys::time::{TimeSpec, TimeVal};
+use crate::Result;
+use crate::errno::Errno;
+use crate::sys::signal::SigSet;
+use crate::sys::time::{TimeSpec, TimeVal};
 
 pub use libc::FD_SETSIZE;
 
-// FIXME: Change to repr(transparent) once it's stable
-#[repr(C)]
+/// Contains a set of file descriptors used by [`select`]
+#[repr(transparent)]
 #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
 pub struct FdSet(libc::fd_set);
 
+fn assert_fd_valid(fd: RawFd) {
+    assert!(
+        usize::try_from(fd).map_or(false, |fd| fd < FD_SETSIZE),
+        "fd must be in the range 0..FD_SETSIZE",
+    );
+}
+
 impl FdSet {
+    /// Create an empty `FdSet`
     pub fn new() -> FdSet {
-        let mut fdset = unsafe { mem::uninitialized() };
-        unsafe { libc::FD_ZERO(&mut fdset) };
-        FdSet(fdset)
+        let mut fdset = mem::MaybeUninit::uninit();
+        unsafe {
+            libc::FD_ZERO(fdset.as_mut_ptr());
+            FdSet(fdset.assume_init())
+        }
     }
 
+    /// Add a file descriptor to an `FdSet`
     pub fn insert(&mut self, fd: RawFd) {
+        assert_fd_valid(fd);
         unsafe { libc::FD_SET(fd, &mut self.0) };
     }
 
+    /// Remove a file descriptor from an `FdSet`
     pub fn remove(&mut self, fd: RawFd) {
+        assert_fd_valid(fd);
         unsafe { libc::FD_CLR(fd, &mut self.0) };
     }
 
-    pub fn contains(&mut self, fd: RawFd) -> bool {
-        unsafe { libc::FD_ISSET(fd, &mut self.0) }
+    /// Test an `FdSet` for the presence of a certain file descriptor.
+    pub fn contains(&self, fd: RawFd) -> bool {
+        assert_fd_valid(fd);
+        unsafe { libc::FD_ISSET(fd, &self.0) }
     }
 
+    /// Remove all file descriptors from this `FdSet`.
     pub fn clear(&mut self) {
         unsafe { libc::FD_ZERO(&mut self.0) };
     }
@@ -46,29 +67,90 @@ impl FdSet {
     /// # Example
     ///
     /// ```
-    /// # extern crate nix;
     /// # use nix::sys::select::FdSet;
-    /// # fn main() {
     /// let mut set = FdSet::new();
     /// set.insert(4);
     /// set.insert(9);
     /// assert_eq!(set.highest(), Some(9));
-    /// # }
     /// ```
     ///
     /// [`select`]: fn.select.html
-    pub fn highest(&mut self) -> Option<RawFd> {
-        for i in (0..FD_SETSIZE).rev() {
-            let i = i as RawFd;
-            if unsafe { libc::FD_ISSET(i, self as *mut _ as *mut libc::fd_set) } {
-                return Some(i)
+    pub fn highest(&self) -> Option<RawFd> {
+        self.fds(None).next_back()
+    }
+
+    /// Returns an iterator over the file descriptors in the set.
+    ///
+    /// For performance, it takes an optional higher bound: the iterator will
+    /// not return any elements of the set greater than the given file
+    /// descriptor.
+    ///
+    /// # Examples
+    ///
+    /// ```
+    /// # use nix::sys::select::FdSet;
+    /// # use std::os::unix::io::RawFd;
+    /// let mut set = FdSet::new();
+    /// set.insert(4);
+    /// set.insert(9);
+    /// let fds: Vec<RawFd> = set.fds(None).collect();
+    /// assert_eq!(fds, vec![4, 9]);
+    /// ```
+    #[inline]
+    pub fn fds(&self, highest: Option<RawFd>) -> Fds {
+        Fds {
+            set: self,
+            range: 0..highest.map(|h| h as usize + 1).unwrap_or(FD_SETSIZE),
+        }
+    }
+}
+
+impl Default for FdSet {
+    fn default() -> Self {
+        Self::new()
+    }
+}
+
+/// Iterator over `FdSet`.
+#[derive(Debug)]
+pub struct Fds<'a> {
+    set: &'a FdSet,
+    range: Range<usize>,
+}
+
+impl<'a> Iterator for Fds<'a> {
+    type Item = RawFd;
+
+    fn next(&mut self) -> Option<RawFd> {
+        for i in &mut self.range {
+            if self.set.contains(i as RawFd) {
+                return Some(i as RawFd);
             }
         }
+        None
+    }
+
+    #[inline]
+    fn size_hint(&self) -> (usize, Option<usize>) {
+        let (_, upper) = self.range.size_hint();
+        (0, upper)
+    }
+}
 
+impl<'a> DoubleEndedIterator for Fds<'a> {
+    #[inline]
+    fn next_back(&mut self) -> Option<RawFd> {
+        while let Some(i) = self.range.next_back() {
+            if self.set.contains(i as RawFd) {
+                return Some(i as RawFd);
+            }
+        }
         None
     }
 }
 
+impl<'a> FusedIterator for Fds<'a> {}
+
 /// Monitors file descriptors for readiness
 ///
 /// Returns the total number of ready file descriptors in all sets. The sets are changed so that all
@@ -89,13 +171,13 @@ impl FdSet {
 ///
 /// # References
 ///
-/// [select(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/select.html)
+/// [select(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/select.html)
 ///
 /// [`FdSet::highest`]: struct.FdSet.html#method.highest
 pub fn select<'a, N, R, W, E, T>(nfds: N,
-                                 readfds: R,
-                                 writefds: W,
-                                 errorfds: E,
+    readfds: R,
+    writefds: W,
+    errorfds: E,
                                  timeout: T) -> Result<c_int>
 where
     N: Into<Option<c_int>>,
@@ -122,7 +204,7 @@ where
     let writefds = writefds.map(|set| set as *mut _ as *mut libc::fd_set).unwrap_or(null_mut());
     let errorfds = errorfds.map(|set| set as *mut _ as *mut libc::fd_set).unwrap_or(null_mut());
     let timeout = timeout.map(|tv| tv as *mut _ as *mut libc::timeval)
-                         .unwrap_or(null_mut());
+        .unwrap_or(null_mut());
 
     let res = unsafe {
         libc::select(nfds, readfds, writefds, errorfds, timeout)
@@ -155,16 +237,16 @@ where
 ///
 /// # References
 ///
-/// [pselect(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/pselect.html)
+/// [pselect(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pselect.html)
 ///
 /// [The new pselect() system call](https://lwn.net/Articles/176911/)
 ///
 /// [`FdSet::highest`]: struct.FdSet.html#method.highest
 pub fn pselect<'a, N, R, W, E, T, S>(nfds: N,
-                                     readfds: R,
-                                     writefds: W,
-                                     errorfds: E,
-                                     timeout: T,
+    readfds: R,
+    writefds: W,
+    errorfds: E,
+    timeout: T,
                                      sigmask: S) -> Result<c_int>
 where
     N: Into<Option<c_int>>,
@@ -207,8 +289,8 @@ where
 mod tests {
     use super::*;
     use std::os::unix::io::RawFd;
-    use sys::time::{TimeVal, TimeValLike};
-    use unistd::{write, pipe};
+    use crate::sys::time::{TimeVal, TimeValLike};
+    use crate::unistd::{write, pipe};
 
     #[test]
     fn fdset_insert() {
@@ -272,6 +354,20 @@ mod tests {
         assert_eq!(set.highest(), Some(7));
     }
 
+    #[test]
+    fn fdset_fds() {
+        let mut set = FdSet::new();
+        assert_eq!(set.fds(None).collect::<Vec<_>>(), vec![]);
+        set.insert(0);
+        assert_eq!(set.fds(None).collect::<Vec<_>>(), vec![0]);
+        set.insert(90);
+        assert_eq!(set.fds(None).collect::<Vec<_>>(), vec![0, 90]);
+
+        // highest limit
+        assert_eq!(set.fds(Some(89)).collect::<Vec<_>>(), vec![0]);
+        assert_eq!(set.fds(Some(90)).collect::<Vec<_>>(), vec![0, 90]);
+    }
+
     #[test]
     fn test_select() {
         let (r1, w1) = pipe().unwrap();
@@ -304,9 +400,9 @@ mod tests {
 
         let mut timeout = TimeVal::seconds(10);
         assert_eq!(1, select(Some(fd_set.highest().unwrap() + 1),
-                             &mut fd_set,
-                             None,
-                             None,
+                &mut fd_set,
+                None,
+                None,
                              &mut timeout).unwrap());
         assert!(fd_set.contains(r1));
         assert!(!fd_set.contains(r2));
@@ -324,9 +420,9 @@ mod tests {
 
         let mut timeout = TimeVal::seconds(10);
         assert_eq!(1, select(::std::cmp::max(r1, r2) + 1,
-                             &mut fd_set,
-                             None,
-                             None,
+                &mut fd_set,
+                None,
+                None,
                              &mut timeout).unwrap());
         assert!(fd_set.contains(r1));
         assert!(!fd_set.contains(r2));
diff --git a/third_party/rust/nix/src/sys/sendfile.rs b/third_party/rust/nix/src/sys/sendfile.rs
index a47d8962f73fb..7a210c6fc32fa 100644
--- a/third_party/rust/nix/src/sys/sendfile.rs
+++ b/third_party/rust/nix/src/sys/sendfile.rs
@@ -1,10 +1,13 @@
+//! Send data from a file to a socket, bypassing userland.
+
+use cfg_if::cfg_if;
 use std::os::unix::io::RawFd;
 use std::ptr;
 
 use libc::{self, off_t};
 
-use Result;
-use errno::Errno;
+use crate::Result;
+use crate::errno::Errno;
 
 /// Copy up to `count` bytes to `out_fd` from `in_fd` starting at `offset`.
 ///
@@ -17,7 +20,7 @@ use errno::Errno;
 ///
 /// `in_fd` must support `mmap`-like operations and therefore cannot be a socket.
 ///
-/// For more information, see [the sendfile(2) man page.](http://man7.org/linux/man-pages/man2/sendfile.2.html)
+/// For more information, see [the sendfile(2) man page.](https://man7.org/linux/man-pages/man2/sendfile.2.html)
 #[cfg(any(target_os = "android", target_os = "linux"))]
 pub fn sendfile(
     out_fd: RawFd,
@@ -32,11 +35,37 @@ pub fn sendfile(
     Errno::result(ret).map(|r| r as usize)
 }
 
+/// Copy up to `count` bytes to `out_fd` from `in_fd` starting at `offset`.
+///
+/// Returns a `Result` with the number of bytes written.
+///
+/// If `offset` is `None`, `sendfile` will begin reading at the current offset of `in_fd`and will
+/// update the offset of `in_fd`. If `offset` is `Some`, `sendfile` will begin at the specified
+/// offset and will not update the offset of `in_fd`. Instead, it will mutate `offset` to point to
+/// the byte after the last byte copied.
+///
+/// `in_fd` must support `mmap`-like operations and therefore cannot be a socket.
+///
+/// For more information, see [the sendfile(2) man page.](https://man7.org/linux/man-pages/man2/sendfile.2.html)
+#[cfg(target_os = "linux")]
+pub fn sendfile64(
+    out_fd: RawFd,
+    in_fd: RawFd,
+    offset: Option<&mut libc::off64_t>,
+    count: usize,
+) -> Result<usize> {
+    let offset = offset
+        .map(|offset| offset as *mut _)
+        .unwrap_or(ptr::null_mut());
+    let ret = unsafe { libc::sendfile64(out_fd, in_fd, offset, count) };
+    Errno::result(ret).map(|r| r as usize)
+}
+
 cfg_if! {
     if #[cfg(any(target_os = "freebsd",
                  target_os = "ios",
                  target_os = "macos"))] {
-        use sys::uio::IoVec;
+        use crate::sys::uio::IoVec;
 
         #[derive(Clone, Debug, Eq, Hash, PartialEq)]
         struct SendfileHeaderTrailer<'a>(
@@ -123,6 +152,7 @@ cfg_if! {
         ///
         /// For more information, see
         /// [the sendfile(2) man page.](https://www.freebsd.org/cgi/man.cgi?query=sendfile&sektion=2)
+        #[allow(clippy::too_many_arguments)]
         pub fn sendfile(
             in_fd: RawFd,
             out_sock: RawFd,
@@ -136,7 +166,8 @@ cfg_if! {
             // Readahead goes in upper 16 bits
             // Flags goes in lower 16 bits
             // see `man 2 sendfile`
-            let flags: u32 = ((readahead as u32) << 16) | (flags.bits() as u32);
+            let ra32 = u32::from(readahead);
+            let flags: u32 = (ra32 << 16) | (flags.bits() as u32);
             let mut bytes_sent: off_t = 0;
             let hdtr = headers.or(trailers).map(|_| SendfileHeaderTrailer::new(headers, trailers));
             let hdtr_ptr = hdtr.as_ref().map_or(ptr::null(), |s| &s.0 as *const libc::sf_hdtr);
diff --git a/third_party/rust/nix/src/sys/signal.rs b/third_party/rust/nix/src/sys/signal.rs
index 1013a77fd4b40..61bdc74aef1aa 100644
--- a/third_party/rust/nix/src/sys/signal.rs
+++ b/third_party/rust/nix/src/sys/signal.rs
@@ -1,11 +1,11 @@
 // Portions of this file are Copyright 2014 The Rust Project Developers.
-// See http://rust-lang.org/COPYRIGHT.
+// See https://www.rust-lang.org/policies/licenses.
 
-///! Operating system signals.
+//! Operating system signals.
 
-use libc;
-use {Error, Result};
-use errno::Errno;
+use crate::{Error, Result};
+use crate::errno::Errno;
+use crate::unistd::Pid;
 use std::mem;
 use std::fmt;
 use std::str::FromStr;
@@ -13,55 +13,98 @@ use std::str::FromStr;
 use std::os::unix::io::RawFd;
 use std::ptr;
 
-#[cfg(not(target_os = "openbsd"))]
+#[cfg(not(any(target_os = "openbsd", target_os = "redox")))]
 pub use self::sigevent::*;
 
 libc_enum!{
+    /// Types of operating system signals
     // Currently there is only one definition of c_int in libc, as well as only one
     // type for signal constants.
     // We would prefer to use the libc::c_int alias in the repr attribute. Unfortunately
     // this is not (yet) possible.
     #[repr(i32)]
+    #[non_exhaustive]
     pub enum Signal {
+        /// Hangup
         SIGHUP,
+        /// Interrupt
         SIGINT,
+        /// Quit
         SIGQUIT,
+        /// Illegal instruction (not reset when caught)
         SIGILL,
+        /// Trace trap (not reset when caught)
         SIGTRAP,
+        /// Abort
         SIGABRT,
+        /// Bus error
         SIGBUS,
+        /// Floating point exception
         SIGFPE,
+        /// Kill (cannot be caught or ignored)
         SIGKILL,
+        /// User defined signal 1
         SIGUSR1,
+        /// Segmentation violation
         SIGSEGV,
+        /// User defined signal 2
         SIGUSR2,
+        /// Write on a pipe with no one to read it
         SIGPIPE,
+        /// Alarm clock
         SIGALRM,
+        /// Software termination signal from kill
         SIGTERM,
-        #[cfg(all(any(target_os = "android", target_os = "emscripten", target_os = "linux"),
-                  not(any(target_arch = "mips", target_arch = "mips64", target_arch = "sparc64"))))]
+        /// Stack fault (obsolete)
+        #[cfg(all(any(target_os = "android", target_os = "emscripten",
+                      target_os = "fuchsia", target_os = "linux"),
+                  not(any(target_arch = "mips", target_arch = "mips64",
+                          target_arch = "sparc64"))))]
         SIGSTKFLT,
+        /// To parent on child stop or exit
         SIGCHLD,
+        /// Continue a stopped process
         SIGCONT,
+        /// Sendable stop signal not from tty
         SIGSTOP,
+        /// Stop signal from tty
         SIGTSTP,
+        /// To readers pgrp upon background tty read
         SIGTTIN,
+        /// Like TTIN if (tp->t_local&LTOSTOP)
         SIGTTOU,
+        /// Urgent condition on IO channel
         SIGURG,
+        /// Exceeded CPU time limit
         SIGXCPU,
+        /// Exceeded file size limit
         SIGXFSZ,
+        /// Virtual time alarm
         SIGVTALRM,
+        /// Profiling time alarm
         SIGPROF,
+        /// Window size changes
         SIGWINCH,
+        /// Input/output possible signal
         SIGIO,
-        #[cfg(any(target_os = "android", target_os = "emscripten", target_os = "linux"))]
+        #[cfg(any(target_os = "android", target_os = "emscripten",
+                  target_os = "fuchsia", target_os = "linux"))]
+        /// Power failure imminent.
         SIGPWR,
+        /// Bad system call
         SIGSYS,
-        #[cfg(not(any(target_os = "android", target_os = "emscripten", target_os = "linux")))]
+        #[cfg(not(any(target_os = "android", target_os = "emscripten",
+                      target_os = "fuchsia", target_os = "linux",
+                      target_os = "redox")))]
+        /// Emulator trap
         SIGEMT,
-        #[cfg(not(any(target_os = "android", target_os = "emscripten", target_os = "linux")))]
+        #[cfg(not(any(target_os = "android", target_os = "emscripten",
+                      target_os = "fuchsia", target_os = "linux",
+                      target_os = "redox")))]
+        /// Information request
         SIGINFO,
     }
+    impl TryFrom<i32>
 }
 
 impl FromStr for Signal {
@@ -83,8 +126,10 @@ impl FromStr for Signal {
             "SIGPIPE" => Signal::SIGPIPE,
             "SIGALRM" => Signal::SIGALRM,
             "SIGTERM" => Signal::SIGTERM,
-            #[cfg(all(any(target_os = "android", target_os = "emscripten", target_os = "linux"),
-                      not(any(target_arch = "mips", target_arch = "mips64", target_arch = "sparc64"))))]
+            #[cfg(all(any(target_os = "android", target_os = "emscripten",
+                          target_os = "fuchsia", target_os = "linux"),
+                      not(any(target_arch = "mips", target_arch = "mips64",
+                              target_arch = "sparc64"))))]
             "SIGSTKFLT" => Signal::SIGSTKFLT,
             "SIGCHLD" => Signal::SIGCHLD,
             "SIGCONT" => Signal::SIGCONT,
@@ -99,21 +144,31 @@ impl FromStr for Signal {
             "SIGPROF" => Signal::SIGPROF,
             "SIGWINCH" => Signal::SIGWINCH,
             "SIGIO" => Signal::SIGIO,
-            #[cfg(any(target_os = "android", target_os = "emscripten", target_os = "linux"))]
+            #[cfg(any(target_os = "android", target_os = "emscripten",
+                      target_os = "fuchsia", target_os = "linux"))]
             "SIGPWR" => Signal::SIGPWR,
             "SIGSYS" => Signal::SIGSYS,
-            #[cfg(not(any(target_os = "android", target_os = "emscripten", target_os = "linux")))]
+            #[cfg(not(any(target_os = "android", target_os = "emscripten",
+                          target_os = "fuchsia", target_os = "linux",
+                          target_os = "redox")))]
             "SIGEMT" => Signal::SIGEMT,
-            #[cfg(not(any(target_os = "android", target_os = "emscripten", target_os = "linux")))]
+            #[cfg(not(any(target_os = "android", target_os = "emscripten",
+                          target_os = "fuchsia", target_os = "linux",
+                          target_os = "redox")))]
             "SIGINFO" => Signal::SIGINFO,
-            _ => return Err(Error::invalid_argument()),
+            _ => return Err(Errno::EINVAL),
         })
     }
 }
 
-impl AsRef<str> for Signal {
-    fn as_ref(&self) -> &str {
-        match *self {
+impl Signal {
+    /// Returns name of signal.
+    ///
+    /// This function is equivalent to `<Signal as AsRef<str>>::as_ref()`,
+    /// with difference that returned string is `'static`
+    /// and not bound to `self`'s lifetime.
+    pub const fn as_str(self) -> &'static str {
+        match self {
             Signal::SIGHUP => "SIGHUP",
             Signal::SIGINT => "SIGINT",
             Signal::SIGQUIT => "SIGQUIT",
@@ -129,7 +184,8 @@ impl AsRef<str> for Signal {
             Signal::SIGPIPE => "SIGPIPE",
             Signal::SIGALRM => "SIGALRM",
             Signal::SIGTERM => "SIGTERM",
-            #[cfg(all(any(target_os = "android", target_os = "emscripten", target_os = "linux"),
+            #[cfg(all(any(target_os = "android", target_os = "emscripten",
+                          target_os = "fuchsia", target_os = "linux"),
                       not(any(target_arch = "mips", target_arch = "mips64", target_arch = "sparc64"))))]
             Signal::SIGSTKFLT => "SIGSTKFLT",
             Signal::SIGCHLD => "SIGCHLD",
@@ -145,17 +201,28 @@ impl AsRef<str> for Signal {
             Signal::SIGPROF => "SIGPROF",
             Signal::SIGWINCH => "SIGWINCH",
             Signal::SIGIO => "SIGIO",
-            #[cfg(any(target_os = "android", target_os = "emscripten", target_os = "linux"))]
+            #[cfg(any(target_os = "android", target_os = "emscripten",
+                      target_os = "fuchsia", target_os = "linux"))]
             Signal::SIGPWR => "SIGPWR",
             Signal::SIGSYS => "SIGSYS",
-            #[cfg(not(any(target_os = "android", target_os = "emscripten", target_os = "linux")))]
+            #[cfg(not(any(target_os = "android", target_os = "emscripten",
+                          target_os = "fuchsia", target_os = "linux",
+                          target_os = "redox")))]
             Signal::SIGEMT => "SIGEMT",
-            #[cfg(not(any(target_os = "android", target_os = "emscripten", target_os = "linux")))]
+            #[cfg(not(any(target_os = "android", target_os = "emscripten",
+                          target_os = "fuchsia", target_os = "linux",
+                          target_os = "redox")))]
             Signal::SIGINFO => "SIGINFO",
         }
     }
 }
 
+impl AsRef<str> for Signal {
+    fn as_ref(&self) -> &str {
+        self.as_str()
+    }
+}
+
 impl fmt::Display for Signal {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         f.write_str(self.as_ref())
@@ -164,7 +231,41 @@ impl fmt::Display for Signal {
 
 pub use self::Signal::*;
 
-#[cfg(all(any(target_os = "linux", target_os = "android", target_os = "emscripten"), not(any(target_arch = "mips", target_arch = "mips64", target_arch = "sparc64"))))]
+#[cfg(target_os = "redox")]
+const SIGNALS: [Signal; 29] = [
+    SIGHUP,
+    SIGINT,
+    SIGQUIT,
+    SIGILL,
+    SIGTRAP,
+    SIGABRT,
+    SIGBUS,
+    SIGFPE,
+    SIGKILL,
+    SIGUSR1,
+    SIGSEGV,
+    SIGUSR2,
+    SIGPIPE,
+    SIGALRM,
+    SIGTERM,
+    SIGCHLD,
+    SIGCONT,
+    SIGSTOP,
+    SIGTSTP,
+    SIGTTIN,
+    SIGTTOU,
+    SIGURG,
+    SIGXCPU,
+    SIGXFSZ,
+    SIGVTALRM,
+    SIGPROF,
+    SIGWINCH,
+    SIGIO,
+    SIGSYS];
+#[cfg(all(any(target_os = "linux", target_os = "android",
+              target_os = "emscripten", target_os = "fuchsia"),
+          not(any(target_arch = "mips", target_arch = "mips64",
+                  target_arch = "sparc64"))))]
 const SIGNALS: [Signal; 31] = [
     SIGHUP,
     SIGINT,
@@ -197,7 +298,10 @@ const SIGNALS: [Signal; 31] = [
     SIGIO,
     SIGPWR,
     SIGSYS];
-#[cfg(all(any(target_os = "linux", target_os = "android", target_os = "emscripten"), any(target_arch = "mips", target_arch = "mips64", target_arch = "sparc64")))]
+#[cfg(all(any(target_os = "linux", target_os = "android",
+              target_os = "emscripten", target_os = "fuchsia"),
+          any(target_arch = "mips", target_arch = "mips64",
+              target_arch = "sparc64")))]
 const SIGNALS: [Signal; 30] = [
     SIGHUP,
     SIGINT,
@@ -229,7 +333,9 @@ const SIGNALS: [Signal; 30] = [
     SIGIO,
     SIGPWR,
     SIGSYS];
-#[cfg(not(any(target_os = "linux", target_os = "android", target_os = "emscripten")))]
+#[cfg(not(any(target_os = "linux", target_os = "android",
+              target_os = "fuchsia", target_os = "emscripten",
+              target_os = "redox")))]
 const SIGNALS: [Signal; 31] = [
     SIGHUP,
     SIGINT,
@@ -263,9 +369,8 @@ const SIGNALS: [Signal; 31] = [
     SIGEMT,
     SIGINFO];
 
-pub const NSIG: libc::c_int = 32;
-
 #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+/// Iterate through all signals defined by this operating system
 pub struct SignalIterator {
     next: usize,
 }
@@ -285,48 +390,67 @@ impl Iterator for SignalIterator {
 }
 
 impl Signal {
-    pub fn iterator() -> SignalIterator {
+    /// Iterate through all signals defined by this OS
+    pub const fn iterator() -> SignalIterator {
         SignalIterator{next: 0}
     }
-
-    // We do not implement the From trait, because it is supposed to be infallible.
-    // With Rust RFC 1542 comes the appropriate trait TryFrom. Once it is
-    // implemented, we'll replace this function.
-    #[inline]
-    pub fn from_c_int(signum: libc::c_int) -> Result<Signal> {
-        if 0 < signum && signum < NSIG {
-            Ok(unsafe { mem::transmute(signum) })
-        } else {
-            Err(Error::invalid_argument())
-        }
-    }
 }
 
+/// Alias for [`SIGABRT`]
 pub const SIGIOT : Signal = SIGABRT;
+/// Alias for [`SIGIO`]
 pub const SIGPOLL : Signal = SIGIO;
+/// Alias for [`SIGSYS`]
 pub const SIGUNUSED : Signal = SIGSYS;
 
+#[cfg(not(target_os = "redox"))]
+type SaFlags_t = libc::c_int;
+#[cfg(target_os = "redox")]
+type SaFlags_t = libc::c_ulong;
+
 libc_bitflags!{
-    pub struct SaFlags: libc::c_int {
+    /// Controls the behavior of a [`SigAction`]
+    pub struct SaFlags: SaFlags_t {
+        /// When catching a [`Signal::SIGCHLD`] signal, the signal will be
+        /// generated only when a child process exits, not when a child process
+        /// stops.
         SA_NOCLDSTOP;
+        /// When catching a [`Signal::SIGCHLD`] signal, the system will not
+        /// create zombie processes when children of the calling process exit.
         SA_NOCLDWAIT;
+        /// Further occurrences of the delivered signal are not masked during
+        /// the execution of the handler.
         SA_NODEFER;
+        /// The system will deliver the signal to the process on a signal stack,
+        /// specified by each thread with sigaltstack(2).
         SA_ONSTACK;
+        /// The handler is reset back to the default at the moment the signal is
+        /// delivered.
         SA_RESETHAND;
+        /// Requests that certain system calls restart if interrupted by this
+        /// signal.  See the man page for complete details.
         SA_RESTART;
+        /// This flag is controlled internally by Nix.
         SA_SIGINFO;
     }
 }
 
 libc_enum! {
+    /// Specifies how certain functions should manipulate a signal mask
     #[repr(i32)]
+    #[non_exhaustive]
     pub enum SigmaskHow {
+        /// The new mask is the union of the current mask and the specified set.
         SIG_BLOCK,
+        /// The new mask is the intersection of the current mask and the
+        /// complement of the specified set.
         SIG_UNBLOCK,
+        /// The current mask is replaced by the specified set.
         SIG_SETMASK,
     }
 }
 
+/// Specifies a set of [`Signal`]s that may be blocked, waited for, etc.
 #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
 pub struct SigSet {
     sigset: libc::sigset_t
@@ -334,32 +458,38 @@ pub struct SigSet {
 
 
 impl SigSet {
+    /// Initialize to include all signals.
     pub fn all() -> SigSet {
-        let mut sigset: libc::sigset_t = unsafe { mem::uninitialized() };
-        let _ = unsafe { libc::sigfillset(&mut sigset as *mut libc::sigset_t) };
+        let mut sigset = mem::MaybeUninit::uninit();
+        let _ = unsafe { libc::sigfillset(sigset.as_mut_ptr()) };
 
-        SigSet { sigset: sigset }
+        unsafe{ SigSet { sigset: sigset.assume_init() } }
     }
 
+    /// Initialize to include nothing.
     pub fn empty() -> SigSet {
-        let mut sigset: libc::sigset_t = unsafe { mem::uninitialized() };
-        let _ = unsafe { libc::sigemptyset(&mut sigset as *mut libc::sigset_t) };
+        let mut sigset = mem::MaybeUninit::uninit();
+        let _ = unsafe { libc::sigemptyset(sigset.as_mut_ptr()) };
 
-        SigSet { sigset: sigset }
+        unsafe{ SigSet { sigset: sigset.assume_init() } }
     }
 
+    /// Add the specified signal to the set.
     pub fn add(&mut self, signal: Signal) {
         unsafe { libc::sigaddset(&mut self.sigset as *mut libc::sigset_t, signal as libc::c_int) };
     }
 
+    /// Remove all signals from this set.
     pub fn clear(&mut self) {
         unsafe { libc::sigemptyset(&mut self.sigset as *mut libc::sigset_t) };
     }
 
+    /// Remove the specified signal from this set.
     pub fn remove(&mut self, signal: Signal) {
         unsafe { libc::sigdelset(&mut self.sigset as *mut libc::sigset_t, signal as libc::c_int) };
     }
 
+    /// Return whether this set includes the specified signal.
     pub fn contains(&self, signal: Signal) -> bool {
         let res = unsafe { libc::sigismember(&self.sigset as *const libc::sigset_t, signal as libc::c_int) };
 
@@ -370,6 +500,8 @@ impl SigSet {
         }
     }
 
+    /// Merge all of `other`'s signals into this set.
+    // TODO: use libc::sigorset on supported operating systems.
     pub fn extend(&mut self, other: &SigSet) {
         for signal in Signal::iterator() {
             if other.contains(signal) {
@@ -380,9 +512,9 @@ impl SigSet {
 
     /// Gets the currently blocked (masked) set of signals for the calling thread.
     pub fn thread_get_mask() -> Result<SigSet> {
-        let mut oldmask: SigSet = unsafe { mem::uninitialized() };
-        pthread_sigmask(SigmaskHow::SIG_SETMASK, None, Some(&mut oldmask))?;
-        Ok(oldmask)
+        let mut oldmask = mem::MaybeUninit::uninit();
+        do_pthread_sigmask(SigmaskHow::SIG_SETMASK, None, Some(oldmask.as_mut_ptr()))?;
+        Ok(unsafe{ SigSet{sigset: oldmask.assume_init()}})
     }
 
     /// Sets the set of signals as the signal mask for the calling thread.
@@ -402,18 +534,23 @@ impl SigSet {
 
     /// Sets the set of signals as the signal mask, and returns the old mask.
     pub fn thread_swap_mask(&self, how: SigmaskHow) -> Result<SigSet> {
-        let mut oldmask: SigSet = unsafe { mem::uninitialized() };
-        pthread_sigmask(how, Some(self), Some(&mut oldmask))?;
-        Ok(oldmask)
+        let mut oldmask = mem::MaybeUninit::uninit();
+        do_pthread_sigmask(how, Some(self), Some(oldmask.as_mut_ptr()))?;
+        Ok(unsafe{ SigSet{sigset: oldmask.assume_init()}})
     }
 
     /// Suspends execution of the calling thread until one of the signals in the
     /// signal mask becomes pending, and returns the accepted signal.
+    #[cfg(not(target_os = "redox"))] // RedoxFS does not yet support sigwait
     pub fn wait(&self) -> Result<Signal> {
-        let mut signum: libc::c_int = unsafe { mem::uninitialized() };
-        let res = unsafe { libc::sigwait(&self.sigset as *const libc::sigset_t, &mut signum) };
+        use std::convert::TryFrom;
+
+        let mut signum = mem::MaybeUninit::uninit();
+        let res = unsafe { libc::sigwait(&self.sigset as *const libc::sigset_t, signum.as_mut_ptr()) };
 
-        Errno::result(res).map(|_| Signal::from_c_int(signum).unwrap())
+        Errno::result(res).map(|_| unsafe {
+            Signal::try_from(signum.assume_init()).unwrap()
+        })
     }
 }
 
@@ -435,6 +572,7 @@ pub enum SigHandler {
     Handler(extern fn(libc::c_int)),
     /// Use the given signal-catching function, which takes in the signal, information about how
     /// the signal was generated, and a pointer to the threads `ucontext_t`.
+    #[cfg(not(target_os = "redox"))]
     SigAction(extern fn(libc::c_int, *mut libc::siginfo_t, *mut libc::c_void))
 }
 
@@ -451,20 +589,38 @@ impl SigAction {
     /// is the `SigAction` variant). `mask` specifies other signals to block during execution of
     /// the signal-catching function.
     pub fn new(handler: SigHandler, flags: SaFlags, mask: SigSet) -> SigAction {
-        let mut s = unsafe { mem::uninitialized::<libc::sigaction>() };
-        s.sa_sigaction = match handler {
-            SigHandler::SigDfl => libc::SIG_DFL,
-            SigHandler::SigIgn => libc::SIG_IGN,
-            SigHandler::Handler(f) => f as *const extern fn(libc::c_int) as usize,
-            SigHandler::SigAction(f) => f as *const extern fn(libc::c_int, *mut libc::siginfo_t, *mut libc::c_void) as usize,
-        };
-        s.sa_flags = match handler {
-            SigHandler::SigAction(_) => (flags | SaFlags::SA_SIGINFO).bits(),
-            _ => (flags - SaFlags::SA_SIGINFO).bits(),
-        };
-        s.sa_mask = mask.sigset;
-
-        SigAction { sigaction: s }
+        #[cfg(target_os = "redox")]
+        unsafe fn install_sig(p: *mut libc::sigaction, handler: SigHandler) {
+            (*p).sa_handler = match handler {
+                SigHandler::SigDfl => libc::SIG_DFL,
+                SigHandler::SigIgn => libc::SIG_IGN,
+                SigHandler::Handler(f) => f as *const extern fn(libc::c_int) as usize,
+            };
+        }
+
+        #[cfg(not(target_os = "redox"))]
+        unsafe fn install_sig(p: *mut libc::sigaction, handler: SigHandler) {
+            (*p).sa_sigaction = match handler {
+                SigHandler::SigDfl => libc::SIG_DFL,
+                SigHandler::SigIgn => libc::SIG_IGN,
+                SigHandler::Handler(f) => f as *const extern fn(libc::c_int) as usize,
+                SigHandler::SigAction(f) => f as *const extern fn(libc::c_int, *mut libc::siginfo_t, *mut libc::c_void) as usize,
+            };
+        }
+
+        let mut s = mem::MaybeUninit::<libc::sigaction>::uninit();
+        unsafe {
+            let p = s.as_mut_ptr();
+            install_sig(p, handler);
+            (*p).sa_flags = match handler {
+                #[cfg(not(target_os = "redox"))]
+                SigHandler::SigAction(_) => (flags | SaFlags::SA_SIGINFO).bits(),
+                _ => (flags - SaFlags::SA_SIGINFO).bits(),
+            };
+            (*p).sa_mask = mask.sigset;
+
+            SigAction { sigaction: s.assume_init() }
+        }
     }
 
     /// Returns the flags set on the action.
@@ -479,13 +635,57 @@ impl SigAction {
     }
 
     /// Returns the action's handler.
+    #[cfg(not(target_os = "redox"))]
     pub fn handler(&self) -> SigHandler {
         match self.sigaction.sa_sigaction {
             libc::SIG_DFL => SigHandler::SigDfl,
             libc::SIG_IGN => SigHandler::SigIgn,
-            f if self.flags().contains(SaFlags::SA_SIGINFO) =>
-                SigHandler::SigAction( unsafe { mem::transmute(f) } ),
-            f => SigHandler::Handler( unsafe { mem::transmute(f) } ),
+            p if self.flags().contains(SaFlags::SA_SIGINFO) =>
+                SigHandler::SigAction(
+                // Safe for one of two reasons:
+                // * The SigHandler was created by SigHandler::new, in which
+                //   case the pointer is correct, or
+                // * The SigHandler was created by signal or sigaction, which
+                //   are unsafe functions, so the caller should've somehow
+                //   ensured that it is correctly initialized.
+                unsafe{
+                    *(&p as *const usize
+                         as *const extern fn(_, _, _))
+                }
+                as extern fn(_, _, _)),
+            p => SigHandler::Handler(
+                // Safe for one of two reasons:
+                // * The SigHandler was created by SigHandler::new, in which
+                //   case the pointer is correct, or
+                // * The SigHandler was created by signal or sigaction, which
+                //   are unsafe functions, so the caller should've somehow
+                //   ensured that it is correctly initialized.
+                unsafe{
+                    *(&p as *const usize
+                         as *const extern fn(libc::c_int))
+                }
+                as extern fn(libc::c_int)),
+        }
+    }
+
+    /// Returns the action's handler.
+    #[cfg(target_os = "redox")]
+    pub fn handler(&self) -> SigHandler {
+        match self.sigaction.sa_handler {
+            libc::SIG_DFL => SigHandler::SigDfl,
+            libc::SIG_IGN => SigHandler::SigIgn,
+            p => SigHandler::Handler(
+                // Safe for one of two reasons:
+                // * The SigHandler was created by SigHandler::new, in which
+                //   case the pointer is correct, or
+                // * The SigHandler was created by signal or sigaction, which
+                //   are unsafe functions, so the caller should've somehow
+                //   ensured that it is correctly initialized.
+                unsafe{
+                    *(&p as *const usize
+                         as *const extern fn(libc::c_int))
+                }
+                as extern fn(libc::c_int)),
         }
     }
 }
@@ -497,19 +697,27 @@ impl SigAction {
 ///
 /// # Safety
 ///
-/// Signal handlers may be called at any point during execution, which limits what is safe to do in
-/// the body of the signal-catching function. Be certain to only make syscalls that are explicitly
-/// marked safe for signal handlers and only share global data using atomics.
+/// * Signal handlers may be called at any point during execution, which limits
+///   what is safe to do in the body of the signal-catching function. Be certain
+///   to only make syscalls that are explicitly marked safe for signal handlers
+///   and only share global data using atomics.
+///
+/// * There is also no guarantee that the old signal handler was installed
+///   correctly.  If it was installed by this crate, it will be.  But if it was
+///   installed by, for example, C code, then there is no guarantee its function
+///   pointer is valid.  In that case, this function effectively dereferences a
+///   raw pointer of unknown provenance.
 pub unsafe fn sigaction(signal: Signal, sigaction: &SigAction) -> Result<SigAction> {
-    let mut oldact = mem::uninitialized::<libc::sigaction>();
+    let mut oldact = mem::MaybeUninit::<libc::sigaction>::uninit();
 
-    let res =
-        libc::sigaction(signal as libc::c_int, &sigaction.sigaction as *const libc::sigaction, &mut oldact as *mut libc::sigaction);
+    let res = libc::sigaction(signal as libc::c_int,
+                              &sigaction.sigaction as *const libc::sigaction,
+                              oldact.as_mut_ptr());
 
-    Errno::result(res).map(|_| SigAction { sigaction: oldact })
+    Errno::result(res).map(|_| SigAction { sigaction: oldact.assume_init() })
 }
 
-/// Signal management (see [signal(3p)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/signal.html))
+/// Signal management (see [signal(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/signal.html))
 ///
 /// Installs `handler` for the given `signal`, returning the previous signal
 /// handler. `signal` should only be used following another call to `signal` or
@@ -534,8 +742,7 @@ pub unsafe fn sigaction(signal: Signal, sigaction: &SigAction) -> Result<SigActi
 ///
 /// ```no_run
 /// # #[macro_use] extern crate lazy_static;
-/// # extern crate libc;
-/// # extern crate nix;
+/// # use std::convert::TryFrom;
 /// # use std::sync::atomic::{AtomicBool, Ordering};
 /// # use nix::sys::signal::{self, Signal, SigHandler};
 /// lazy_static! {
@@ -543,7 +750,7 @@ pub unsafe fn sigaction(signal: Signal, sigaction: &SigAction) -> Result<SigActi
 /// }
 ///
 /// extern fn handle_sigint(signal: libc::c_int) {
-///     let signal = Signal::from_c_int(signal).unwrap();
+///     let signal = Signal::try_from(signal).unwrap();
 ///     SIGNALED.store(signal == Signal::SIGINT, Ordering::Relaxed);
 /// }
 ///
@@ -555,7 +762,7 @@ pub unsafe fn sigaction(signal: Signal, sigaction: &SigAction) -> Result<SigActi
 ///
 /// # Errors
 ///
-/// Returns [`Error::UnsupportedOperation`] if `handler` is
+/// Returns [`Error(Errno::EOPNOTSUPP)`] if `handler` is
 /// [`SigAction`][SigActionStruct]. Use [`sigaction`][SigActionFn] instead.
 ///
 /// `signal` also returns any error from `libc::signal`, such as when an attempt
@@ -571,17 +778,40 @@ pub unsafe fn signal(signal: Signal, handler: SigHandler) -> Result<SigHandler>
         SigHandler::SigDfl => libc::signal(signal, libc::SIG_DFL),
         SigHandler::SigIgn => libc::signal(signal, libc::SIG_IGN),
         SigHandler::Handler(handler) => libc::signal(signal, handler as libc::sighandler_t),
-        SigHandler::SigAction(_) => return Err(Error::UnsupportedOperation),
+        #[cfg(not(target_os = "redox"))]
+        SigHandler::SigAction(_) => return Err(Errno::ENOTSUP),
     };
     Errno::result(res).map(|oldhandler| {
         match oldhandler {
             libc::SIG_DFL => SigHandler::SigDfl,
             libc::SIG_IGN => SigHandler::SigIgn,
-            f => SigHandler::Handler(mem::transmute(f)),
+            p => SigHandler::Handler(
+                *(&p as *const usize
+                     as *const extern fn(libc::c_int))
+                as extern fn(libc::c_int)),
         }
     })
 }
 
+fn do_pthread_sigmask(how: SigmaskHow,
+                       set: Option<&SigSet>,
+                       oldset: Option<*mut libc::sigset_t>) -> Result<()> {
+    if set.is_none() && oldset.is_none() {
+        return Ok(())
+    }
+
+    let res = unsafe {
+        // if set or oldset is None, pass in null pointers instead
+        libc::pthread_sigmask(how as libc::c_int,
+                             set.map_or_else(ptr::null::<libc::sigset_t>,
+                                             |s| &s.sigset as *const libc::sigset_t),
+                             oldset.unwrap_or(ptr::null_mut())
+                             )
+    };
+
+    Errno::result(res).map(drop)
+}
+
 /// Manages the signal mask (set of blocked signals) for the calling thread.
 ///
 /// If the `set` parameter is `Some(..)`, then the signal mask will be updated with the signal set.
@@ -595,31 +825,19 @@ pub unsafe fn signal(signal: Signal, handler: SigHandler) -> Result<SigHandler>
 ///
 /// If both `set` and `oldset` is None, this function is a no-op.
 ///
-/// For more information, visit the [`pthread_sigmask`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_sigmask.html),
-/// or [`sigprocmask`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/sigprocmask.html) man pages.
+/// For more information, visit the [`pthread_sigmask`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_sigmask.html),
+/// or [`sigprocmask`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/sigprocmask.html) man pages.
 pub fn pthread_sigmask(how: SigmaskHow,
                        set: Option<&SigSet>,
-                       oldset: Option<&mut SigSet>) -> Result<()> {
-    if set.is_none() && oldset.is_none() {
-        return Ok(())
-    }
-
-    let res = unsafe {
-        // if set or oldset is None, pass in null pointers instead
-        libc::pthread_sigmask(how as libc::c_int,
-                             set.map_or_else(ptr::null::<libc::sigset_t>,
-                                             |s| &s.sigset as *const libc::sigset_t),
-                             oldset.map_or_else(ptr::null_mut::<libc::sigset_t>,
-                                                |os| &mut os.sigset as *mut libc::sigset_t))
-    };
-
-    Errno::result(res).map(drop)
+                       oldset: Option<&mut SigSet>) -> Result<()>
+{
+    do_pthread_sigmask(how, set, oldset.map(|os| &mut os.sigset as *mut _ ))
 }
 
 /// Examine and change blocked signals.
 ///
 /// For more informations see the [`sigprocmask` man
-/// pages](http://pubs.opengroup.org/onlinepubs/9699919799/functions/sigprocmask.html).
+/// pages](https://pubs.opengroup.org/onlinepubs/9699919799/functions/sigprocmask.html).
 pub fn sigprocmask(how: SigmaskHow, set: Option<&SigSet>, oldset: Option<&mut SigSet>) -> Result<()> {
     if set.is_none() && oldset.is_none() {
         return Ok(())
@@ -637,7 +855,25 @@ pub fn sigprocmask(how: SigmaskHow, set: Option<&SigSet>, oldset: Option<&mut Si
     Errno::result(res).map(drop)
 }
 
-pub fn kill<T: Into<Option<Signal>>>(pid: ::unistd::Pid, signal: T) -> Result<()> {
+/// Send a signal to a process
+///
+/// # Arguments
+///
+/// * `pid` -    Specifies which processes should receive the signal.
+///   - If positive, specifies an individual process
+///   - If zero, the signal will be sent to all processes whose group
+///     ID is equal to the process group ID of the sender.  This is a
+///     variant of [`killpg`].
+///   - If `-1` and the process has super-user privileges, the signal
+///     is sent to all processes exclusing system processes.
+///   - If less than `-1`, the signal is sent to all processes whose
+///     process group ID is equal to the absolute value of `pid`.
+/// * `signal` - Signal to send. If `None`, error checking is performed
+///              but no signal is actually sent.
+///
+/// See Also
+/// [`kill(2)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/kill.html)
+pub fn kill<T: Into<Option<Signal>>>(pid: Pid, signal: T) -> Result<()> {
     let res = unsafe { libc::kill(pid.into(),
                                   match signal.into() {
                                       Some(s) => s as libc::c_int,
@@ -647,13 +883,18 @@ pub fn kill<T: Into<Option<Signal>>>(pid: ::unistd::Pid, signal: T) -> Result<()
     Errno::result(res).map(drop)
 }
 
-/// Send a signal to a process group [(see
-/// killpg(3))](http://pubs.opengroup.org/onlinepubs/9699919799/functions/killpg.html).
+/// Send a signal to a process group
 ///
-/// If `pgrp` less then or equal 1, the behavior is platform-specific.
-/// If `signal` is `None`, `killpg` will only preform error checking and won't
-/// send any signal.
-pub fn killpg<T: Into<Option<Signal>>>(pgrp: ::unistd::Pid, signal: T) -> Result<()> {
+/// # Arguments
+///
+/// * `pgrp` -   Process group to signal.  If less then or equal 1, the behavior
+///              is platform-specific.
+/// * `signal` - Signal to send. If `None`, `killpg` will only preform error
+///              checking and won't send any signal.
+///
+/// See Also [killpg(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/killpg.html).
+#[cfg(not(target_os = "fuchsia"))]
+pub fn killpg<T: Into<Option<Signal>>>(pgrp: Pid, signal: T) -> Result<()> {
     let res = unsafe { libc::killpg(pgrp.into(),
                                   match signal.into() {
                                       Some(s) => s as libc::c_int,
@@ -663,6 +904,9 @@ pub fn killpg<T: Into<Option<Signal>>>(pgrp: ::unistd::Pid, signal: T) -> Result
     Errno::result(res).map(drop)
 }
 
+/// Send a signal to the current thread
+///
+/// See Also [raise(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/raise.html)
 pub fn raise(signal: Signal) -> Result<()> {
     let res = unsafe { libc::raise(signal as libc::c_int) };
 
@@ -670,41 +914,55 @@ pub fn raise(signal: Signal) -> Result<()> {
 }
 
 
+/// Identifies a thread for [`SigevNotify::SigevThreadId`]
 #[cfg(target_os = "freebsd")]
 pub type type_of_thread_id = libc::lwpid_t;
+/// Identifies a thread for [`SigevNotify::SigevThreadId`]
 #[cfg(target_os = "linux")]
 pub type type_of_thread_id = libc::pid_t;
 
-/// Used to request asynchronous notification of certain events, for example,
-/// with POSIX AIO, POSIX message queues, and POSIX timers.
+/// Specifies the notification method used by a [`SigEvent`]
 // sigval is actually a union of a int and a void*.  But it's never really used
 // as a pointer, because neither libc nor the kernel ever dereference it.  nix
 // therefore presents it as an intptr_t, which is how kevent uses it.
+#[cfg(not(any(target_os = "openbsd", target_os = "redox")))]
 #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
 pub enum SigevNotify {
     /// No notification will be delivered
     SigevNone,
-    /// The signal given by `signal` will be delivered to the process.  The
-    /// value in `si_value` will be present in the `si_value` field of the
-    /// `siginfo_t` structure of the queued signal.
-    SigevSignal { signal: Signal, si_value: libc::intptr_t },
+    /// Notify by delivering a signal to the process.
+    SigevSignal {
+        /// Signal to deliver
+        signal: Signal,
+        /// Will be present in the `si_value` field of the [`libc::siginfo_t`]
+        /// structure of the queued signal.
+        si_value: libc::intptr_t
+    },
     // Note: SIGEV_THREAD is not implemented because libc::sigevent does not
     // expose a way to set the union members needed by SIGEV_THREAD.
-    /// A new `kevent` is posted to the kqueue `kq`.  The `kevent`'s `udata`
-    /// field will contain the value in `udata`.
+    /// Notify by delivering an event to a kqueue.
     #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
-    SigevKevent { kq: RawFd, udata: libc::intptr_t },
-    /// The signal `signal` is queued to the thread whose LWP ID is given in
-    /// `thread_id`.  The value stored in `si_value` will be present in the
-    /// `si_value` of the `siginfo_t` structure of the queued signal.
+    SigevKevent {
+        /// File descriptor of the kqueue to notify.
+        kq: RawFd,
+        /// Will be contained in the kevent's `udata` field.
+        udata: libc::intptr_t
+    },
+    /// Notify by delivering a signal to a thread.
     #[cfg(any(target_os = "freebsd", target_os = "linux"))]
-    SigevThreadId { signal: Signal, thread_id: type_of_thread_id,
-                    si_value: libc::intptr_t },
+    SigevThreadId {
+        /// Signal to send
+        signal: Signal,
+        /// LWP ID of the thread to notify
+        thread_id: type_of_thread_id,
+        /// Will be present in the `si_value` field of the [`libc::siginfo_t`]
+        /// structure of the queued signal.
+        si_value: libc::intptr_t
+    },
 }
 
-#[cfg(not(target_os = "openbsd"))]
+#[cfg(not(any(target_os = "openbsd", target_os = "redox")))]
 mod sigevent {
-    use libc;
     use std::mem;
     use std::ptr;
     use super::SigevNotify;
@@ -733,8 +991,11 @@ mod sigevent {
         /// Linux, Solaris, and portable programs should prefer `SIGEV_THREAD_ID` or
         /// `SIGEV_SIGNAL`.  That field is part of a union that shares space with the
         /// more genuinely useful `sigev_notify_thread_id`
+        // Allow invalid_value warning on Fuchsia only.
+        // See https://github.com/nix-rust/nix/issues/1441
+        #[cfg_attr(target_os = "fuchsia", allow(invalid_value))]
         pub fn new(sigev_notify: SigevNotify) -> SigEvent {
-            let mut sev = unsafe { mem::zeroed::<libc::sigevent>()};
+            let mut sev = unsafe { mem::MaybeUninit::<libc::sigevent>::zeroed().assume_init() };
             sev.sigev_notify = match sigev_notify {
                 SigevNotify::SigevNone => libc::SIGEV_NONE,
                 SigevNotify::SigevSignal{..} => libc::SIGEV_SIGNAL,
@@ -779,6 +1040,7 @@ mod sigevent {
         fn set_tid(_sev: &mut libc::sigevent, _sigev_notify: &SigevNotify) {
         }
 
+        /// Return a copy of the inner structure
         pub fn sigevent(&self) -> libc::sigevent {
             self.sigevent
         }
@@ -793,6 +1055,7 @@ mod sigevent {
 
 #[cfg(test)]
 mod tests {
+    #[cfg(not(target_os = "redox"))]
     use std::thread;
     use super::*;
 
@@ -828,7 +1091,7 @@ mod tests {
 
     #[test]
     fn test_from_str_invalid_value() {
-        let errval = Err(Error::Sys(Errno::EINVAL));
+        let errval = Err(Errno::EINVAL);
         assert_eq!("NOSIGNAL".parse::<Signal>(), errval);
         assert_eq!("kill".parse::<Signal>(), errval);
         assert_eq!("9".parse::<Signal>(), errval);
@@ -848,6 +1111,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(not(target_os = "redox"))]
     fn test_thread_signal_set_mask() {
         thread::spawn(|| {
             let prev_mask = SigSet::thread_get_mask()
@@ -868,6 +1132,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(not(target_os = "redox"))]
     fn test_thread_signal_block() {
         thread::spawn(|| {
             let mut mask = SigSet::empty();
@@ -880,6 +1145,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(not(target_os = "redox"))]
     fn test_thread_signal_unblock() {
         thread::spawn(|| {
             let mut mask = SigSet::empty();
@@ -892,6 +1158,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(not(target_os = "redox"))]
     fn test_thread_signal_swap() {
         thread::spawn(|| {
             let mut mask = SigSet::empty();
@@ -914,8 +1181,8 @@ mod tests {
     }
 
     #[test]
+    #[cfg(not(target_os = "redox"))]
     fn test_sigaction() {
-        use libc;
         thread::spawn(|| {
             extern fn test_sigaction_handler(_: libc::c_int) {}
             extern fn test_sigaction_action(_: libc::c_int,
@@ -952,6 +1219,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(not(target_os = "redox"))]
     fn test_sigwait() {
         thread::spawn(|| {
             let mut mask = SigSet::empty();
diff --git a/third_party/rust/nix/src/sys/signalfd.rs b/third_party/rust/nix/src/sys/signalfd.rs
index 5425a27be9e52..bc4a4522439ad 100644
--- a/third_party/rust/nix/src/sys/signalfd.rs
+++ b/third_party/rust/nix/src/sys/signalfd.rs
@@ -15,11 +15,10 @@
 //!
 //! Please note that signal discarding is not specific to `signalfd`, but also happens with regular
 //! signal handlers.
-use libc;
-use unistd;
-use {Error, Result};
-use errno::Errno;
-pub use sys::signal::{self, SigSet};
+use crate::unistd;
+use crate::Result;
+use crate::errno::Errno;
+pub use crate::sys::signal::{self, SigSet};
 pub use libc::signalfd_siginfo as siginfo;
 
 use std::os::unix::io::{RawFd, AsRawFd};
@@ -34,7 +33,8 @@ libc_bitflags!{
 }
 
 pub const SIGNALFD_NEW: RawFd = -1;
-pub const SIGNALFD_SIGINFO_SIZE: usize = 128;
+#[deprecated(since = "0.23.0", note = "use mem::size_of::<siginfo>() instead")]
+pub const SIGNALFD_SIGINFO_SIZE: usize = mem::size_of::<siginfo>();
 
 /// Creates a new file descriptor for reading signals.
 ///
@@ -46,7 +46,7 @@ pub const SIGNALFD_SIGINFO_SIZE: usize = 128;
 /// A signal must be blocked on every thread in a process, otherwise it won't be visible from
 /// signalfd (the default handler will be invoked instead).
 ///
-/// See [the signalfd man page for more information](http://man7.org/linux/man-pages/man2/signalfd.2.html)
+/// See [the signalfd man page for more information](https://man7.org/linux/man-pages/man2/signalfd.2.html)
 pub fn signalfd(fd: RawFd, mask: &SigSet, flags: SfdFlags) -> Result<RawFd> {
     unsafe {
         Errno::result(libc::signalfd(fd as libc::c_int, mask.as_ref(), flags.bits()))
@@ -79,7 +79,7 @@ pub fn signalfd(fd: RawFd, mask: &SigSet, flags: SfdFlags) -> Result<RawFd> {
 ///     Err(err) => (), // some error happend
 /// }
 /// ```
-#[derive(Clone, Debug, Eq, Hash, PartialEq)]
+#[derive(Debug, Eq, Hash, PartialEq)]
 pub struct SignalFd(RawFd);
 
 impl SignalFd {
@@ -98,12 +98,16 @@ impl SignalFd {
     }
 
     pub fn read_signal(&mut self) -> Result<Option<siginfo>> {
-        let mut buffer: [u8; SIGNALFD_SIGINFO_SIZE] = unsafe { mem::uninitialized() };
-
-        match unistd::read(self.0, &mut buffer) {
-            Ok(SIGNALFD_SIGINFO_SIZE) => Ok(Some(unsafe { mem::transmute(buffer) })),
+        let mut buffer = mem::MaybeUninit::<siginfo>::uninit();
+
+        let size = mem::size_of_val(&buffer);
+        let res = Errno::result(unsafe {
+            libc::read(self.0, buffer.as_mut_ptr() as *mut libc::c_void, size)
+        }).map(|r| r as usize);
+        match res {
+            Ok(x) if x == size => Ok(Some(unsafe { buffer.assume_init() })),
             Ok(_) => unreachable!("partial read on signalfd"),
-            Err(Error::Sys(Errno::EAGAIN)) => Ok(None),
+            Err(Errno::EAGAIN) => Ok(None),
             Err(error) => Err(error)
         }
     }
@@ -111,7 +115,10 @@ impl SignalFd {
 
 impl Drop for SignalFd {
     fn drop(&mut self) {
-        let _ = unistd::close(self.0);
+        let e = unistd::close(self.0);
+        if !std::thread::panicking() && e == Err(Errno::EBADF) {
+            panic!("Closing an invalid file descriptor!");
+        };
     }
 }
 
@@ -136,14 +143,6 @@ impl Iterator for SignalFd {
 #[cfg(test)]
 mod tests {
     use super::*;
-    use std::mem;
-    use libc;
-
-
-    #[test]
-    fn check_siginfo_size() {
-        assert_eq!(mem::size_of::<libc::signalfd_siginfo>(), SIGNALFD_SIGINFO_SIZE);
-    }
 
     #[test]
     fn create_signalfd() {
diff --git a/third_party/rust/nix/src/sys/socket/addr.rs b/third_party/rust/nix/src/sys/socket/addr.rs
index ed41441155361..b119642b3fc66 100644
--- a/third_party/rust/nix/src/sys/socket/addr.rs
+++ b/third_party/rust/nix/src/sys/socket/addr.rs
@@ -1,48 +1,55 @@
 use super::sa_family_t;
-use {Error, Result, NixPath};
-use errno::Errno;
-use libc;
+use crate::{Result, NixPath};
+use crate::errno::Errno;
+use memoffset::offset_of;
 use std::{fmt, mem, net, ptr, slice};
 use std::ffi::OsStr;
 use std::hash::{Hash, Hasher};
 use std::path::Path;
 use std::os::unix::ffi::OsStrExt;
 #[cfg(any(target_os = "android", target_os = "linux"))]
-use ::sys::socket::addr::netlink::NetlinkAddr;
+use crate::sys::socket::addr::netlink::NetlinkAddr;
 #[cfg(any(target_os = "android", target_os = "linux"))]
-use ::sys::socket::addr::alg::AlgAddr;
+use crate::sys::socket::addr::alg::AlgAddr;
 #[cfg(any(target_os = "ios", target_os = "macos"))]
 use std::os::unix::io::RawFd;
 #[cfg(any(target_os = "ios", target_os = "macos"))]
-use ::sys::socket::addr::sys_control::SysControlAddr;
+use crate::sys::socket::addr::sys_control::SysControlAddr;
 #[cfg(any(target_os = "android",
           target_os = "dragonfly",
           target_os = "freebsd",
           target_os = "ios",
           target_os = "linux",
           target_os = "macos",
+          target_os = "illumos",
           target_os = "netbsd",
-          target_os = "openbsd"))]
+          target_os = "openbsd",
+          target_os = "fuchsia"))]
 pub use self::datalink::LinkAddr;
-#[cfg(target_os = "linux")]
+#[cfg(any(target_os = "android", target_os = "linux"))]
 pub use self::vsock::VsockAddr;
 
 /// These constants specify the protocol family to be used
 /// in [`socket`](fn.socket.html) and [`socketpair`](fn.socketpair.html)
 #[repr(i32)]
+#[non_exhaustive]
 #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]
 pub enum AddressFamily {
-    /// Local communication (see [`unix(7)`](http://man7.org/linux/man-pages/man7/unix.7.html))
+    /// Local communication (see [`unix(7)`](https://man7.org/linux/man-pages/man7/unix.7.html))
     Unix = libc::AF_UNIX,
-    /// IPv4 Internet protocols (see [`ip(7)`](http://man7.org/linux/man-pages/man7/ip.7.html))
+    /// IPv4 Internet protocols (see [`ip(7)`](https://man7.org/linux/man-pages/man7/ip.7.html))
     Inet = libc::AF_INET,
-    /// IPv6 Internet protocols (see [`ipv6(7)`](http://man7.org/linux/man-pages/man7/ipv6.7.html))
+    /// IPv6 Internet protocols (see [`ipv6(7)`](https://man7.org/linux/man-pages/man7/ipv6.7.html))
     Inet6 = libc::AF_INET6,
-    /// Kernel user interface device (see [`netlink(7)`](http://man7.org/linux/man-pages/man7/netlink.7.html))
+    /// Kernel user interface device (see [`netlink(7)`](https://man7.org/linux/man-pages/man7/netlink.7.html))
     #[cfg(any(target_os = "android", target_os = "linux"))]
     Netlink = libc::AF_NETLINK,
-    /// Low level packet interface (see [`packet(7)`](http://man7.org/linux/man-pages/man7/packet.7.html))
-    #[cfg(any(target_os = "android", target_os = "linux"))]
+    /// Low level packet interface (see [`packet(7)`](https://man7.org/linux/man-pages/man7/packet.7.html))
+    #[cfg(any(target_os = "android",
+              target_os = "linux",
+              target_os = "illumos",
+              target_os = "fuchsia",
+              target_os = "solaris"))]
     Packet = libc::AF_PACKET,
     /// KEXT Controls and Notifications
     #[cfg(any(target_os = "ios", target_os = "macos"))]
@@ -61,7 +68,7 @@ pub enum AddressFamily {
     /// Access to raw ATM PVCs
     #[cfg(any(target_os = "android", target_os = "linux"))]
     AtmPvc = libc::AF_ATMPVC,
-    /// ITU-T X.25 / ISO-8208 protocol (see [`x25(7)`](http://man7.org/linux/man-pages/man7/x25.7.html))
+    /// ITU-T X.25 / ISO-8208 protocol (see [`x25(7)`](https://man7.org/linux/man-pages/man7/x25.7.html))
     #[cfg(any(target_os = "android", target_os = "linux"))]
     X25 = libc::AF_X25,
     #[cfg(any(target_os = "android", target_os = "linux"))]
@@ -98,12 +105,16 @@ pub enum AddressFamily {
     Can = libc::AF_CAN,
     #[cfg(any(target_os = "android", target_os = "linux"))]
     Tipc = libc::AF_TIPC,
-    #[cfg(not(any(target_os = "ios", target_os = "macos")))]
+    #[cfg(not(any(target_os = "illumos",
+                  target_os = "ios",
+                  target_os = "macos",
+                  target_os = "solaris")))]
     Bluetooth = libc::AF_BLUETOOTH,
     #[cfg(any(target_os = "android", target_os = "linux"))]
     Iucv = libc::AF_IUCV,
     #[cfg(any(target_os = "android", target_os = "linux"))]
     RxRpc = libc::AF_RXRPC,
+    #[cfg(not(any(target_os = "illumos", target_os = "solaris")))]
     Isdn = libc::AF_ISDN,
     #[cfg(any(target_os = "android", target_os = "linux"))]
     Phonet = libc::AF_PHONET,
@@ -116,7 +127,7 @@ pub enum AddressFamily {
     Alg = libc::AF_ALG,
     #[cfg(target_os = "linux")]
     Nfc = libc::AF_NFC,
-    #[cfg(target_os = "linux")]
+    #[cfg(any(target_os = "android", target_os = "linux"))]
     Vsock = libc::AF_VSOCK,
     #[cfg(any(target_os = "dragonfly",
               target_os = "freebsd",
@@ -190,6 +201,7 @@ pub enum AddressFamily {
               target_os = "freebsd",
               target_os = "ios",
               target_os = "macos",
+              target_os = "illumos",
               target_os = "netbsd",
               target_os = "openbsd"))]
     Link = libc::AF_LINK,
@@ -214,7 +226,7 @@ pub enum AddressFamily {
               target_os = "netbsd",
               target_os = "openbsd"))]
     Natm = libc::AF_NATM,
-    /// Unspecified address family, (see [`getaddrinfo(3)`](http://man7.org/linux/man-pages/man3/getaddrinfo.3.html))
+    /// Unspecified address family, (see [`getaddrinfo(3)`](https://man7.org/linux/man-pages/man3/getaddrinfo.3.html))
     #[cfg(any(target_os = "android", target_os = "linux"))]
     Unspec = libc::AF_UNSPEC,
 }
@@ -225,7 +237,7 @@ impl AddressFamily {
     ///
     /// Currently only supports these address families: Unix, Inet (v4 & v6), Netlink, Link/Packet
     /// and System. Returns None for unsupported or unknown address families.
-    pub fn from_i32(family: i32) -> Option<AddressFamily> {
+    pub const fn from_i32(family: i32) -> Option<AddressFamily> {
         match family {
             libc::AF_UNIX => Some(AddressFamily::Unix),
             libc::AF_INET => Some(AddressFamily::Inet),
@@ -241,9 +253,10 @@ impl AddressFamily {
                       target_os = "ios",
                       target_os = "macos",
                       target_os = "netbsd",
+                      target_os = "illumos",
                       target_os = "openbsd"))]
             libc::AF_LINK => Some(AddressFamily::Link),
-            #[cfg(target_os = "linux")]
+            #[cfg(any(target_os = "android", target_os = "linux"))]
             libc::AF_VSOCK => Some(AddressFamily::Vsock),
             _ => None
         }
@@ -257,6 +270,7 @@ pub enum InetAddr {
 }
 
 impl InetAddr {
+    #[allow(clippy::needless_update)]   // It isn't needless on all OSes
     pub fn from_std(std: &net::SocketAddr) -> InetAddr {
         match *std {
             net::SocketAddr::V4(ref addr) => {
@@ -280,6 +294,7 @@ impl InetAddr {
         }
     }
 
+    #[allow(clippy::needless_update)]   // It isn't needless on all OSes
     pub fn new(ip: IpAddr, port: u16) -> InetAddr {
         match ip {
             IpAddr::V4(ref ip) => {
@@ -301,7 +316,7 @@ impl InetAddr {
         }
     }
     /// Gets the IP address associated with this socket address.
-    pub fn ip(&self) -> IpAddr {
+    pub const fn ip(&self) -> IpAddr {
         match *self {
             InetAddr::V4(ref sa) => IpAddr::V4(Ipv4Addr(sa.sin_addr)),
             InetAddr::V6(ref sa) => IpAddr::V6(Ipv6Addr(sa.sin6_addr)),
@@ -309,7 +324,7 @@ impl InetAddr {
     }
 
     /// Gets the port number associated with this socket address
-    pub fn port(&self) -> u16 {
+    pub const fn port(&self) -> u16 {
         match *self {
             InetAddr::V6(ref sa) => u16::from_be(sa.sin6_port),
             InetAddr::V4(ref sa) => u16::from_be(sa.sin_port),
@@ -331,6 +346,7 @@ impl InetAddr {
         }
     }
 
+    #[deprecated(since = "0.23.0", note = "use .to_string() instead")]
     pub fn to_str(&self) -> String {
         format!("{}", self)
     }
@@ -360,14 +376,16 @@ impl IpAddr {
     /// Create a new IpAddr that contains an IPv4 address.
     ///
     /// The result will represent the IP address a.b.c.d
-    pub fn new_v4(a: u8, b: u8, c: u8, d: u8) -> IpAddr {
+    pub const fn new_v4(a: u8, b: u8, c: u8, d: u8) -> IpAddr {
         IpAddr::V4(Ipv4Addr::new(a, b, c, d))
     }
 
     /// Create a new IpAddr that contains an IPv6 address.
     ///
     /// The result will represent the IP address a:b:c:d:e:f
-    pub fn new_v6(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> IpAddr {
+    #[allow(clippy::many_single_char_names)]
+    #[allow(clippy::too_many_arguments)]
+    pub const fn new_v6(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> IpAddr {
         IpAddr::V6(Ipv6Addr::new(a, b, c, d, e, f, g, h))
     }
 
@@ -378,7 +396,7 @@ impl IpAddr {
         }
     }
 
-    pub fn to_std(&self) -> net::IpAddr {
+    pub const fn to_std(&self) -> net::IpAddr {
         match *self {
             IpAddr::V4(ref ip) => net::IpAddr::V4(ip.to_std()),
             IpAddr::V6(ref ip) => net::IpAddr::V6(ip.to_std()),
@@ -405,7 +423,8 @@ impl fmt::Display for IpAddr {
 pub struct Ipv4Addr(pub libc::in_addr);
 
 impl Ipv4Addr {
-    pub fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {
+    #[allow(clippy::identity_op)]   // More readable this way
+    pub const fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {
         let ip = (((a as u32) << 24) |
                   ((b as u32) << 16) |
                   ((c as u32) <<  8) |
@@ -414,21 +433,23 @@ impl Ipv4Addr {
         Ipv4Addr(libc::in_addr { s_addr: ip })
     }
 
+    // Use pass by reference for symmetry with Ipv6Addr::from_std
+    #[allow(clippy::trivially_copy_pass_by_ref)]
     pub fn from_std(std: &net::Ipv4Addr) -> Ipv4Addr {
         let bits = std.octets();
         Ipv4Addr::new(bits[0], bits[1], bits[2], bits[3])
     }
 
-    pub fn any() -> Ipv4Addr {
+    pub const fn any() -> Ipv4Addr {
         Ipv4Addr(libc::in_addr { s_addr: libc::INADDR_ANY })
     }
 
-    pub fn octets(&self) -> [u8; 4] {
+    pub const fn octets(self) -> [u8; 4] {
         let bits = u32::from_be(self.0.s_addr);
         [(bits >> 24) as u8, (bits >> 16) as u8, (bits >> 8) as u8, bits as u8]
     }
 
-    pub fn to_std(&self) -> net::Ipv4Addr {
+    pub const fn to_std(self) -> net::Ipv4Addr {
         let bits = self.octets();
         net::Ipv4Addr::new(bits[0], bits[1], bits[2], bits[3])
     }
@@ -467,10 +488,10 @@ macro_rules! to_u16_array {
 }
 
 impl Ipv6Addr {
-    pub fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> Ipv6Addr {
-        let mut in6_addr_var: libc::in6_addr = unsafe{mem::uninitialized()};
-        in6_addr_var.s6_addr = to_u8_array!(a,b,c,d,e,f,g,h);
-        Ipv6Addr(in6_addr_var)
+    #[allow(clippy::many_single_char_names)]
+    #[allow(clippy::too_many_arguments)]
+    pub const fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> Ipv6Addr {
+        Ipv6Addr(libc::in6_addr{s6_addr: to_u8_array!(a,b,c,d,e,f,g,h)})
     }
 
     pub fn from_std(std: &net::Ipv6Addr) -> Ipv6Addr {
@@ -479,11 +500,11 @@ impl Ipv6Addr {
     }
 
     /// Return the eight 16-bit segments that make up this address
-    pub fn segments(&self) -> [u16; 8] {
+    pub const fn segments(&self) -> [u16; 8] {
         to_u16_array!(self, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
     }
 
-    pub fn to_std(&self) -> net::Ipv6Addr {
+    pub const fn to_std(&self) -> net::Ipv6Addr {
         let s = self.segments();
         net::Ipv6Addr::new(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7])
     }
@@ -496,15 +517,42 @@ impl fmt::Display for Ipv6Addr {
 }
 
 /// A wrapper around `sockaddr_un`.
-///
-/// This also tracks the length of `sun_path` address (excluding
-/// a terminating null), because it may not be null-terminated.  For example,
-/// unconnected and Linux abstract sockets are never null-terminated, and POSIX
-/// does not require that `sun_len` include the terminating null even for normal
-/// sockets.  Note that the actual sockaddr length is greater by
-/// `offset_of!(libc::sockaddr_un, sun_path)`
 #[derive(Clone, Copy, Debug)]
-pub struct UnixAddr(pub libc::sockaddr_un, pub usize);
+pub struct UnixAddr {
+    // INVARIANT: sun & path_len are valid as defined by docs for from_raw_parts
+    sun: libc::sockaddr_un,
+    path_len: usize,
+}
+
+// linux man page unix(7) says there are 3 kinds of unix socket:
+// pathname: addrlen = offsetof(struct sockaddr_un, sun_path) + strlen(sun_path) + 1
+// unnamed: addrlen = sizeof(sa_family_t)
+// abstract: addren > sizeof(sa_family_t), name = sun_path[..(addrlen - sizeof(sa_family_t))]
+//
+// what we call path_len = addrlen - offsetof(struct sockaddr_un, sun_path)
+#[derive(PartialEq, Eq, Hash)]
+enum UnixAddrKind<'a> {
+    Pathname(&'a Path),
+    Unnamed,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Abstract(&'a [u8]),
+}
+impl<'a> UnixAddrKind<'a> {
+    /// Safety: sun & path_len must be valid
+    unsafe fn get(sun: &'a libc::sockaddr_un, path_len: usize) -> Self {
+        if path_len == 0 {
+            return Self::Unnamed;
+        }
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        if sun.sun_path[0] == 0 {
+            let name =
+                slice::from_raw_parts(sun.sun_path.as_ptr().add(1) as *const u8, path_len - 1);
+            return Self::Abstract(name);
+        }
+        let pathname = slice::from_raw_parts(sun.sun_path.as_ptr() as *const u8, path_len - 1);
+        Self::Pathname(Path::new(OsStr::from_bytes(pathname)))
+    }
+}
 
 impl UnixAddr {
     /// Create a new sockaddr_un representing a filesystem path.
@@ -518,15 +566,15 @@ impl UnixAddr {
 
                 let bytes = cstr.to_bytes();
 
-                if bytes.len() > ret.sun_path.len() {
-                    return Err(Error::Sys(Errno::ENAMETOOLONG));
+                if bytes.len() >= ret.sun_path.len() {
+                    return Err(Errno::ENAMETOOLONG);
                 }
 
                 ptr::copy_nonoverlapping(bytes.as_ptr(),
                                          ret.sun_path.as_mut_ptr() as *mut u8,
                                          bytes.len());
 
-                Ok(UnixAddr(ret, bytes.len()))
+                Ok(UnixAddr::from_raw_parts(ret, bytes.len() + 1))
             }
         })?
     }
@@ -545,8 +593,8 @@ impl UnixAddr {
                 .. mem::zeroed()
             };
 
-            if path.len() + 1 > ret.sun_path.len() {
-                return Err(Error::Sys(Errno::ENAMETOOLONG));
+            if path.len() >= ret.sun_path.len() {
+                return Err(Errno::ENAMETOOLONG);
             }
 
             // Abstract addresses are represented by sun_path[0] ==
@@ -555,28 +603,39 @@ impl UnixAddr {
                                      ret.sun_path.as_mut_ptr().offset(1) as *mut u8,
                                      path.len());
 
-            Ok(UnixAddr(ret, ret.sun_path.len()))
+            Ok(UnixAddr::from_raw_parts(ret, path.len() + 1))
         }
     }
 
-    fn sun_path(&self) -> &[u8] {
-        unsafe { slice::from_raw_parts(self.0.sun_path.as_ptr() as *const u8, self.1) }
+    /// Create a UnixAddr from a raw `sockaddr_un` struct and a size. `path_len` is the "addrlen"
+    /// of this address, but minus `offsetof(struct sockaddr_un, sun_path)`. Basically the length
+    /// of the data in `sun_path`.
+    ///
+    /// # Safety
+    /// This pair of sockaddr_un & path_len must be a valid unix addr, which means:
+    /// - path_len <= sockaddr_un.sun_path.len()
+    /// - if this is a unix addr with a pathname, sun.sun_path is a nul-terminated fs path and
+    ///   sun.sun_path[path_len - 1] == 0 || sun.sun_path[path_len] == 0
+    pub(crate) unsafe fn from_raw_parts(sun: libc::sockaddr_un, mut path_len: usize) -> UnixAddr {
+        if let UnixAddrKind::Pathname(_) = UnixAddrKind::get(&sun, path_len) {
+            if sun.sun_path[path_len - 1] != 0 {
+                assert_eq!(sun.sun_path[path_len], 0);
+                path_len += 1
+            }
+        }
+        UnixAddr { sun, path_len }
+    }
+
+    fn kind(&self) -> UnixAddrKind<'_> {
+        // SAFETY: our sockaddr is always valid because of the invariant on the struct
+        unsafe { UnixAddrKind::get(&self.sun, self.path_len) }
     }
 
     /// If this address represents a filesystem path, return that path.
     pub fn path(&self) -> Option<&Path> {
-        if self.1 == 0 || self.0.sun_path[0] == 0 {
-            // unnamed or abstract
-            None
-        } else {
-            let p = self.sun_path();
-            // POSIX only requires that `sun_len` be at least long enough to
-            // contain the pathname, and it need not be null-terminated.  So we
-            // need to create a string that is the shorter of the
-            // null-terminated length or the full length.
-            let ptr = &self.0.sun_path as *const libc::c_char;
-            let reallen = unsafe { libc::strnlen(ptr, p.len()) };
-            Some(Path::new(<OsStr as OsStrExt>::from_bytes(&p[..reallen])))
+        match self.kind() {
+            UnixAddrKind::Pathname(path) => Some(path),
+            _ => None,
         }
     }
 
@@ -586,31 +645,55 @@ impl UnixAddr {
     /// leading null byte. `None` is returned for unnamed or path-backed sockets.
     #[cfg(any(target_os = "android", target_os = "linux"))]
     pub fn as_abstract(&self) -> Option<&[u8]> {
-        if self.1 >= 1 && self.0.sun_path[0] == 0 {
-            Some(&self.sun_path()[1..])
-        } else {
-            // unnamed or filesystem path
-            None
+        match self.kind() {
+            UnixAddrKind::Abstract(name) => Some(name),
+            _ => None,
         }
     }
+
+    /// Returns the addrlen of this socket - `offsetof(struct sockaddr_un, sun_path)`
+    #[inline]
+    pub fn path_len(&self) -> usize {
+        self.path_len
+    }
+    /// Returns a pointer to the raw `sockaddr_un` struct
+    #[inline]
+    pub fn as_ptr(&self) -> *const libc::sockaddr_un {
+        &self.sun
+    }
+    /// Returns a mutable pointer to the raw `sockaddr_un` struct
+    #[inline]
+    pub fn as_mut_ptr(&mut self) -> *mut libc::sockaddr_un {
+        &mut self.sun
+    }
+}
+
+#[cfg(any(target_os = "android", target_os = "linux"))]
+fn fmt_abstract(abs: &[u8], f: &mut fmt::Formatter) -> fmt::Result {
+    use fmt::Write;
+    f.write_str("@\"")?;
+    for &b in abs {
+        use fmt::Display;
+        char::from(b).escape_default().fmt(f)?;
+    }
+    f.write_char('"')?;
+    Ok(())
 }
 
 impl fmt::Display for UnixAddr {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-        if self.1 == 0 {
-            f.write_str("<unbound UNIX socket>")
-        } else if let Some(path) = self.path() {
-            path.display().fmt(f)
-        } else {
-            let display = String::from_utf8_lossy(&self.sun_path()[1..]);
-            write!(f, "@{}", display)
+        match self.kind() {
+            UnixAddrKind::Pathname(path) => path.display().fmt(f),
+            UnixAddrKind::Unnamed => f.pad("<unbound UNIX socket>"),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            UnixAddrKind::Abstract(name) => fmt_abstract(name, f),
         }
     }
 }
 
 impl PartialEq for UnixAddr {
     fn eq(&self, other: &UnixAddr) -> bool {
-        self.sun_path() == other.sun_path()
+        self.kind() == other.kind()
     }
 }
 
@@ -618,12 +701,13 @@ impl Eq for UnixAddr {}
 
 impl Hash for UnixAddr {
     fn hash<H: Hasher>(&self, s: &mut H) {
-        ( self.0.sun_family, self.sun_path() ).hash(s)
+        self.kind().hash(s)
     }
 }
 
 /// Represents a socket address
 #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+#[non_exhaustive]
 pub enum SockAddr {
     Inet(InetAddr),
     Unix(UnixAddr),
@@ -640,10 +724,11 @@ pub enum SockAddr {
               target_os = "ios",
               target_os = "linux",
               target_os = "macos",
+              target_os = "illumos",
               target_os = "netbsd",
               target_os = "openbsd"))]
     Link(LinkAddr),
-    #[cfg(target_os = "linux")]
+    #[cfg(any(target_os = "android", target_os = "linux"))]
     Vsock(VsockAddr),
 }
 
@@ -668,10 +753,10 @@ impl SockAddr {
 
     #[cfg(any(target_os = "ios", target_os = "macos"))]
     pub fn new_sys_control(sockfd: RawFd, name: &str, unit: u32) -> Result<SockAddr> {
-        SysControlAddr::from_name(sockfd, name, unit).map(|a| SockAddr::SysControl(a))
+        SysControlAddr::from_name(sockfd, name, unit).map(SockAddr::SysControl)
     }
 
-    #[cfg(target_os = "linux")]
+    #[cfg(any(target_os = "android", target_os = "linux"))]
     pub fn new_vsock(cid: u32, port: u32) -> SockAddr {
         SockAddr::Vsock(VsockAddr::new(cid, port))
     }
@@ -694,13 +779,15 @@ impl SockAddr {
                       target_os = "ios",
                       target_os = "macos",
                       target_os = "netbsd",
+                      target_os = "illumos",
                       target_os = "openbsd"))]
             SockAddr::Link(..) => AddressFamily::Link,
-            #[cfg(target_os = "linux")]
+            #[cfg(any(target_os = "android", target_os = "linux"))]
             SockAddr::Vsock(..) => AddressFamily::Vsock,
         }
     }
 
+    #[deprecated(since = "0.23.0", note = "use .to_string() instead")]
     pub fn to_str(&self) -> String {
         format!("{}", self)
     }
@@ -709,11 +796,17 @@ impl SockAddr {
     ///
     /// Supports only the following address families: Unix, Inet (v4 & v6), Netlink and System.
     /// Returns None for unsupported families.
-    pub unsafe fn from_libc_sockaddr(addr: *const libc::sockaddr) -> Option<SockAddr> {
+    ///
+    /// # Safety
+    ///
+    /// unsafe because it takes a raw pointer as argument.  The caller must
+    /// ensure that the pointer is valid.
+    #[cfg(not(target_os = "fuchsia"))]
+    pub(crate) unsafe fn from_libc_sockaddr(addr: *const libc::sockaddr) -> Option<SockAddr> {
         if addr.is_null() {
             None
         } else {
-            match AddressFamily::from_i32((*addr).sa_family as i32) {
+            match AddressFamily::from_i32(i32::from((*addr).sa_family)) {
                 Some(AddressFamily::Unix) => None,
                 Some(AddressFamily::Inet) => Some(SockAddr::Inet(
                     InetAddr::V4(*(addr as *const libc::sockaddr_in)))),
@@ -733,6 +826,7 @@ impl SockAddr {
                           target_os = "ios",
                           target_os = "macos",
                           target_os = "netbsd",
+                          target_os = "illumos",
                           target_os = "openbsd"))]
                 Some(AddressFamily::Link) => {
                     let ether_addr = LinkAddr(*(addr as *const libc::sockaddr_dl));
@@ -742,7 +836,7 @@ impl SockAddr {
                         Some(SockAddr::Link(ether_addr))
                     }
                 },
-                #[cfg(target_os = "linux")]
+                #[cfg(any(target_os = "android", target_os = "linux"))]
                 Some(AddressFamily::Vsock) => Some(SockAddr::Vsock(
                     VsockAddr(*(addr as *const libc::sockaddr_vm)))),
                 // Other address families are currently not supported and simply yield a None
@@ -759,28 +853,84 @@ impl SockAddr {
     /// with the size of the actual data type. sockaddr is commonly used as a proxy for
     /// a superclass as C doesn't support inheritance, so many functions that take
     /// a sockaddr * need to take the size of the underlying type as well and then internally cast it back.
-    pub unsafe fn as_ffi_pair(&self) -> (&libc::sockaddr, libc::socklen_t) {
+    pub fn as_ffi_pair(&self) -> (&libc::sockaddr, libc::socklen_t) {
         match *self {
-            SockAddr::Inet(InetAddr::V4(ref addr)) => (mem::transmute(addr), mem::size_of::<libc::sockaddr_in>() as libc::socklen_t),
-            SockAddr::Inet(InetAddr::V6(ref addr)) => (mem::transmute(addr), mem::size_of::<libc::sockaddr_in6>() as libc::socklen_t),
-            SockAddr::Unix(UnixAddr(ref addr, len)) => (mem::transmute(addr), (len + offset_of!(libc::sockaddr_un, sun_path)) as libc::socklen_t),
+            SockAddr::Inet(InetAddr::V4(ref addr)) => (
+                // This cast is always allowed in C
+                unsafe {
+                    &*(addr as *const libc::sockaddr_in as *const libc::sockaddr)
+                },
+                mem::size_of_val(addr) as libc::socklen_t
+            ),
+            SockAddr::Inet(InetAddr::V6(ref addr)) => (
+                // This cast is always allowed in C
+                unsafe {
+                    &*(addr as *const libc::sockaddr_in6 as *const libc::sockaddr)
+                },
+                mem::size_of_val(addr) as libc::socklen_t
+            ),
+            SockAddr::Unix(UnixAddr { ref sun, path_len }) => (
+                // This cast is always allowed in C
+                unsafe {
+                    &*(sun as *const libc::sockaddr_un as *const libc::sockaddr)
+                },
+                (path_len + offset_of!(libc::sockaddr_un, sun_path)) as libc::socklen_t
+            ),
             #[cfg(any(target_os = "android", target_os = "linux"))]
-            SockAddr::Netlink(NetlinkAddr(ref sa)) => (mem::transmute(sa), mem::size_of::<libc::sockaddr_nl>() as libc::socklen_t),
+            SockAddr::Netlink(NetlinkAddr(ref sa)) => (
+                // This cast is always allowed in C
+                unsafe {
+                    &*(sa as *const libc::sockaddr_nl as *const libc::sockaddr)
+                },
+                mem::size_of_val(sa) as libc::socklen_t
+            ),
             #[cfg(any(target_os = "android", target_os = "linux"))]
-            SockAddr::Alg(AlgAddr(ref sa)) => (mem::transmute(sa), mem::size_of::<libc::sockaddr_alg>() as libc::socklen_t),
+            SockAddr::Alg(AlgAddr(ref sa)) => (
+                // This cast is always allowed in C
+                unsafe {
+                    &*(sa as *const libc::sockaddr_alg as *const libc::sockaddr)
+                },
+                mem::size_of_val(sa) as libc::socklen_t
+            ),
             #[cfg(any(target_os = "ios", target_os = "macos"))]
-            SockAddr::SysControl(SysControlAddr(ref sa)) => (mem::transmute(sa), mem::size_of::<libc::sockaddr_ctl>() as libc::socklen_t),
+            SockAddr::SysControl(SysControlAddr(ref sa)) => (
+                // This cast is always allowed in C
+                unsafe {
+                    &*(sa as *const libc::sockaddr_ctl as *const libc::sockaddr)
+                },
+                mem::size_of_val(sa) as libc::socklen_t
+
+            ),
             #[cfg(any(target_os = "android", target_os = "linux"))]
-            SockAddr::Link(LinkAddr(ref ether_addr)) => (mem::transmute(ether_addr), mem::size_of::<libc::sockaddr_ll>() as libc::socklen_t),
+            SockAddr::Link(LinkAddr(ref addr)) => (
+                // This cast is always allowed in C
+                unsafe {
+                    &*(addr as *const libc::sockaddr_ll as *const libc::sockaddr)
+                },
+                mem::size_of_val(addr) as libc::socklen_t
+            ),
             #[cfg(any(target_os = "dragonfly",
                       target_os = "freebsd",
                       target_os = "ios",
                       target_os = "macos",
+                      target_os = "illumos",
                       target_os = "netbsd",
                       target_os = "openbsd"))]
-            SockAddr::Link(LinkAddr(ref ether_addr)) => (mem::transmute(ether_addr), mem::size_of::<libc::sockaddr_dl>() as libc::socklen_t),
-            #[cfg(target_os = "linux")]
-            SockAddr::Vsock(VsockAddr(ref sa)) => (mem::transmute(sa), mem::size_of::<libc::sockaddr_vm>() as libc::socklen_t),
+            SockAddr::Link(LinkAddr(ref addr)) => (
+                // This cast is always allowed in C
+                unsafe {
+                    &*(addr as *const libc::sockaddr_dl as *const libc::sockaddr)
+                },
+                mem::size_of_val(addr) as libc::socklen_t
+            ),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            SockAddr::Vsock(VsockAddr(ref sa)) => (
+                // This cast is always allowed in C
+                unsafe {
+                    &*(sa as *const libc::sockaddr_vm as *const libc::sockaddr)
+                },
+                mem::size_of_val(sa) as libc::socklen_t
+            ),
         }
     }
 }
@@ -803,9 +953,10 @@ impl fmt::Display for SockAddr {
                       target_os = "linux",
                       target_os = "macos",
                       target_os = "netbsd",
+                      target_os = "illumos",
                       target_os = "openbsd"))]
             SockAddr::Link(ref ether_addr) => ether_addr.fmt(f),
-            #[cfg(target_os = "linux")]
+            #[cfg(any(target_os = "android", target_os = "linux"))]
             SockAddr::Vsock(ref svm) => svm.fmt(f),
         }
     }
@@ -813,7 +964,7 @@ impl fmt::Display for SockAddr {
 
 #[cfg(any(target_os = "android", target_os = "linux"))]
 pub mod netlink {
-    use ::sys::socket::addr::AddressFamily;
+    use crate::sys::socket::addr::AddressFamily;
     use libc::{sa_family_t, sockaddr_nl};
     use std::{fmt, mem};
 
@@ -830,11 +981,11 @@ pub mod netlink {
             NetlinkAddr(addr)
         }
 
-        pub fn pid(&self) -> u32 {
+        pub const fn pid(&self) -> u32 {
             self.0.nl_pid
         }
 
-        pub fn groups(&self) -> u32 {
+        pub const fn groups(&self) -> u32 {
             self.0.nl_groups
         }
     }
@@ -911,11 +1062,11 @@ pub mod alg {
 
 #[cfg(any(target_os = "ios", target_os = "macos"))]
 pub mod sys_control {
-    use ::sys::socket::addr::AddressFamily;
+    use crate::sys::socket::addr::AddressFamily;
     use libc::{self, c_uchar};
     use std::{fmt, mem};
     use std::os::unix::io::RawFd;
-    use {Errno, Error, Result};
+    use crate::{Errno, Result};
 
     // FIXME: Move type into `libc`
     #[repr(C)]
@@ -926,7 +1077,7 @@ pub mod sys_control {
         pub ctl_name: [c_uchar; MAX_KCTL_NAME],
     }
 
-    const CTL_IOC_MAGIC: u8 = 'N' as u8;
+    const CTL_IOC_MAGIC: u8 = b'N';
     const CTL_IOC_INFO: u8 = 3;
     const MAX_KCTL_NAME: usize = 96;
 
@@ -937,7 +1088,7 @@ pub mod sys_control {
     pub struct SysControlAddr(pub libc::sockaddr_ctl);
 
     impl SysControlAddr {
-        pub fn new(id: u32, unit: u32) -> SysControlAddr {
+        pub const fn new(id: u32, unit: u32) -> SysControlAddr {
             let addr = libc::sockaddr_ctl {
                 sc_len: mem::size_of::<libc::sockaddr_ctl>() as c_uchar,
                 sc_family: AddressFamily::System as c_uchar,
@@ -952,23 +1103,23 @@ pub mod sys_control {
 
         pub fn from_name(sockfd: RawFd, name: &str, unit: u32) -> Result<SysControlAddr> {
             if name.len() > MAX_KCTL_NAME {
-                return Err(Error::Sys(Errno::ENAMETOOLONG));
+                return Err(Errno::ENAMETOOLONG);
             }
 
             let mut ctl_name = [0; MAX_KCTL_NAME];
             ctl_name[..name.len()].clone_from_slice(name.as_bytes());
-            let mut info = ctl_ioc_info { ctl_id: 0, ctl_name: ctl_name };
+            let mut info = ctl_ioc_info { ctl_id: 0, ctl_name };
 
             unsafe { ctl_info(sockfd, &mut info)?; }
 
             Ok(SysControlAddr::new(info.ctl_id, unit))
         }
 
-        pub fn id(&self) -> u32 {
+        pub const fn id(&self) -> u32 {
             self.0.sc_id
         }
 
-        pub fn unit(&self) -> u32 {
+        pub const fn unit(&self) -> u32 {
             self.0.sc_unit
         }
     }
@@ -981,9 +1132,9 @@ pub mod sys_control {
 }
 
 
-#[cfg(any(target_os = "android", target_os = "linux"))]
+#[cfg(any(target_os = "android", target_os = "linux", target_os = "fuchsia"))]
 mod datalink {
-    use super::{libc, fmt, AddressFamily};
+    use super::{fmt, AddressFamily};
 
     /// Hardware Address
     #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
@@ -1023,14 +1174,14 @@ mod datalink {
 
         /// Physical-layer address (MAC)
         pub fn addr(&self) -> [u8; 6] {
-            let a = self.0.sll_addr[0] as u8;
-            let b = self.0.sll_addr[1] as u8;
-            let c = self.0.sll_addr[2] as u8;
-            let d = self.0.sll_addr[3] as u8;
-            let e = self.0.sll_addr[4] as u8;
-            let f = self.0.sll_addr[5] as u8;
-
-            [a, b, c, d, e, f]
+            [
+                self.0.sll_addr[0] as u8,
+                self.0.sll_addr[1] as u8,
+                self.0.sll_addr[2] as u8,
+                self.0.sll_addr[3] as u8,
+                self.0.sll_addr[4] as u8,
+                self.0.sll_addr[5] as u8,
+            ]
         }
     }
 
@@ -1052,10 +1203,11 @@ mod datalink {
           target_os = "freebsd",
           target_os = "ios",
           target_os = "macos",
+          target_os = "illumos",
           target_os = "netbsd",
           target_os = "openbsd"))]
 mod datalink {
-    use super::{libc, fmt, AddressFamily};
+    use super::{fmt, AddressFamily};
 
     /// Hardware Address
     #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
@@ -1063,13 +1215,14 @@ mod datalink {
 
     impl LinkAddr {
         /// Total length of sockaddr
+        #[cfg(not(target_os = "illumos"))]
         pub fn len(&self) -> usize {
             self.0.sdl_len as usize
         }
 
         /// always == AF_LINK
         pub fn family(&self) -> AddressFamily {
-            assert_eq!(self.0.sdl_family as i32, libc::AF_LINK);
+            assert_eq!(i32::from(self.0.sdl_family), libc::AF_LINK);
             AddressFamily::Link
         }
 
@@ -1105,11 +1258,7 @@ mod datalink {
             let alen = self.alen();
             let data_len = self.0.sdl_data.len();
 
-            if alen > 0 && nlen + alen < data_len {
-                false
-            } else {
-                true
-            }
+            alen == 0 || nlen + alen >= data_len
         }
 
         /// Physical-layer address (MAC)
@@ -1119,14 +1268,14 @@ mod datalink {
 
             assert!(!self.is_empty());
 
-            let a = data[nlen] as u8;
-            let b = data[nlen + 1] as u8;
-            let c = data[nlen + 2] as u8;
-            let d = data[nlen + 3] as u8;
-            let e = data[nlen + 4] as u8;
-            let f = data[nlen + 5] as u8;
-
-            [a, b, c, d, e, f]
+            [
+                data[nlen] as u8,
+                data[nlen + 1] as u8,
+                data[nlen + 2] as u8,
+                data[nlen + 3] as u8,
+                data[nlen + 4] as u8,
+                data[nlen + 5] as u8,
+            ]
         }
     }
 
@@ -1144,9 +1293,9 @@ mod datalink {
     }
 }
 
-#[cfg(target_os = "linux")]
+#[cfg(any(target_os = "android", target_os = "linux"))]
 pub mod vsock {
-    use ::sys::socket::addr::AddressFamily;
+    use crate::sys::socket::addr::AddressFamily;
     use libc::{sa_family_t, sockaddr_vm};
     use std::{fmt, mem};
     use std::hash::{Hash, Hasher};
@@ -1218,6 +1367,7 @@ mod tests {
               target_os = "linux",
               target_os = "macos",
               target_os = "netbsd",
+              target_os = "illumos",
               target_os = "openbsd"))]
     use super::*;
 
@@ -1262,17 +1412,36 @@ mod tests {
         };
     }
 
+    #[cfg(target_os = "illumos")]
+    #[test]
+    fn test_illumos_tap_datalink_addr() {
+        let bytes = [25u8, 0, 0, 0, 6, 0, 6, 0, 24, 101, 144, 221, 76, 176];
+        let ptr = bytes.as_ptr();
+        let sa = ptr as *const libc::sockaddr;
+        let _sock_addr = unsafe { SockAddr::from_libc_sockaddr(sa) };
+
+        assert!(_sock_addr.is_some());
+
+        let sock_addr = _sock_addr.unwrap();
+
+        assert_eq!(sock_addr.family(), AddressFamily::Link);
+
+        match sock_addr {
+            SockAddr::Link(ether_addr) => {
+                assert_eq!(ether_addr.addr(), [24u8, 101, 144, 221, 76, 176]);
+            },
+            _ => { unreachable!() }
+        };
+    }
+
     #[cfg(any(target_os = "android", target_os = "linux"))]
     #[test]
     fn test_abstract_sun_path() {
         let name = String::from("nix\0abstract\0test");
         let addr = UnixAddr::new_abstract(name.as_bytes()).unwrap();
 
-        let sun_path1 = addr.sun_path();
-        let sun_path2 = [0u8, 110, 105, 120, 0, 97, 98, 115, 116, 114, 97, 99, 116, 0, 116, 101, 115, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
-        assert_eq!(sun_path1.len(), sun_path2.len());
-        for i in 0..sun_path1.len() {
-            assert_eq!(sun_path1[i], sun_path2[i]);
-        }
+        let sun_path1 = unsafe { &(*addr.as_ptr()).sun_path[..addr.path_len()] };
+        let sun_path2 = [0, 110, 105, 120, 0, 97, 98, 115, 116, 114, 97, 99, 116, 0, 116, 101, 115, 116];
+        assert_eq!(sun_path1, sun_path2);
     }
 }
diff --git a/third_party/rust/nix/src/sys/socket/mod.rs b/third_party/rust/nix/src/sys/socket/mod.rs
index 1c12c5f851734..97eea3dcb125a 100644
--- a/third_party/rust/nix/src/sys/socket/mod.rs
+++ b/third_party/rust/nix/src/sys/socket/mod.rs
@@ -1,16 +1,20 @@
 //! Socket interface functions
 //!
-//! [Further reading](http://man7.org/linux/man-pages/man7/socket.7.html)
-use {Error, Result};
-use errno::Errno;
+//! [Further reading](https://man7.org/linux/man-pages/man7/socket.7.html)
+use cfg_if::cfg_if;
+use crate::{Result, errno::Errno};
 use libc::{self, c_void, c_int, iovec, socklen_t, size_t,
         CMSG_FIRSTHDR, CMSG_NXTHDR, CMSG_DATA, CMSG_LEN};
+use memoffset::offset_of;
 use std::{mem, ptr, slice};
 use std::os::unix::io::RawFd;
-use sys::time::TimeVal;
-use sys::uio::IoVec;
+#[cfg(all(target_os = "linux"))]
+use crate::sys::time::TimeSpec;
+use crate::sys::time::TimeVal;
+use crate::sys::uio::IoVec;
 
 mod addr;
+#[deny(missing_docs)]
 pub mod sockopt;
 
 /*
@@ -19,6 +23,7 @@ pub mod sockopt;
  *
  */
 
+#[cfg(not(any(target_os = "illumos", target_os = "solaris")))]
 pub use self::addr::{
     AddressFamily,
     SockAddr,
@@ -29,12 +34,23 @@ pub use self::addr::{
     Ipv6Addr,
     LinkAddr,
 };
+#[cfg(any(target_os = "illumos", target_os = "solaris"))]
+pub use self::addr::{
+    AddressFamily,
+    SockAddr,
+    InetAddr,
+    UnixAddr,
+    IpAddr,
+    Ipv4Addr,
+    Ipv6Addr,
+};
+
 #[cfg(any(target_os = "android", target_os = "linux"))]
-pub use ::sys::socket::addr::netlink::NetlinkAddr;
+pub use crate::sys::socket::addr::netlink::NetlinkAddr;
 #[cfg(any(target_os = "android", target_os = "linux"))]
-pub use sys::socket::addr::alg::AlgAddr;
-#[cfg(target_os = "linux")]
-pub use sys::socket::addr::vsock::VsockAddr;
+pub use crate::sys::socket::addr::alg::AlgAddr;
+#[cfg(any(target_os = "android", target_os = "linux"))]
+pub use crate::sys::socket::addr::vsock::VsockAddr;
 
 pub use libc::{
     cmsghdr,
@@ -55,6 +71,7 @@ pub use libc::{c_uint, CMSG_SPACE};
 /// when creating a socket with [`socket()`](fn.socket.html)
 #[derive(Clone, Copy, PartialEq, Eq, Debug)]
 #[repr(i32)]
+#[non_exhaustive]
 pub enum SockType {
     /// Provides sequenced, reliable, two-way, connection-
     /// based byte streams.  An out-of-band data transmission
@@ -79,10 +96,11 @@ pub enum SockType {
 /// to specify the protocol to use.
 #[repr(i32)]
 #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+#[non_exhaustive]
 pub enum SockProtocol {
-    /// TCP protocol ([ip(7)](http://man7.org/linux/man-pages/man7/ip.7.html))
+    /// TCP protocol ([ip(7)](https://man7.org/linux/man-pages/man7/ip.7.html))
     Tcp = libc::IPPROTO_TCP,
-    /// UDP protocol ([ip(7)](http://man7.org/linux/man-pages/man7/ip.7.html))
+    /// UDP protocol ([ip(7)](https://man7.org/linux/man-pages/man7/ip.7.html))
     Udp = libc::IPPROTO_UDP,
     /// Allows applications and other KEXTs to be notified when certain kernel events occur
     /// ([ref](https://developer.apple.com/library/content/documentation/Darwin/Conceptual/NKEConceptual/control/control.html))
@@ -92,6 +110,64 @@ pub enum SockProtocol {
     /// ([ref](https://developer.apple.com/library/content/documentation/Darwin/Conceptual/NKEConceptual/control/control.html))
     #[cfg(any(target_os = "ios", target_os = "macos"))]
     KextControl = libc::SYSPROTO_CONTROL,
+    /// Receives routing and link updates and may be used to modify the routing tables (both IPv4 and IPv6), IP addresses, link
+    // parameters, neighbor setups, queueing disciplines, traffic classes and packet classifiers
+    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkRoute = libc::NETLINK_ROUTE,
+    /// Reserved for user-mode socket protocols
+    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkUserSock = libc::NETLINK_USERSOCK,
+    /// Query information about sockets of various protocol families from the kernel
+    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkSockDiag = libc::NETLINK_SOCK_DIAG,
+    /// SELinux event notifications.
+    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkSELinux = libc::NETLINK_SELINUX,
+    /// Open-iSCSI
+    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkISCSI = libc::NETLINK_ISCSI,
+    /// Auditing
+    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkAudit = libc::NETLINK_AUDIT,
+    /// Access to FIB lookup from user space
+    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkFIBLookup = libc::NETLINK_FIB_LOOKUP,
+    /// Netfilter subsystem
+    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkNetFilter = libc::NETLINK_NETFILTER,
+    /// SCSI Transports
+    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkSCSITransport = libc::NETLINK_SCSITRANSPORT,
+    /// Infiniband RDMA
+    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkRDMA = libc::NETLINK_RDMA,
+    /// Transport IPv6 packets from netfilter to user space.  Used by ip6_queue kernel module.
+    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkIPv6Firewall = libc::NETLINK_IP6_FW,
+    /// DECnet routing messages
+    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkDECNetRoutingMessage = libc::NETLINK_DNRTMSG,
+    /// Kernel messages to user space
+    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkKObjectUEvent = libc::NETLINK_KOBJECT_UEVENT,
+    /// Netlink interface to request information about ciphers registered with the kernel crypto API as well as allow
+    /// configuration of the kernel crypto API.
+    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkCrypto = libc::NETLINK_CRYPTO,
 }
 
 libc_bitflags!{
@@ -101,6 +177,7 @@ libc_bitflags!{
         #[cfg(any(target_os = "android",
                   target_os = "dragonfly",
                   target_os = "freebsd",
+                  target_os = "illumos",
                   target_os = "linux",
                   target_os = "netbsd",
                   target_os = "openbsd"))]
@@ -109,6 +186,7 @@ libc_bitflags!{
         #[cfg(any(target_os = "android",
                   target_os = "dragonfly",
                   target_os = "freebsd",
+                  target_os = "illumos",
                   target_os = "linux",
                   target_os = "netbsd",
                   target_os = "openbsd"))]
@@ -144,7 +222,7 @@ libc_bitflags!{
         /// (via the [`fcntl`](../../fcntl/fn.fcntl.html)
         /// `F_SETFL` operation), but differs in that `MSG_DONTWAIT` is a per-
         /// call option, whereas `O_NONBLOCK` is a setting on the open file
-        /// description (see [open(2)](http://man7.org/linux/man-pages/man2/open.2.html)),
+        /// description (see [open(2)](https://man7.org/linux/man-pages/man2/open.2.html)),
         /// which will affect all threads in
         /// the calling process and as well as other processes that hold
         /// file descriptors referring to the same open file description.
@@ -172,7 +250,7 @@ libc_bitflags!{
         /// file descriptor using the `SCM_RIGHTS` operation (described in
         /// [unix(7)](https://linux.die.net/man/7/unix)).
         /// This flag is useful for the same reasons as the `O_CLOEXEC` flag of
-        /// [open(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html).
+        /// [open(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html).
         ///
         /// Only used in [`recvmsg`](fn.recvmsg.html) function.
         #[cfg(any(target_os = "android",
@@ -189,12 +267,22 @@ cfg_if! {
     if #[cfg(any(target_os = "android", target_os = "linux"))] {
         /// Unix credentials of the sending process.
         ///
-        /// This struct is used with the `SO_PEERCRED` ancillary message for UNIX sockets.
-        #[repr(C)]
+        /// This struct is used with the `SO_PEERCRED` ancillary message
+        /// and the `SCM_CREDENTIALS` control message for UNIX sockets.
+        #[repr(transparent)]
         #[derive(Clone, Copy, Debug, Eq, PartialEq)]
         pub struct UnixCredentials(libc::ucred);
 
         impl UnixCredentials {
+            /// Creates a new instance with the credentials of the current process
+            pub fn new() -> Self {
+                UnixCredentials(libc::ucred {
+                    pid: crate::unistd::getpid().as_raw(),
+                    uid: crate::unistd::getuid().as_raw(),
+                    gid: crate::unistd::getgid().as_raw(),
+                })
+            }
+
             /// Returns the process identifier
             pub fn pid(&self) -> libc::pid_t {
                 self.0.pid
@@ -211,15 +299,93 @@ cfg_if! {
             }
         }
 
+        impl Default for UnixCredentials {
+            fn default() -> Self {
+                Self::new()
+            }
+        }
+
         impl From<libc::ucred> for UnixCredentials {
             fn from(cred: libc::ucred) -> Self {
                 UnixCredentials(cred)
             }
         }
 
-        impl Into<libc::ucred> for UnixCredentials {
-            fn into(self) -> libc::ucred {
-                self.0
+        impl From<UnixCredentials> for libc::ucred {
+            fn from(uc: UnixCredentials) -> Self {
+                uc.0
+            }
+        }
+    } else if #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))] {
+        /// Unix credentials of the sending process.
+        ///
+        /// This struct is used with the `SCM_CREDS` ancillary message for UNIX sockets.
+        #[repr(transparent)]
+        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
+        pub struct UnixCredentials(libc::cmsgcred);
+
+        impl UnixCredentials {
+            /// Returns the process identifier
+            pub fn pid(&self) -> libc::pid_t {
+                self.0.cmcred_pid
+            }
+
+            /// Returns the real user identifier
+            pub fn uid(&self) -> libc::uid_t {
+                self.0.cmcred_uid
+            }
+
+            /// Returns the effective user identifier
+            pub fn euid(&self) -> libc::uid_t {
+                self.0.cmcred_euid
+            }
+
+            /// Returns the real group identifier
+            pub fn gid(&self) -> libc::gid_t {
+                self.0.cmcred_gid
+            }
+
+            /// Returns a list group identifiers (the first one being the effective GID)
+            pub fn groups(&self) -> &[libc::gid_t] {
+                unsafe { slice::from_raw_parts(self.0.cmcred_groups.as_ptr() as *const libc::gid_t, self.0.cmcred_ngroups as _) }
+            }
+        }
+
+        impl From<libc::cmsgcred> for UnixCredentials {
+            fn from(cred: libc::cmsgcred) -> Self {
+                UnixCredentials(cred)
+            }
+        }
+    }
+}
+
+cfg_if!{
+    if #[cfg(any(
+                target_os = "dragonfly",
+                target_os = "freebsd",
+                target_os = "macos",
+                target_os = "ios"
+        ))] {
+        /// Return type of [`LocalPeerCred`](crate::sys::socket::sockopt::LocalPeerCred)
+        #[repr(transparent)]
+        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
+        pub struct XuCred(libc::xucred);
+
+        impl XuCred {
+            /// Structure layout version
+            pub fn version(&self) -> u32 {
+                self.0.cr_version
+            }
+
+            /// Effective user ID
+            pub fn uid(&self) -> libc::uid_t {
+                self.0.cr_uid
+            }
+
+            /// Returns a list of group identifiers (the first one being the
+            /// effective GID)
+            pub fn groups(&self) -> &[libc::gid_t] {
+                &self.0.cr_groups
             }
         }
     }
@@ -228,7 +394,7 @@ cfg_if! {
 /// Request for multicast socket operations
 ///
 /// This is a wrapper type around `ip_mreq`.
-#[repr(C)]
+#[repr(transparent)]
 #[derive(Clone, Copy, Debug, Eq, PartialEq)]
 pub struct IpMembershipRequest(libc::ip_mreq);
 
@@ -247,13 +413,13 @@ impl IpMembershipRequest {
 /// Request for ipv6 multicast socket operations
 ///
 /// This is a wrapper type around `ipv6_mreq`.
-#[repr(C)]
+#[repr(transparent)]
 #[derive(Clone, Copy, Debug, Eq, PartialEq)]
 pub struct Ipv6MembershipRequest(libc::ipv6_mreq);
 
 impl Ipv6MembershipRequest {
     /// Instantiate a new `Ipv6MembershipRequest`
-    pub fn new(group: Ipv6Addr) -> Self {
+    pub const fn new(group: Ipv6Addr) -> Self {
         Ipv6MembershipRequest(libc::ipv6_mreq {
             ipv6mr_multiaddr: group.0,
             ipv6mr_interface: 0,
@@ -261,21 +427,6 @@ impl Ipv6MembershipRequest {
     }
 }
 
-cfg_if! {
-    // Darwin and DragonFly BSD always align struct cmsghdr to 32-bit only.
-    if #[cfg(any(target_os = "dragonfly", target_os = "ios", target_os = "macos"))] {
-        type align_of_cmsg_data = u32;
-    } else {
-        type align_of_cmsg_data = size_t;
-    }
-}
-
-/// A type that can be used to store ancillary data received by
-/// [`recvmsg`](fn.recvmsg.html)
-pub trait CmsgBuffer {
-    fn as_bytes_mut(&mut self) -> &mut [u8];
-}
-
 /// Create a buffer large enough for storing some control messages as returned
 /// by [`recvmsg`](fn.recvmsg.html).
 ///
@@ -302,70 +453,18 @@ pub trait CmsgBuffer {
 macro_rules! cmsg_space {
     ( $( $x:ty ),* ) => {
         {
-            use nix::sys::socket::{c_uint, CMSG_SPACE};
-            use std::mem;
             let mut space = 0;
             $(
                 // CMSG_SPACE is always safe
                 space += unsafe {
-                    CMSG_SPACE(mem::size_of::<$x>() as c_uint)
+                    $crate::sys::socket::CMSG_SPACE(::std::mem::size_of::<$x>() as $crate::sys::socket::c_uint)
                 } as usize;
             )*
-            let mut v = Vec::<u8>::with_capacity(space);
-            // safe because any bit pattern is a valid u8
-            unsafe {v.set_len(space)};
-            v
-        }
-    }
-}
-
-/// A structure used to make room in a cmsghdr passed to recvmsg. The
-/// size and alignment match that of a cmsghdr followed by a T, but the
-/// fields are not accessible, as the actual types will change on a call
-/// to recvmsg.
-///
-/// To make room for multiple messages, nest the type parameter with
-/// tuples:
-///
-/// ```
-/// use std::os::unix::io::RawFd;
-/// use nix::sys::socket::CmsgSpace;
-/// let cmsg: CmsgSpace<([RawFd; 3], CmsgSpace<[RawFd; 2]>)> = CmsgSpace::new();
-/// ```
-#[repr(C)]
-#[derive(Clone, Copy, Debug, Eq, PartialEq)]
-pub struct CmsgSpace<T> {
-    _hdr: cmsghdr,
-    _pad: [align_of_cmsg_data; 0],
-    _data: T,
-}
-
-impl<T> CmsgSpace<T> {
-    /// Create a CmsgSpace<T>. The structure is used only for space, so
-    /// the fields are uninitialized.
-    #[deprecated( since="0.14.0", note="Use the cmsg_space! macro instead")]
-    pub fn new() -> Self {
-        // Safe because the fields themselves aren't accessible.
-        unsafe { mem::uninitialized() }
-    }
-}
-
-impl<T> CmsgBuffer for CmsgSpace<T> {
-    fn as_bytes_mut(&mut self) -> &mut [u8] {
-        // Safe because nothing ever attempts to access CmsgSpace's fields
-        unsafe {
-            slice::from_raw_parts_mut(self as *mut CmsgSpace<T> as *mut u8,
-                                      mem::size_of::<Self>())
+            Vec::<u8>::with_capacity(space)
         }
     }
 }
 
-impl CmsgBuffer for Vec<u8> {
-    fn as_bytes_mut(&mut self) -> &mut [u8] {
-        &mut self[..]
-    }
-}
-
 #[derive(Clone, Copy, Debug, Eq, PartialEq)]
 pub struct RecvMsg<'a> {
     pub bytes: usize,
@@ -418,7 +517,7 @@ impl<'a> Iterator for CmsgIterator<'a> {
 /// A type-safe wrapper around a single control message, as used with
 /// [`recvmsg`](#fn.recvmsg).
 ///
-/// [Further reading](http://man7.org/linux/man-pages/man3/cmsg.3.html)
+/// [Further reading](https://man7.org/linux/man-pages/man3/cmsg.3.html)
 //  Nix version 0.13.0 and earlier used ControlMessage for both recvmsg and
 //  sendmsg.  However, on some platforms the messages returned by recvmsg may be
 //  unaligned.  ControlMessageOwned takes those messages by copy, obviating any
@@ -426,14 +525,16 @@ impl<'a> Iterator for CmsgIterator<'a> {
 //
 //  See https://github.com/nix-rust/nix/issues/999
 #[derive(Clone, Debug, Eq, PartialEq)]
+#[non_exhaustive]
 pub enum ControlMessageOwned {
-    /// Received version of
-    /// [`ControlMessage::ScmRights`][#enum.ControlMessage.html#variant.ScmRights]
+    /// Received version of [`ControlMessage::ScmRights`]
     ScmRights(Vec<RawFd>),
-    /// Received version of
-    /// [`ControlMessage::ScmCredentials`][#enum.ControlMessage.html#variant.ScmCredentials]
+    /// Received version of [`ControlMessage::ScmCredentials`]
     #[cfg(any(target_os = "android", target_os = "linux"))]
-    ScmCredentials(libc::ucred),
+    ScmCredentials(UnixCredentials),
+    /// Received version of [`ControlMessage::ScmCreds`]
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    ScmCreds(UnixCredentials),
     /// A message of type `SCM_TIMESTAMP`, containing the time the
     /// packet was received by the kernel.
     ///
@@ -442,10 +543,7 @@ pub enum ControlMessageOwned {
     ///
     /// # Examples
     ///
-    // Disable this test on FreeBSD i386
-    // https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=222039
-    #[cfg_attr(not(all(target_os = "freebsd", target_arch = "x86")), doc = " ```")]
-    #[cfg_attr(all(target_os = "freebsd", target_arch = "x86"), doc = " ```no_run")]
+    /// ```
     /// # #[macro_use] extern crate nix;
     /// # use nix::sys::socket::*;
     /// # use nix::sys::uio::IoVec;
@@ -493,6 +591,11 @@ pub enum ControlMessageOwned {
     /// # }
     /// ```
     ScmTimestamp(TimeVal),
+    /// Nanoseconds resolution timestamp
+    ///
+    /// [Further reading](https://www.kernel.org/doc/html/latest/networking/timestamping.html)
+    #[cfg(all(target_os = "linux"))]
+    ScmTimestampns(TimeSpec),
     #[cfg(any(
         target_os = "android",
         target_os = "ios",
@@ -528,6 +631,36 @@ pub enum ControlMessageOwned {
         target_os = "openbsd",
     ))]
     Ipv4RecvDstAddr(libc::in_addr),
+
+    /// UDP Generic Receive Offload (GRO) allows receiving multiple UDP
+    /// packets from a single sender.
+    /// Fixed-size payloads are following one by one in a receive buffer.
+    /// This Control Message indicates the size of all smaller packets,
+    /// except, maybe, the last one.
+    ///
+    /// `UdpGroSegment` socket option should be enabled on a socket
+    /// to allow receiving GRO packets.
+    #[cfg(target_os = "linux")]
+    UdpGroSegments(u16),
+
+    /// SO_RXQ_OVFL indicates that an unsigned 32 bit value
+    /// ancilliary msg (cmsg) should be attached to recieved
+    /// skbs indicating the number of packets dropped by the
+    /// socket between the last recieved packet and this
+    /// received packet.
+    ///
+    /// `RxqOvfl` socket option should be enabled on a socket
+    /// to allow receiving the drop counter.
+    #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+    RxqOvfl(u32),
+
+    /// Socket error queue control messages read with the `MSG_ERRQUEUE` flag.
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Ipv4RecvErr(libc::sock_extended_err, Option<sockaddr_in>),
+    /// Socket error queue control messages read with the `MSG_ERRQUEUE` flag.
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Ipv6RecvErr(libc::sock_extended_err, Option<sockaddr_in6>),
+
     /// Catch-all variant for unimplemented cmsg types.
     #[doc(hidden)]
     Unknown(UnknownCmsg),
@@ -540,9 +673,9 @@ impl ControlMessageOwned {
     /// specified in the header. Normally, the kernel ensures that this is the
     /// case. "Correct" in this case includes correct length, alignment and
     /// actual content.
-    ///
-    /// Returns `None` if the data may be unaligned.  In that case use
-    /// `ControlMessageOwned::decode_from`.
+    // Clippy complains about the pointer alignment of `p`, not understanding
+    // that it's being fed to a function that can handle that.
+    #[allow(clippy::cast_ptr_alignment)]
     unsafe fn decode_from(header: &cmsghdr) -> ControlMessageOwned
     {
         let p = CMSG_DATA(header);
@@ -553,21 +686,30 @@ impl ControlMessageOwned {
                 let n = len / mem::size_of::<RawFd>();
                 let mut fds = Vec::with_capacity(n);
                 for i in 0..n {
-                    let fdp = (p as *const RawFd).offset(i as isize);
+                    let fdp = (p as *const RawFd).add(i);
                     fds.push(ptr::read_unaligned(fdp));
                 }
-                let cmo = ControlMessageOwned::ScmRights(fds);
-                cmo
+                ControlMessageOwned::ScmRights(fds)
             },
             #[cfg(any(target_os = "android", target_os = "linux"))]
             (libc::SOL_SOCKET, libc::SCM_CREDENTIALS) => {
                 let cred: libc::ucred = ptr::read_unaligned(p as *const _);
-                ControlMessageOwned::ScmCredentials(cred)
+                ControlMessageOwned::ScmCredentials(cred.into())
+            }
+            #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+            (libc::SOL_SOCKET, libc::SCM_CREDS) => {
+                let cred: libc::cmsgcred = ptr::read_unaligned(p as *const _);
+                ControlMessageOwned::ScmCreds(cred.into())
             }
             (libc::SOL_SOCKET, libc::SCM_TIMESTAMP) => {
                 let tv: libc::timeval = ptr::read_unaligned(p as *const _);
                 ControlMessageOwned::ScmTimestamp(TimeVal::from(tv))
             },
+            #[cfg(all(target_os = "linux"))]
+            (libc::SOL_SOCKET, libc::SCM_TIMESTAMPNS) => {
+                let ts: libc::timespec = ptr::read_unaligned(p as *const _);
+                ControlMessageOwned::ScmTimestampns(TimeSpec::from(ts))
+            }
             #[cfg(any(
                 target_os = "android",
                 target_os = "freebsd",
@@ -612,27 +754,66 @@ impl ControlMessageOwned {
                 let dl = ptr::read_unaligned(p as *const libc::in_addr);
                 ControlMessageOwned::Ipv4RecvDstAddr(dl)
             },
+            #[cfg(target_os = "linux")]
+            (libc::SOL_UDP, libc::UDP_GRO) => {
+                let gso_size: u16 = ptr::read_unaligned(p as *const _);
+                ControlMessageOwned::UdpGroSegments(gso_size)
+            },
+            #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+            (libc::SOL_SOCKET, libc::SO_RXQ_OVFL) => {
+                let drop_counter = ptr::read_unaligned(p as *const u32);
+                ControlMessageOwned::RxqOvfl(drop_counter)
+            },
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            (libc::IPPROTO_IP, libc::IP_RECVERR) => {
+                let (err, addr) = Self::recv_err_helper::<sockaddr_in>(p, len);
+                ControlMessageOwned::Ipv4RecvErr(err, addr)
+            },
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            (libc::IPPROTO_IPV6, libc::IPV6_RECVERR) => {
+                let (err, addr) = Self::recv_err_helper::<sockaddr_in6>(p, len);
+                ControlMessageOwned::Ipv6RecvErr(err, addr)
+            },
             (_, _) => {
                 let sl = slice::from_raw_parts(p, len);
-                let ucmsg = UnknownCmsg(*header, Vec::<u8>::from(&sl[..]));
+                let ucmsg = UnknownCmsg(*header, Vec::<u8>::from(sl));
                 ControlMessageOwned::Unknown(ucmsg)
             }
         }
     }
+
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    unsafe fn recv_err_helper<T>(p: *mut libc::c_uchar, len: usize) -> (libc::sock_extended_err, Option<T>) {
+        let ee = p as *const libc::sock_extended_err;
+        let err = ptr::read_unaligned(ee);
+
+        // For errors originating on the network, SO_EE_OFFENDER(ee) points inside the p[..len]
+        // CMSG_DATA buffer.  For local errors, there is no address included in the control
+        // message, and SO_EE_OFFENDER(ee) points beyond the end of the buffer.  So, we need to
+        // validate that the address object is in-bounds before we attempt to copy it.
+        let addrp = libc::SO_EE_OFFENDER(ee) as *const T;
+
+        if addrp.offset(1) as usize - (p as usize) > len {
+            (err, None)
+        } else {
+            (err, Some(ptr::read_unaligned(addrp)))
+        }
+    }
 }
 
 /// A type-safe zero-copy wrapper around a single control message, as used wih
 /// [`sendmsg`](#fn.sendmsg).  More types may be added to this enum; do not
 /// exhaustively pattern-match it.
 ///
-/// [Further reading](http://man7.org/linux/man-pages/man3/cmsg.3.html)
+/// [Further reading](https://man7.org/linux/man-pages/man3/cmsg.3.html)
 #[derive(Clone, Copy, Debug, Eq, PartialEq)]
+#[non_exhaustive]
 pub enum ControlMessage<'a> {
     /// A message of type `SCM_RIGHTS`, containing an array of file
     /// descriptors passed between processes.
     ///
     /// See the description in the "Ancillary messages" section of the
-    /// [unix(7) man page](http://man7.org/linux/man-pages/man7/unix.7.html).
+    /// [unix(7) man page](https://man7.org/linux/man-pages/man7/unix.7.html).
     ///
     /// Using multiple `ScmRights` messages for a single `sendmsg` call isn't
     /// recommended since it causes platform-dependent behaviour: It might
@@ -649,11 +830,23 @@ pub enum ControlMessage<'a> {
     /// processes are verified by the kernel.
     ///
     /// For further information, please refer to the
-    /// [`unix(7)`](http://man7.org/linux/man-pages/man7/unix.7.html) man page.
-    // FIXME: When `#[repr(transparent)]` is stable, use it on `UnixCredentials`
-    // and put that in here instead of a raw ucred.
+    /// [`unix(7)`](https://man7.org/linux/man-pages/man7/unix.7.html) man page.
     #[cfg(any(target_os = "android", target_os = "linux"))]
-    ScmCredentials(&'a libc::ucred),
+    ScmCredentials(&'a UnixCredentials),
+    /// A message of type `SCM_CREDS`, containing the pid, uid, euid, gid and groups of
+    /// a process connected to the socket.
+    ///
+    /// This is similar to the socket options `LOCAL_CREDS` and `LOCAL_PEERCRED`, but
+    /// requires a process to explicitly send its credentials.
+    ///
+    /// Credentials are always overwritten by the kernel, so this variant does have
+    /// any data, unlike the receive-side
+    /// [`ControlMessageOwned::ScmCreds`].
+    ///
+    /// For further information, please refer to the
+    /// [`unix(4)`](https://www.freebsd.org/cgi/man.cgi?query=unix) man page.
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    ScmCreds,
 
     /// Set IV for `AF_ALG` crypto API.
     ///
@@ -685,6 +878,47 @@ pub enum ControlMessage<'a> {
     ))]
     AlgSetAeadAssoclen(&'a u32),
 
+    /// UDP GSO makes it possible for applications to generate network packets
+    /// for a virtual MTU much greater than the real one.
+    /// The length of the send data no longer matches the expected length on
+    /// the wire.
+    /// The size of the datagram payload as it should appear on the wire may be
+    /// passed through this control message.
+    /// Send buffer should consist of multiple fixed-size wire payloads
+    /// following one by one, and the last, possibly smaller one.
+    #[cfg(target_os = "linux")]
+    UdpGsoSegments(&'a u16),
+
+    /// Configure the sending addressing and interface for v4
+    ///
+    /// For further information, please refer to the
+    /// [`ip(7)`](https://man7.org/linux/man-pages/man7/ip.7.html) man page.
+    #[cfg(any(target_os = "linux",
+              target_os = "macos",
+              target_os = "netbsd",
+              target_os = "android",
+              target_os = "ios",))]
+    Ipv4PacketInfo(&'a libc::in_pktinfo),
+
+    /// Configure the sending addressing and interface for v6
+    ///
+    /// For further information, please refer to the
+    /// [`ipv6(7)`](https://man7.org/linux/man-pages/man7/ipv6.7.html) man page.
+    #[cfg(any(target_os = "linux",
+              target_os = "macos",
+              target_os = "netbsd",
+              target_os = "freebsd",
+              target_os = "android",
+              target_os = "ios",))]
+    Ipv6PacketInfo(&'a libc::in6_pktinfo),
+
+    /// SO_RXQ_OVFL indicates that an unsigned 32 bit value
+    /// ancilliary msg (cmsg) should be attached to recieved
+    /// skbs indicating the number of packets dropped by the
+    /// socket between the last recieved packet and this
+    /// received packet.
+    #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+    RxqOvfl(&'a u32),
 }
 
 // An opaque structure used to prevent cmsghdr from being a public type
@@ -715,35 +949,70 @@ impl<'a> ControlMessage<'a> {
 
     /// Return a reference to the payload data as a byte pointer
     fn copy_to_cmsg_data(&self, cmsg_data: *mut u8) {
-        let data_ptr = match self {
-            &ControlMessage::ScmRights(fds) => {
+        let data_ptr = match *self {
+            ControlMessage::ScmRights(fds) => {
                 fds as *const _ as *const u8
             },
             #[cfg(any(target_os = "android", target_os = "linux"))]
-            &ControlMessage::ScmCredentials(creds) => {
-                creds as *const libc::ucred as *const u8
+            ControlMessage::ScmCredentials(creds) => {
+                &creds.0 as *const libc::ucred as *const u8
+            }
+            #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+            ControlMessage::ScmCreds => {
+                // The kernel overwrites the data, we just zero it
+                // to make sure it's not uninitialized memory
+                unsafe { ptr::write_bytes(cmsg_data, 0, self.len()) };
+                return
             }
             #[cfg(any(target_os = "android", target_os = "linux"))]
-            &ControlMessage::AlgSetIv(iv) => {
+            ControlMessage::AlgSetIv(iv) => {
+                #[allow(deprecated)] // https://github.com/rust-lang/libc/issues/1501
+                let af_alg_iv = libc::af_alg_iv {
+                    ivlen: iv.len() as u32,
+                    iv: [0u8; 0],
+                };
+
+                let size = mem::size_of_val(&af_alg_iv);
+
                 unsafe {
-                    let alg_iv = cmsg_data as *mut libc::af_alg_iv;
-                    (*alg_iv).ivlen = iv.len() as u32;
+                    ptr::copy_nonoverlapping(
+                        &af_alg_iv as *const _ as *const u8,
+                        cmsg_data,
+                        size,
+                    );
                     ptr::copy_nonoverlapping(
                         iv.as_ptr(),
-                        (*alg_iv).iv.as_mut_ptr(),
+                        cmsg_data.add(size),
                         iv.len()
                     );
                 };
+
                 return
             },
             #[cfg(any(target_os = "android", target_os = "linux"))]
-            &ControlMessage::AlgSetOp(op) => {
+            ControlMessage::AlgSetOp(op) => {
                 op as *const _ as *const u8
             },
             #[cfg(any(target_os = "android", target_os = "linux"))]
-            &ControlMessage::AlgSetAeadAssoclen(len) => {
+            ControlMessage::AlgSetAeadAssoclen(len) => {
                 len as *const _ as *const u8
             },
+            #[cfg(target_os = "linux")]
+            ControlMessage::UdpGsoSegments(gso_size) => {
+                gso_size as *const _ as *const u8
+            },
+            #[cfg(any(target_os = "linux", target_os = "macos",
+                      target_os = "netbsd", target_os = "android",
+                      target_os = "ios",))]
+            ControlMessage::Ipv4PacketInfo(info) => info as *const _ as *const u8,
+            #[cfg(any(target_os = "linux", target_os = "macos",
+                      target_os = "netbsd", target_os = "freebsd",
+                      target_os = "android", target_os = "ios",))]
+            ControlMessage::Ipv6PacketInfo(info) => info as *const _ as *const u8,
+            #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+            ControlMessage::RxqOvfl(drop_count) => {
+                drop_count as *const _ as *const u8
+            },
         };
         unsafe {
             ptr::copy_nonoverlapping(
@@ -756,60 +1025,111 @@ impl<'a> ControlMessage<'a> {
 
     /// The size of the payload, excluding its cmsghdr
     fn len(&self) -> usize {
-        match self {
-            &ControlMessage::ScmRights(fds) => {
+        match *self {
+            ControlMessage::ScmRights(fds) => {
                 mem::size_of_val(fds)
             },
             #[cfg(any(target_os = "android", target_os = "linux"))]
-            &ControlMessage::ScmCredentials(creds) => {
+            ControlMessage::ScmCredentials(creds) => {
                 mem::size_of_val(creds)
             }
+            #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+            ControlMessage::ScmCreds => {
+                mem::size_of::<libc::cmsgcred>()
+            }
             #[cfg(any(target_os = "android", target_os = "linux"))]
-            &ControlMessage::AlgSetIv(iv) => {
-                mem::size_of::<libc::af_alg_iv>() + iv.len()
+            ControlMessage::AlgSetIv(iv) => {
+                mem::size_of_val(&iv) + iv.len()
             },
             #[cfg(any(target_os = "android", target_os = "linux"))]
-            &ControlMessage::AlgSetOp(op) => {
+            ControlMessage::AlgSetOp(op) => {
                 mem::size_of_val(op)
             },
             #[cfg(any(target_os = "android", target_os = "linux"))]
-            &ControlMessage::AlgSetAeadAssoclen(len) => {
+            ControlMessage::AlgSetAeadAssoclen(len) => {
                 mem::size_of_val(len)
             },
+            #[cfg(target_os = "linux")]
+            ControlMessage::UdpGsoSegments(gso_size) => {
+                mem::size_of_val(gso_size)
+            },
+            #[cfg(any(target_os = "linux", target_os = "macos",
+              target_os = "netbsd", target_os = "android",
+              target_os = "ios",))]
+            ControlMessage::Ipv4PacketInfo(info) => mem::size_of_val(info),
+            #[cfg(any(target_os = "linux", target_os = "macos",
+              target_os = "netbsd", target_os = "freebsd",
+              target_os = "android", target_os = "ios",))]
+            ControlMessage::Ipv6PacketInfo(info) => mem::size_of_val(info),
+            #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+            ControlMessage::RxqOvfl(drop_count) => {
+                mem::size_of_val(drop_count)
+            },
         }
     }
 
     /// Returns the value to put into the `cmsg_level` field of the header.
     fn cmsg_level(&self) -> libc::c_int {
-        match self {
-            &ControlMessage::ScmRights(_) => libc::SOL_SOCKET,
+        match *self {
+            ControlMessage::ScmRights(_) => libc::SOL_SOCKET,
             #[cfg(any(target_os = "android", target_os = "linux"))]
-            &ControlMessage::ScmCredentials(_) => libc::SOL_SOCKET,
+            ControlMessage::ScmCredentials(_) => libc::SOL_SOCKET,
+            #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+            ControlMessage::ScmCreds => libc::SOL_SOCKET,
             #[cfg(any(target_os = "android", target_os = "linux"))]
-            &ControlMessage::AlgSetIv(_) | &ControlMessage::AlgSetOp(_) | &ControlMessage::AlgSetAeadAssoclen(_) => {
-                libc::SOL_ALG
-            },
+            ControlMessage::AlgSetIv(_) | ControlMessage::AlgSetOp(_) |
+                ControlMessage::AlgSetAeadAssoclen(_) => libc::SOL_ALG,
+            #[cfg(target_os = "linux")]
+            ControlMessage::UdpGsoSegments(_) => libc::SOL_UDP,
+            #[cfg(any(target_os = "linux", target_os = "macos",
+                      target_os = "netbsd", target_os = "android",
+                      target_os = "ios",))]
+            ControlMessage::Ipv4PacketInfo(_) => libc::IPPROTO_IP,
+            #[cfg(any(target_os = "linux", target_os = "macos",
+              target_os = "netbsd", target_os = "freebsd",
+              target_os = "android", target_os = "ios",))]
+            ControlMessage::Ipv6PacketInfo(_) => libc::IPPROTO_IPV6,
+            #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+            ControlMessage::RxqOvfl(_) => libc::SOL_SOCKET,
         }
     }
 
     /// Returns the value to put into the `cmsg_type` field of the header.
     fn cmsg_type(&self) -> libc::c_int {
-        match self {
-            &ControlMessage::ScmRights(_) => libc::SCM_RIGHTS,
+        match *self {
+            ControlMessage::ScmRights(_) => libc::SCM_RIGHTS,
             #[cfg(any(target_os = "android", target_os = "linux"))]
-            &ControlMessage::ScmCredentials(_) => libc::SCM_CREDENTIALS,
+            ControlMessage::ScmCredentials(_) => libc::SCM_CREDENTIALS,
+            #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+            ControlMessage::ScmCreds => libc::SCM_CREDS,
             #[cfg(any(target_os = "android", target_os = "linux"))]
-            &ControlMessage::AlgSetIv(_) => {
+            ControlMessage::AlgSetIv(_) => {
                 libc::ALG_SET_IV
             },
             #[cfg(any(target_os = "android", target_os = "linux"))]
-            &ControlMessage::AlgSetOp(_) => {
+            ControlMessage::AlgSetOp(_) => {
                 libc::ALG_SET_OP
             },
             #[cfg(any(target_os = "android", target_os = "linux"))]
-            &ControlMessage::AlgSetAeadAssoclen(_) => {
+            ControlMessage::AlgSetAeadAssoclen(_) => {
                 libc::ALG_SET_AEAD_ASSOCLEN
             },
+            #[cfg(target_os = "linux")]
+            ControlMessage::UdpGsoSegments(_) => {
+                libc::UDP_SEGMENT
+            },
+            #[cfg(any(target_os = "linux", target_os = "macos",
+                      target_os = "netbsd", target_os = "android",
+                      target_os = "ios",))]
+            ControlMessage::Ipv4PacketInfo(_) => libc::IP_PKTINFO,
+            #[cfg(any(target_os = "linux", target_os = "macos",
+                      target_os = "netbsd", target_os = "freebsd",
+                      target_os = "android", target_os = "ios",))]
+            ControlMessage::Ipv6PacketInfo(_) => libc::IPV6_PKTINFO,
+            #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+            ControlMessage::RxqOvfl(_) => {
+                libc::SO_RXQ_OVFL
+            },
         }
     }
 
@@ -836,12 +1156,303 @@ pub fn sendmsg(fd: RawFd, iov: &[IoVec<&[u8]>], cmsgs: &[ControlMessage],
 
     // First size the buffer needed to hold the cmsgs.  It must be zeroed,
     // because subsequent code will not clear the padding bytes.
-    let cmsg_buffer = vec![0u8; capacity];
+    let mut cmsg_buffer = vec![0u8; capacity];
+
+    let mhdr = pack_mhdr_to_send(&mut cmsg_buffer[..], &iov, &cmsgs, addr);
+
+    let ret = unsafe { libc::sendmsg(fd, &mhdr, flags.bits()) };
+
+    Errno::result(ret).map(|r| r as usize)
+}
+
+#[cfg(any(
+    target_os = "linux",
+    target_os = "android",
+    target_os = "freebsd",
+    target_os = "netbsd",
+))]
+#[derive(Debug)]
+pub struct SendMmsgData<'a, I, C>
+    where
+        I: AsRef<[IoVec<&'a [u8]>]>,
+        C: AsRef<[ControlMessage<'a>]>
+{
+    pub iov: I,
+    pub cmsgs: C,
+    pub addr: Option<SockAddr>,
+    pub _lt: std::marker::PhantomData<&'a I>,
+}
+
+/// An extension of `sendmsg` that allows the caller to transmit multiple
+/// messages on a socket using a single system call. This has performance
+/// benefits for some applications.
+///
+/// Allocations are performed for cmsgs and to build `msghdr` buffer
+///
+/// # Arguments
+///
+/// * `fd`:             Socket file descriptor
+/// * `data`:           Struct that implements `IntoIterator` with `SendMmsgData` items
+/// * `flags`:          Optional flags passed directly to the operating system.
+///
+/// # Returns
+/// `Vec` with numbers of sent bytes on each sent message.
+///
+/// # References
+/// [`sendmsg`](fn.sendmsg.html)
+#[cfg(any(
+    target_os = "linux",
+    target_os = "android",
+    target_os = "freebsd",
+    target_os = "netbsd",
+))]
+pub fn sendmmsg<'a, I, C>(
+    fd: RawFd,
+    data: impl std::iter::IntoIterator<Item=&'a SendMmsgData<'a, I, C>>,
+    flags: MsgFlags
+) -> Result<Vec<usize>>
+    where
+        I: AsRef<[IoVec<&'a [u8]>]> + 'a,
+        C: AsRef<[ControlMessage<'a>]> + 'a,
+{
+    let iter = data.into_iter();
+
+    let size_hint = iter.size_hint();
+    let reserve_items = size_hint.1.unwrap_or(size_hint.0);
+
+    let mut output = Vec::<libc::mmsghdr>::with_capacity(reserve_items);
+
+    let mut cmsgs_buffers = Vec::<Vec<u8>>::with_capacity(reserve_items);
+
+    for d in iter {
+        let capacity: usize = d.cmsgs.as_ref().iter().map(|c| c.space()).sum();
+        let mut cmsgs_buffer = vec![0u8; capacity];
+
+        output.push(libc::mmsghdr {
+            msg_hdr: pack_mhdr_to_send(
+                &mut cmsgs_buffer,
+                &d.iov,
+                &d.cmsgs,
+                d.addr.as_ref()
+            ),
+            msg_len: 0,
+        });
+        cmsgs_buffers.push(cmsgs_buffer);
+    };
+
+    let ret = unsafe { libc::sendmmsg(fd, output.as_mut_ptr(), output.len() as _, flags.bits() as _) };
+
+    let sent_messages = Errno::result(ret)? as usize;
+    let mut sent_bytes = Vec::with_capacity(sent_messages);
+
+    for item in &output {
+        sent_bytes.push(item.msg_len as usize);
+    }
+
+    Ok(sent_bytes)
+}
+
+
+#[cfg(any(
+    target_os = "linux",
+    target_os = "android",
+    target_os = "freebsd",
+    target_os = "netbsd",
+))]
+#[derive(Debug)]
+pub struct RecvMmsgData<'a, I>
+    where
+        I: AsRef<[IoVec<&'a mut [u8]>]> + 'a,
+{
+    pub iov: I,
+    pub cmsg_buffer: Option<&'a mut Vec<u8>>,
+}
+
+/// An extension of `recvmsg` that allows the caller to receive multiple
+/// messages from a socket using a single system call. This has
+/// performance benefits for some applications.
+///
+/// `iov` and `cmsg_buffer` should be constructed similarly to `recvmsg`
+///
+/// Multiple allocations are performed
+///
+/// # Arguments
+///
+/// * `fd`:             Socket file descriptor
+/// * `data`:           Struct that implements `IntoIterator` with `RecvMmsgData` items
+/// * `flags`:          Optional flags passed directly to the operating system.
+///
+/// # RecvMmsgData
+///
+/// * `iov`:            Scatter-gather list of buffers to receive the message
+/// * `cmsg_buffer`:    Space to receive ancillary data.  Should be created by
+///                     [`cmsg_space!`](macro.cmsg_space.html)
+///
+/// # Returns
+/// A `Vec` with multiple `RecvMsg`, one per received message
+///
+/// # References
+/// - [`recvmsg`](fn.recvmsg.html)
+/// - [`RecvMsg`](struct.RecvMsg.html)
+#[cfg(any(
+    target_os = "linux",
+    target_os = "android",
+    target_os = "freebsd",
+    target_os = "netbsd",
+))]
+#[allow(clippy::needless_collect)]  // Complicated false positive
+pub fn recvmmsg<'a, I>(
+    fd: RawFd,
+    data: impl std::iter::IntoIterator<Item=&'a mut RecvMmsgData<'a, I>,
+        IntoIter=impl ExactSizeIterator + Iterator<Item=&'a mut RecvMmsgData<'a, I>>>,
+    flags: MsgFlags,
+    timeout: Option<crate::sys::time::TimeSpec>
+) -> Result<Vec<RecvMsg<'a>>>
+    where
+        I: AsRef<[IoVec<&'a mut [u8]>]> + 'a,
+{
+    let iter = data.into_iter();
+
+    let num_messages = iter.len();
+
+    let mut output: Vec<libc::mmsghdr> = Vec::with_capacity(num_messages);
+
+    // Addresses should be pre-allocated.  pack_mhdr_to_receive will store them
+    // as raw pointers, so we may not move them.  Turn the vec into a boxed
+    // slice so we won't inadvertently reallocate the vec.
+    let mut addresses = vec![mem::MaybeUninit::uninit(); num_messages]
+        .into_boxed_slice();
+
+    let results: Vec<_> = iter.enumerate().map(|(i, d)| {
+        let (msg_controllen, mhdr) = unsafe {
+            pack_mhdr_to_receive(
+                d.iov.as_ref(),
+                &mut d.cmsg_buffer,
+                addresses[i].as_mut_ptr(),
+            )
+        };
+
+        output.push(
+            libc::mmsghdr {
+                msg_hdr: mhdr,
+                msg_len: 0,
+            }
+        );
+
+        (msg_controllen as usize, &mut d.cmsg_buffer)
+    }).collect();
+
+    let timeout = if let Some(mut t) = timeout {
+        t.as_mut() as *mut libc::timespec
+    } else {
+        ptr::null_mut()
+    };
+
+    let ret = unsafe { libc::recvmmsg(fd, output.as_mut_ptr(), output.len() as _, flags.bits() as _, timeout) };
+
+    let _ = Errno::result(ret)?;
+
+    Ok(output
+        .into_iter()
+        .take(ret as usize)
+        .zip(addresses.iter().map(|addr| unsafe{addr.assume_init()}))
+        .zip(results.into_iter())
+        .map(|((mmsghdr, address), (msg_controllen, cmsg_buffer))| {
+            unsafe {
+                read_mhdr(
+                    mmsghdr.msg_hdr,
+                    mmsghdr.msg_len as isize,
+                    msg_controllen,
+                    address,
+                    cmsg_buffer
+                )
+            }
+        })
+        .collect())
+}
+
+unsafe fn read_mhdr<'a, 'b>(
+    mhdr: msghdr,
+    r: isize,
+    msg_controllen: usize,
+    address: sockaddr_storage,
+    cmsg_buffer: &'a mut Option<&'b mut Vec<u8>>
+) -> RecvMsg<'b> {
+    let cmsghdr = {
+        if mhdr.msg_controllen > 0 {
+            // got control message(s)
+            cmsg_buffer
+                .as_mut()
+                .unwrap()
+                .set_len(mhdr.msg_controllen as usize);
+            debug_assert!(!mhdr.msg_control.is_null());
+            debug_assert!(msg_controllen >= mhdr.msg_controllen as usize);
+            CMSG_FIRSTHDR(&mhdr as *const msghdr)
+        } else {
+            ptr::null()
+        }.as_ref()
+    };
+
+    let address = sockaddr_storage_to_addr(
+        &address ,
+         mhdr.msg_namelen as usize
+    ).ok();
+
+    RecvMsg {
+        bytes: r as usize,
+        cmsghdr,
+        address,
+        flags: MsgFlags::from_bits_truncate(mhdr.msg_flags),
+        mhdr,
+    }
+}
+
+unsafe fn pack_mhdr_to_receive<'a, I>(
+    iov: I,
+    cmsg_buffer: &mut Option<&mut Vec<u8>>,
+    address: *mut sockaddr_storage,
+) -> (usize, msghdr)
+    where
+        I: AsRef<[IoVec<&'a mut [u8]>]> + 'a,
+{
+    let (msg_control, msg_controllen) = cmsg_buffer.as_mut()
+        .map(|v| (v.as_mut_ptr(), v.capacity()))
+        .unwrap_or((ptr::null_mut(), 0));
+
+    let mhdr = {
+        // Musl's msghdr has private fields, so this is the only way to
+        // initialize it.
+        let mut mhdr = mem::MaybeUninit::<msghdr>::zeroed();
+        let p = mhdr.as_mut_ptr();
+        (*p).msg_name = address as *mut c_void;
+        (*p).msg_namelen = mem::size_of::<sockaddr_storage>() as socklen_t;
+        (*p).msg_iov = iov.as_ref().as_ptr() as *mut iovec;
+        (*p).msg_iovlen = iov.as_ref().len() as _;
+        (*p).msg_control = msg_control as *mut c_void;
+        (*p).msg_controllen = msg_controllen as _;
+        (*p).msg_flags = 0;
+        mhdr.assume_init()
+    };
+
+    (msg_controllen, mhdr)
+}
+
+fn pack_mhdr_to_send<'a, I, C>(
+    cmsg_buffer: &mut [u8],
+    iov: I,
+    cmsgs: C,
+    addr: Option<&SockAddr>
+) -> msghdr
+    where
+        I: AsRef<[IoVec<&'a [u8]>]>,
+        C: AsRef<[ControlMessage<'a>]>
+{
+    let capacity = cmsg_buffer.len();
 
     // Next encode the sending address, if provided
     let (name, namelen) = match addr {
         Some(addr) => {
-            let (x, y) = unsafe { addr.as_ffi_pair() };
+            let (x, y) = addr.as_ffi_pair();
             (x as *const _, y)
         },
         None => (ptr::null(), 0),
@@ -854,97 +1465,68 @@ pub fn sendmsg(fd: RawFd, iov: &[IoVec<&[u8]>], cmsgs: &[ControlMessage],
         ptr::null_mut()
     };
 
-    let mhdr = {
+    let mhdr = unsafe {
         // Musl's msghdr has private fields, so this is the only way to
         // initialize it.
-        let mut mhdr: msghdr = unsafe{mem::uninitialized()};
-        mhdr.msg_name = name as *mut _;
-        mhdr.msg_namelen = namelen;
+        let mut mhdr = mem::MaybeUninit::<msghdr>::zeroed();
+        let p = mhdr.as_mut_ptr();
+        (*p).msg_name = name as *mut _;
+        (*p).msg_namelen = namelen;
         // transmute iov into a mutable pointer.  sendmsg doesn't really mutate
         // the buffer, but the standard says that it takes a mutable pointer
-        mhdr.msg_iov = iov.as_ptr() as *mut _;
-        mhdr.msg_iovlen = iov.len() as _;
-        mhdr.msg_control = cmsg_ptr;
-        mhdr.msg_controllen = capacity as _;
-        mhdr.msg_flags = 0;
-        mhdr
+        (*p).msg_iov = iov.as_ref().as_ptr() as *mut _;
+        (*p).msg_iovlen = iov.as_ref().len() as _;
+        (*p).msg_control = cmsg_ptr;
+        (*p).msg_controllen = capacity as _;
+        (*p).msg_flags = 0;
+        mhdr.assume_init()
     };
 
     // Encode each cmsg.  This must happen after initializing the header because
     // CMSG_NEXT_HDR and friends read the msg_control and msg_controllen fields.
     // CMSG_FIRSTHDR is always safe
-    let mut pmhdr: *mut cmsghdr = unsafe{CMSG_FIRSTHDR(&mhdr as *const msghdr)};
-    for cmsg in cmsgs {
+    let mut pmhdr: *mut cmsghdr = unsafe { CMSG_FIRSTHDR(&mhdr as *const msghdr) };
+    for cmsg in cmsgs.as_ref() {
         assert_ne!(pmhdr, ptr::null_mut());
         // Safe because we know that pmhdr is valid, and we initialized it with
         // sufficient space
         unsafe { cmsg.encode_into(pmhdr) };
         // Safe because mhdr is valid
-        pmhdr = unsafe{CMSG_NXTHDR(&mhdr as *const msghdr, pmhdr)};
+        pmhdr = unsafe { CMSG_NXTHDR(&mhdr as *const msghdr, pmhdr) };
     }
 
-    let ret = unsafe { libc::sendmsg(fd, &mhdr, flags.bits()) };
-
-    Errno::result(ret).map(|r| r as usize)
+    mhdr
 }
 
 /// Receive message in scatter-gather vectors from a socket, and
 /// optionally receive ancillary data into the provided buffer.
 /// If no ancillary data is desired, use () as the type parameter.
 ///
+/// # Arguments
+///
+/// * `fd`:             Socket file descriptor
+/// * `iov`:            Scatter-gather list of buffers to receive the message
+/// * `cmsg_buffer`:    Space to receive ancillary data.  Should be created by
+///                     [`cmsg_space!`](macro.cmsg_space.html)
+/// * `flags`:          Optional flags passed directly to the operating system.
+///
 /// # References
-/// [recvmsg(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/recvmsg.html)
+/// [recvmsg(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvmsg.html)
 pub fn recvmsg<'a>(fd: RawFd, iov: &[IoVec<&mut [u8]>],
-                   cmsg_buffer: Option<&'a mut dyn CmsgBuffer>,
+                   mut cmsg_buffer: Option<&'a mut Vec<u8>>,
                    flags: MsgFlags) -> Result<RecvMsg<'a>>
 {
-    let mut address: sockaddr_storage = unsafe { mem::uninitialized() };
-    let (msg_control, msg_controllen) = match cmsg_buffer {
-        Some(cmsgspace) => {
-            let msg_buf = cmsgspace.as_bytes_mut();
-            (msg_buf.as_mut_ptr(), msg_buf.len())
-        },
-        None => (ptr::null_mut(), 0),
-    };
-    let mut mhdr = {
-        // Musl's msghdr has private fields, so this is the only way to
-        // initialize it.
-        let mut mhdr: msghdr = unsafe{mem::uninitialized()};
-        mhdr.msg_name = &mut address as *mut sockaddr_storage as *mut c_void;
-        mhdr.msg_namelen = mem::size_of::<sockaddr_storage>() as socklen_t;
-        mhdr.msg_iov = iov.as_ptr() as *mut iovec;
-        mhdr.msg_iovlen = iov.len() as _;
-        mhdr.msg_control = msg_control as *mut c_void;
-        mhdr.msg_controllen = msg_controllen as _;
-        mhdr.msg_flags = 0;
-        mhdr
+    let mut address = mem::MaybeUninit::uninit();
+
+    let (msg_controllen, mut mhdr) = unsafe {
+        pack_mhdr_to_receive(&iov, &mut cmsg_buffer, address.as_mut_ptr())
     };
 
     let ret = unsafe { libc::recvmsg(fd, &mut mhdr, flags.bits()) };
 
-    Errno::result(ret).map(|r| {
-        let cmsghdr = unsafe {
-            if mhdr.msg_controllen > 0 {
-                // got control message(s)
-                debug_assert!(!mhdr.msg_control.is_null());
-                debug_assert!(msg_controllen >= mhdr.msg_controllen as usize);
-                CMSG_FIRSTHDR(&mhdr as *const msghdr)
-            } else {
-                ptr::null()
-            }.as_ref()
-        };
+    let r = Errno::result(ret)?;
 
-        let address = unsafe {
-            sockaddr_storage_to_addr(&address, mhdr.msg_namelen as usize).ok()
-        };
-        RecvMsg {
-            bytes: r as usize,
-            cmsghdr,
-            address,
-            flags: MsgFlags::from_bits_truncate(mhdr.msg_flags),
-            mhdr,
-        }
-    })
+    Ok(unsafe { read_mhdr(mhdr, r, msg_controllen, address.assume_init(), &mut cmsg_buffer) })
 }
 
 
@@ -957,7 +1539,7 @@ pub fn recvmsg<'a>(fd: RawFd, iov: &[IoVec<&mut [u8]>],
 /// protocols may exist, in which case a particular protocol must be
 /// specified in this manner.
 ///
-/// [Further reading](http://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html)
+/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html)
 pub fn socket<T: Into<Option<SockProtocol>>>(domain: AddressFamily, ty: SockType, flags: SockFlag, protocol: T) -> Result<RawFd> {
     let protocol = match protocol.into() {
         None => 0,
@@ -977,7 +1559,7 @@ pub fn socket<T: Into<Option<SockProtocol>>>(domain: AddressFamily, ty: SockType
 
 /// Create a pair of connected sockets
 ///
-/// [Further reading](http://pubs.opengroup.org/onlinepubs/9699919799/functions/socketpair.html)
+/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/socketpair.html)
 pub fn socketpair<T: Into<Option<SockProtocol>>>(domain: AddressFamily, ty: SockType, protocol: T,
                   flags: SockFlag) -> Result<(RawFd, RawFd)> {
     let protocol = match protocol.into() {
@@ -1001,7 +1583,7 @@ pub fn socketpair<T: Into<Option<SockProtocol>>>(domain: AddressFamily, ty: Sock
 
 /// Listen for connections on a socket
 ///
-/// [Further reading](http://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html)
+/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html)
 pub fn listen(sockfd: RawFd, backlog: usize) -> Result<()> {
     let res = unsafe { libc::listen(sockfd, backlog as c_int) };
 
@@ -1010,7 +1592,7 @@ pub fn listen(sockfd: RawFd, backlog: usize) -> Result<()> {
 
 /// Bind a name to a socket
 ///
-/// [Further reading](http://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html)
+/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html)
 pub fn bind(fd: RawFd, addr: &SockAddr) -> Result<()> {
     let res = unsafe {
         let (ptr, len) = addr.as_ffi_pair();
@@ -1022,7 +1604,7 @@ pub fn bind(fd: RawFd, addr: &SockAddr) -> Result<()> {
 
 /// Accept a connection on a socket
 ///
-/// [Further reading](http://pubs.opengroup.org/onlinepubs/9699919799/functions/accept.html)
+/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/accept.html)
 pub fn accept(sockfd: RawFd) -> Result<RawFd> {
     let res = unsafe { libc::accept(sockfd, ptr::null_mut(), ptr::null_mut()) };
 
@@ -1031,8 +1613,15 @@ pub fn accept(sockfd: RawFd) -> Result<RawFd> {
 
 /// Accept a connection on a socket
 ///
-/// [Further reading](http://man7.org/linux/man-pages/man2/accept.2.html)
-#[cfg(any(target_os = "android",
+/// [Further reading](https://man7.org/linux/man-pages/man2/accept.2.html)
+#[cfg(any(all(
+            target_os = "android",
+            any(
+                target_arch = "aarch64",
+                target_arch = "x86",
+                target_arch = "x86_64"
+            )
+          ),
           target_os = "freebsd",
           target_os = "linux",
           target_os = "openbsd"))]
@@ -1044,7 +1633,7 @@ pub fn accept4(sockfd: RawFd, flags: SockFlag) -> Result<RawFd> {
 
 /// Initiate a connection on a socket
 ///
-/// [Further reading](http://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html)
+/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html)
 pub fn connect(fd: RawFd, addr: &SockAddr) -> Result<()> {
     let res = unsafe {
         let (ptr, len) = addr.as_ffi_pair();
@@ -1057,7 +1646,7 @@ pub fn connect(fd: RawFd, addr: &SockAddr) -> Result<()> {
 /// Receive data from a connection-oriented socket. Returns the number of
 /// bytes read
 ///
-/// [Further reading](http://pubs.opengroup.org/onlinepubs/9699919799/functions/recv.html)
+/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/recv.html)
 pub fn recv(sockfd: RawFd, buf: &mut [u8], flags: MsgFlags) -> Result<usize> {
     unsafe {
         let ret = libc::recv(
@@ -1071,12 +1660,15 @@ pub fn recv(sockfd: RawFd, buf: &mut [u8], flags: MsgFlags) -> Result<usize> {
 }
 
 /// Receive data from a connectionless or connection-oriented socket. Returns
-/// the number of bytes read and the socket address of the sender.
+/// the number of bytes read and, for connectionless sockets,  the socket
+/// address of the sender.
 ///
-/// [Further reading](http://pubs.opengroup.org/onlinepubs/9699919799/functions/recvfrom.html)
-pub fn recvfrom(sockfd: RawFd, buf: &mut [u8]) -> Result<(usize, SockAddr)> {
+/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvfrom.html)
+pub fn recvfrom(sockfd: RawFd, buf: &mut [u8])
+    -> Result<(usize, Option<SockAddr>)>
+{
     unsafe {
-        let addr: sockaddr_storage = mem::zeroed();
+        let mut addr: sockaddr_storage = mem::zeroed();
         let mut len = mem::size_of::<sockaddr_storage>() as socklen_t;
 
         let ret = Errno::result(libc::recvfrom(
@@ -1084,17 +1676,20 @@ pub fn recvfrom(sockfd: RawFd, buf: &mut [u8]) -> Result<(usize, SockAddr)> {
             buf.as_ptr() as *mut c_void,
             buf.len() as size_t,
             0,
-            mem::transmute(&addr),
-            &mut len as *mut socklen_t))?;
+            &mut addr as *mut libc::sockaddr_storage as *mut libc::sockaddr,
+            &mut len as *mut socklen_t))? as usize;
 
-        sockaddr_storage_to_addr(&addr, len as usize)
-            .map(|addr| (ret as usize, addr))
+        match sockaddr_storage_to_addr(&addr, len as usize) {
+            Err(Errno::ENOTCONN) => Ok((ret, None)),
+            Ok(addr) => Ok((ret, Some(addr))),
+            Err(e) => Err(e)
+        }
     }
 }
 
 /// Send a message to a socket
 ///
-/// [Further reading](http://pubs.opengroup.org/onlinepubs/9699919799/functions/sendto.html)
+/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendto.html)
 pub fn sendto(fd: RawFd, buf: &[u8], addr: &SockAddr, flags: MsgFlags) -> Result<usize> {
     let ret = unsafe {
         let (ptr, len) = addr.as_ffi_pair();
@@ -1106,7 +1701,7 @@ pub fn sendto(fd: RawFd, buf: &[u8], addr: &SockAddr, flags: MsgFlags) -> Result
 
 /// Send data to a connection-oriented socket. Returns the number of bytes read
 ///
-/// [Further reading](http://pubs.opengroup.org/onlinepubs/9699919799/functions/send.html)
+/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/send.html)
 pub fn send(fd: RawFd, buf: &[u8], flags: MsgFlags) -> Result<usize> {
     let ret = unsafe {
         libc::send(fd, buf.as_ptr() as *const c_void, buf.len() as size_t, flags.bits())
@@ -1121,52 +1716,32 @@ pub fn send(fd: RawFd, buf: &[u8], flags: MsgFlags) -> Result<usize> {
  *
  */
 
-/// The protocol level at which to get / set socket options. Used as an
-/// argument to `getsockopt` and `setsockopt`.
-///
-/// [Further reading](http://pubs.opengroup.org/onlinepubs/9699919799/functions/setsockopt.html)
-#[repr(i32)]
-#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
-pub enum SockLevel {
-    Socket = libc::SOL_SOCKET,
-    Tcp = libc::IPPROTO_TCP,
-    Ip = libc::IPPROTO_IP,
-    Ipv6 = libc::IPPROTO_IPV6,
-    Udp = libc::IPPROTO_UDP,
-    #[cfg(any(target_os = "android", target_os = "linux"))]
-    Netlink = libc::SOL_NETLINK,
-    #[cfg(any(target_os = "android", target_os = "linux"))]
-    Alg = libc::SOL_ALG,
-}
-
-/// Represents a socket option that can be accessed or set. Used as an argument
-/// to `getsockopt`
+/// Represents a socket option that can be retrieved.
 pub trait GetSockOpt : Copy {
     type Val;
 
-    #[doc(hidden)]
+    /// Look up the value of this socket option on the given socket.
     fn get(&self, fd: RawFd) -> Result<Self::Val>;
 }
 
-/// Represents a socket option that can be accessed or set. Used as an argument
-/// to `setsockopt`
+/// Represents a socket option that can be set.
 pub trait SetSockOpt : Clone {
     type Val;
 
-    #[doc(hidden)]
+    /// Set the value of this socket option on the given socket.
     fn set(&self, fd: RawFd, val: &Self::Val) -> Result<()>;
 }
 
 /// Get the current value for the requested socket option
 ///
-/// [Further reading](http://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockopt.html)
+/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockopt.html)
 pub fn getsockopt<O: GetSockOpt>(fd: RawFd, opt: O) -> Result<O::Val> {
     opt.get(fd)
 }
 
 /// Sets the value for the requested socket option
 ///
-/// [Further reading](http://pubs.opengroup.org/onlinepubs/9699919799/functions/setsockopt.html)
+/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/setsockopt.html)
 ///
 /// # Examples
 ///
@@ -1187,79 +1762,118 @@ pub fn setsockopt<O: SetSockOpt>(fd: RawFd, opt: O, val: &O::Val) -> Result<()>
 
 /// Get the address of the peer connected to the socket `fd`.
 ///
-/// [Further reading](http://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html)
+/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html)
 pub fn getpeername(fd: RawFd) -> Result<SockAddr> {
     unsafe {
-        let addr: sockaddr_storage = mem::uninitialized();
+        let mut addr = mem::MaybeUninit::uninit();
         let mut len = mem::size_of::<sockaddr_storage>() as socklen_t;
 
-        let ret = libc::getpeername(fd, mem::transmute(&addr), &mut len);
+        let ret = libc::getpeername(
+            fd,
+            addr.as_mut_ptr() as *mut libc::sockaddr,
+            &mut len
+        );
 
         Errno::result(ret)?;
 
-        sockaddr_storage_to_addr(&addr, len as usize)
+        sockaddr_storage_to_addr(&addr.assume_init(), len as usize)
     }
 }
 
 /// Get the current address to which the socket `fd` is bound.
 ///
-/// [Further reading](http://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html)
+/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html)
 pub fn getsockname(fd: RawFd) -> Result<SockAddr> {
     unsafe {
-        let addr: sockaddr_storage = mem::uninitialized();
+        let mut addr = mem::MaybeUninit::uninit();
         let mut len = mem::size_of::<sockaddr_storage>() as socklen_t;
 
-        let ret = libc::getsockname(fd, mem::transmute(&addr), &mut len);
+        let ret = libc::getsockname(
+            fd,
+            addr.as_mut_ptr() as *mut libc::sockaddr,
+            &mut len
+        );
 
         Errno::result(ret)?;
 
-        sockaddr_storage_to_addr(&addr, len as usize)
+        sockaddr_storage_to_addr(&addr.assume_init(), len as usize)
     }
 }
 
-/// Return the appropriate `SockAddr` type from a `sockaddr_storage` of a certain
-/// size.  In C this would usually be done by casting.  The `len` argument
+/// Return the appropriate `SockAddr` type from a `sockaddr_storage` of a
+/// certain size.
+///
+/// In C this would usually be done by casting.  The `len` argument
 /// should be the number of bytes in the `sockaddr_storage` that are actually
 /// allocated and valid.  It must be at least as large as all the useful parts
 /// of the structure.  Note that in the case of a `sockaddr_un`, `len` need not
 /// include the terminating null.
-pub unsafe fn sockaddr_storage_to_addr(
+pub fn sockaddr_storage_to_addr(
     addr: &sockaddr_storage,
     len: usize) -> Result<SockAddr> {
 
+    assert!(len <= mem::size_of::<sockaddr_storage>());
     if len < mem::size_of_val(&addr.ss_family) {
-        return Err(Error::Sys(Errno::ENOTCONN));
+        return Err(Errno::ENOTCONN);
     }
 
-    match addr.ss_family as c_int {
+    match c_int::from(addr.ss_family) {
         libc::AF_INET => {
-            assert!(len as usize == mem::size_of::<sockaddr_in>());
-            let ret = *(addr as *const _ as *const sockaddr_in);
-            Ok(SockAddr::Inet(InetAddr::V4(ret)))
+            assert!(len as usize >= mem::size_of::<sockaddr_in>());
+            let sin = unsafe {
+                *(addr as *const sockaddr_storage as *const sockaddr_in)
+            };
+            Ok(SockAddr::Inet(InetAddr::V4(sin)))
         }
         libc::AF_INET6 => {
-            assert!(len as usize == mem::size_of::<sockaddr_in6>());
-            Ok(SockAddr::Inet(InetAddr::V6(*(addr as *const _ as *const sockaddr_in6))))
+            assert!(len as usize >= mem::size_of::<sockaddr_in6>());
+            let sin6 = unsafe {
+                *(addr as *const _ as *const sockaddr_in6)
+            };
+            Ok(SockAddr::Inet(InetAddr::V6(sin6)))
         }
         libc::AF_UNIX => {
-            let sun = *(addr as *const _ as *const sockaddr_un);
             let pathlen = len - offset_of!(sockaddr_un, sun_path);
-            Ok(SockAddr::Unix(UnixAddr(sun, pathlen)))
+            unsafe {
+                let sun = *(addr as *const _ as *const sockaddr_un);
+                Ok(SockAddr::Unix(UnixAddr::from_raw_parts(sun, pathlen)))
+            }
+        }
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        libc::AF_PACKET => {
+            use libc::sockaddr_ll;
+            // Don't assert anything about the size.
+            // Apparently the Linux kernel can return smaller sizes when
+            // the value in the last element of sockaddr_ll (`sll_addr`) is
+            // smaller than the declared size of that field
+            let sll = unsafe {
+                *(addr as *const _ as *const sockaddr_ll)
+            };
+            Ok(SockAddr::Link(LinkAddr(sll)))
         }
         #[cfg(any(target_os = "android", target_os = "linux"))]
         libc::AF_NETLINK => {
             use libc::sockaddr_nl;
-            Ok(SockAddr::Netlink(NetlinkAddr(*(addr as *const _ as *const sockaddr_nl))))
+            let snl = unsafe {
+                *(addr as *const _ as *const sockaddr_nl)
+            };
+            Ok(SockAddr::Netlink(NetlinkAddr(snl)))
         }
         #[cfg(any(target_os = "android", target_os = "linux"))]
         libc::AF_ALG => {
             use libc::sockaddr_alg;
-            Ok(SockAddr::Alg(AlgAddr(*(addr as *const _ as *const sockaddr_alg))))
+            let salg = unsafe {
+                *(addr as *const _ as *const sockaddr_alg)
+            };
+            Ok(SockAddr::Alg(AlgAddr(salg)))
         }
-        #[cfg(target_os = "linux")]
+        #[cfg(any(target_os = "android", target_os = "linux"))]
         libc::AF_VSOCK => {
             use libc::sockaddr_vm;
-            Ok(SockAddr::Vsock(VsockAddr(*(addr as *const _ as *const sockaddr_vm))))
+            let svm = unsafe {
+                *(addr as *const _ as *const sockaddr_vm)
+            };
+            Ok(SockAddr::Vsock(VsockAddr(svm)))
         }
         af => panic!("unexpected address family {}", af),
     }
@@ -1278,7 +1892,7 @@ pub enum Shutdown {
 
 /// Shut down part of a full-duplex connection.
 ///
-/// [Further reading](http://pubs.opengroup.org/onlinepubs/9699919799/functions/shutdown.html)
+/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/shutdown.html)
 pub fn shutdown(df: RawFd, how: Shutdown) -> Result<()> {
     unsafe {
         use libc::shutdown;
@@ -1292,3 +1906,11 @@ pub fn shutdown(df: RawFd, how: Shutdown) -> Result<()> {
         Errno::result(shutdown(df, how)).map(drop)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    #[test]
+    fn can_use_cmsg_space() {
+        let _ = cmsg_space!(u8);
+    }
+}
diff --git a/third_party/rust/nix/src/sys/socket/sockopt.rs b/third_party/rust/nix/src/sys/socket/sockopt.rs
index a996010018d5b..fcb4be81be861 100644
--- a/third_party/rust/nix/src/sys/socket/sockopt.rs
+++ b/third_party/rust/nix/src/sys/socket/sockopt.rs
@@ -1,9 +1,14 @@
+//! Socket options as used by `setsockopt` and `getsockopt`.
+use cfg_if::cfg_if;
 use super::{GetSockOpt, SetSockOpt};
-use Result;
-use errno::Errno;
-use sys::time::TimeVal;
+use crate::Result;
+use crate::errno::Errno;
+use crate::sys::time::TimeVal;
 use libc::{self, c_int, c_void, socklen_t};
-use std::mem;
+use std::mem::{
+    self,
+    MaybeUninit
+};
 use std::os::unix::io::RawFd;
 use std::ffi::{OsStr, OsString};
 #[cfg(target_family = "unix")]
@@ -26,7 +31,7 @@ const TCP_CA_NAME_MAX: usize = 16;
 /// # Arguments
 ///
 /// * `$name:ident`: name of the type you want to implement `SetSockOpt` for.
-/// * `$level:path` : socket layer, or a `protocol level`: could be *raw sockets*
+/// * `$level:expr` : socket layer, or a `protocol level`: could be *raw sockets*
 ///    (`libc::SOL_SOCKET`), *ip protocol* (libc::IPPROTO_IP), *tcp protocol* (`libc::IPPROTO_TCP`),
 ///    and more. Please refer to your system manual for more options. Will be passed as the second
 ///    argument (`level`) to the `setsockopt` call.
@@ -37,7 +42,7 @@ const TCP_CA_NAME_MAX: usize = 16;
 /// * Type that implements the `Set` trait for the type from the previous item (like `SetBool` for
 ///    `bool`, `SetUsize` for `usize`, etc.).
 macro_rules! setsockopt_impl {
-    ($name:ident, $level:path, $flag:path, $ty:ty, $setter:ty) => {
+    ($name:ident, $level:expr, $flag:path, $ty:ty, $setter:ty) => {
         impl SetSockOpt for $name {
             type Val = $ty;
 
@@ -78,20 +83,20 @@ macro_rules! setsockopt_impl {
 /// * Type that implements the `Get` trait for the type from the previous item (`GetBool` for
 ///    `bool`, `GetUsize` for `usize`, etc.).
 macro_rules! getsockopt_impl {
-    ($name:ident, $level:path, $flag:path, $ty:ty, $getter:ty) => {
+    ($name:ident, $level:expr, $flag:path, $ty:ty, $getter:ty) => {
         impl GetSockOpt for $name {
             type Val = $ty;
 
             fn get(&self, fd: RawFd) -> Result<$ty> {
                 unsafe {
-                    let mut getter: $getter = Get::blank();
+                    let mut getter: $getter = Get::uninit();
 
                     let res = libc::getsockopt(fd, $level, $flag,
                                                getter.ffi_ptr(),
                                                getter.ffi_len());
                     Errno::result(res)?;
 
-                    Ok(getter.unwrap())
+                    Ok(getter.assume_init())
                 }
             }
         }
@@ -113,7 +118,7 @@ macro_rules! getsockopt_impl {
 /// * `GetOnly`, `SetOnly` or `Both`: whether you want to implement only getter, only setter or
 ///    both of them.
 /// * `$name:ident`: name of type `GetSockOpt`/`SetSockOpt` will be implemented for.
-/// * `$level:path` : socket layer, or a `protocol level`: could be *raw sockets*
+/// * `$level:expr` : socket layer, or a `protocol level`: could be *raw sockets*
 ///    (`lic::SOL_SOCKET`), *ip protocol* (libc::IPPROTO_IP), *tcp protocol* (`libc::IPPROTO_TCP`),
 ///    and more. Please refer to your system manual for more options. Will be passed as the second
 ///    argument (`level`) to the `getsockopt`/`setsockopt` call.
@@ -124,73 +129,99 @@ macro_rules! getsockopt_impl {
 /// * `$getter:ty`: `Get` implementation; optional; only for `GetOnly` and `Both`.
 /// * `$setter:ty`: `Set` implementation; optional; only for `SetOnly` and `Both`.
 macro_rules! sockopt_impl {
-    (GetOnly, $name:ident, $level:path, $flag:path, bool) => {
-        sockopt_impl!(GetOnly, $name, $level, $flag, bool, GetBool);
+    ($(#[$attr:meta])* $name:ident, GetOnly, $level:expr, $flag:path, bool) => {
+        sockopt_impl!($(#[$attr])*
+                      $name, GetOnly, $level, $flag, bool, GetBool);
     };
 
-    (GetOnly, $name:ident, $level:path, $flag:path, u8) => {
-        sockopt_impl!(GetOnly, $name, $level, $flag, u8, GetU8);
+    ($(#[$attr:meta])* $name:ident, GetOnly, $level:expr, $flag:path, u8) => {
+        sockopt_impl!($(#[$attr])* $name, GetOnly, $level, $flag, u8, GetU8);
     };
 
-    (GetOnly, $name:ident, $level:path, $flag:path, usize) => {
-        sockopt_impl!(GetOnly, $name, $level, $flag, usize, GetUsize);
+    ($(#[$attr:meta])* $name:ident, GetOnly, $level:expr, $flag:path, usize) =>
+    {
+        sockopt_impl!($(#[$attr])*
+                      $name, GetOnly, $level, $flag, usize, GetUsize);
     };
 
-    (SetOnly, $name:ident, $level:path, $flag:path, bool) => {
-        sockopt_impl!(SetOnly, $name, $level, $flag, bool, SetBool);
+    ($(#[$attr:meta])* $name:ident, SetOnly, $level:expr, $flag:path, bool) => {
+        sockopt_impl!($(#[$attr])*
+                      $name, SetOnly, $level, $flag, bool, SetBool);
     };
 
-    (SetOnly, $name:ident, $level:path, $flag:path, u8) => {
-        sockopt_impl!(SetOnly, $name, $level, $flag, u8, SetU8);
+    ($(#[$attr:meta])* $name:ident, SetOnly, $level:expr, $flag:path, u8) => {
+        sockopt_impl!($(#[$attr])* $name, SetOnly, $level, $flag, u8, SetU8);
     };
 
-    (SetOnly, $name:ident, $level:path, $flag:path, usize) => {
-        sockopt_impl!(SetOnly, $name, $level, $flag, usize, SetUsize);
+    ($(#[$attr:meta])* $name:ident, SetOnly, $level:expr, $flag:path, usize) =>
+    {
+        sockopt_impl!($(#[$attr])*
+                      $name, SetOnly, $level, $flag, usize, SetUsize);
     };
 
-    (Both, $name:ident, $level:path, $flag:path, bool) => {
-        sockopt_impl!(Both, $name, $level, $flag, bool, GetBool, SetBool);
+    ($(#[$attr:meta])* $name:ident, Both, $level:expr, $flag:path, bool) => {
+        sockopt_impl!($(#[$attr])*
+                      $name, Both, $level, $flag, bool, GetBool, SetBool);
     };
 
-    (Both, $name:ident, $level:path, $flag:path, u8) => {
-        sockopt_impl!(Both, $name, $level, $flag, u8, GetU8, SetU8);
+    ($(#[$attr:meta])* $name:ident, Both, $level:expr, $flag:path, u8) => {
+        sockopt_impl!($(#[$attr])*
+                      $name, Both, $level, $flag, u8, GetU8, SetU8);
     };
 
-    (Both, $name:ident, $level:path, $flag:path, usize) => {
-        sockopt_impl!(Both, $name, $level, $flag, usize, GetUsize, SetUsize);
+    ($(#[$attr:meta])* $name:ident, Both, $level:expr, $flag:path, usize) => {
+        sockopt_impl!($(#[$attr])*
+                      $name, Both, $level, $flag, usize, GetUsize, SetUsize);
     };
 
-    (Both, $name:ident, $level:path, $flag:path, OsString<$array:ty>) => {
-        sockopt_impl!(Both, $name, $level, $flag, OsString, GetOsString<$array>, SetOsString);
+    ($(#[$attr:meta])* $name:ident, Both, $level:expr, $flag:path,
+     OsString<$array:ty>) =>
+    {
+        sockopt_impl!($(#[$attr])*
+                      $name, Both, $level, $flag, OsString, GetOsString<$array>,
+                      SetOsString);
     };
 
     /*
      * Matchers with generic getter types must be placed at the end, so
      * they'll only match _after_ specialized matchers fail
      */
-    (GetOnly, $name:ident, $level:path, $flag:path, $ty:ty) => {
-        sockopt_impl!(GetOnly, $name, $level, $flag, $ty, GetStruct<$ty>);
+    ($(#[$attr:meta])* $name:ident, GetOnly, $level:expr, $flag:path, $ty:ty) =>
+    {
+        sockopt_impl!($(#[$attr])*
+                      $name, GetOnly, $level, $flag, $ty, GetStruct<$ty>);
     };
 
-    (GetOnly, $name:ident, $level:path, $flag:path, $ty:ty, $getter:ty) => {
+    ($(#[$attr:meta])* $name:ident, GetOnly, $level:expr, $flag:path, $ty:ty,
+     $getter:ty) =>
+    {
+        $(#[$attr])*
         #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
         pub struct $name;
 
         getsockopt_impl!($name, $level, $flag, $ty, $getter);
     };
 
-    (SetOnly, $name:ident, $level:path, $flag:path, $ty:ty) => {
-        sockopt_impl!(SetOnly, $name, $level, $flag, $ty, SetStruct<$ty>);
+    ($(#[$attr:meta])* $name:ident, SetOnly, $level:expr, $flag:path, $ty:ty) =>
+    {
+        sockopt_impl!($(#[$attr])*
+                      $name, SetOnly, $level, $flag, $ty, SetStruct<$ty>);
     };
 
-    (SetOnly, $name:ident, $level:path, $flag:path, $ty:ty, $setter:ty) => {
+    ($(#[$attr:meta])* $name:ident, SetOnly, $level:expr, $flag:path, $ty:ty,
+     $setter:ty) =>
+    {
+        $(#[$attr])*
         #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
         pub struct $name;
 
         setsockopt_impl!($name, $level, $flag, $ty, $setter);
     };
 
-    (Both, $name:ident, $level:path, $flag:path, $ty:ty, $getter:ty, $setter:ty) => {
+    ($(#[$attr:meta])* $name:ident, Both, $level:expr, $flag:path, $ty:ty,
+     $getter:ty, $setter:ty) =>
+    {
+        $(#[$attr])*
         #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
         pub struct $name;
 
@@ -198,8 +229,10 @@ macro_rules! sockopt_impl {
         getsockopt_impl!($name, $level, $flag, $ty, $getter);
     };
 
-    (Both, $name:ident, $level:path, $flag:path, $ty:ty) => {
-        sockopt_impl!(Both, $name, $level, $flag, $ty, GetStruct<$ty>, SetStruct<$ty>);
+    ($(#[$attr:meta])* $name:ident, Both, $level:expr, $flag:path, $ty:ty) => {
+        sockopt_impl!($(#[$attr])*
+                      $name, Both, $level, $flag, $ty, GetStruct<$ty>,
+                      SetStruct<$ty>);
     };
 }
 
@@ -209,68 +242,232 @@ macro_rules! sockopt_impl {
  *
  */
 
-sockopt_impl!(Both, ReuseAddr, libc::SOL_SOCKET, libc::SO_REUSEADDR, bool);
-sockopt_impl!(Both, ReusePort, libc::SOL_SOCKET, libc::SO_REUSEPORT, bool);
-sockopt_impl!(Both, TcpNoDelay, libc::IPPROTO_TCP, libc::TCP_NODELAY, bool);
-sockopt_impl!(Both, Linger, libc::SOL_SOCKET, libc::SO_LINGER, libc::linger);
-sockopt_impl!(SetOnly, IpAddMembership, libc::IPPROTO_IP, libc::IP_ADD_MEMBERSHIP, super::IpMembershipRequest);
-sockopt_impl!(SetOnly, IpDropMembership, libc::IPPROTO_IP, libc::IP_DROP_MEMBERSHIP, super::IpMembershipRequest);
+sockopt_impl!(
+    /// Enables local address reuse
+    ReuseAddr, Both, libc::SOL_SOCKET, libc::SO_REUSEADDR, bool
+);
+#[cfg(not(any(target_os = "illumos", target_os = "solaris")))]
+sockopt_impl!(
+    /// Permits multiple AF_INET or AF_INET6 sockets to be bound to an
+    /// identical socket address.
+    ReusePort, Both, libc::SOL_SOCKET, libc::SO_REUSEPORT, bool);
+sockopt_impl!(
+    /// Under most circumstances, TCP sends data when it is presented; when
+    /// outstanding data has not yet been acknowledged, it gathers small amounts
+    /// of output to be sent in a single packet once an acknowledgement is
+    /// received.  For a small number of clients, such as window systems that
+    /// send a stream of mouse events which receive no replies, this
+    /// packetization may cause significant delays.  The boolean option
+    /// TCP_NODELAY defeats this algorithm.
+    TcpNoDelay, Both, libc::IPPROTO_TCP, libc::TCP_NODELAY, bool);
+sockopt_impl!(
+    /// When enabled,  a close(2) or shutdown(2) will not return until all
+    /// queued messages for the socket have been successfully sent or the
+    /// linger timeout has been reached.
+    Linger, Both, libc::SOL_SOCKET, libc::SO_LINGER, libc::linger);
+sockopt_impl!(
+    /// Join a multicast group
+    IpAddMembership, SetOnly, libc::IPPROTO_IP, libc::IP_ADD_MEMBERSHIP,
+    super::IpMembershipRequest);
+sockopt_impl!(
+    /// Leave a multicast group.
+    IpDropMembership, SetOnly, libc::IPPROTO_IP, libc::IP_DROP_MEMBERSHIP,
+    super::IpMembershipRequest);
 cfg_if! {
     if #[cfg(any(target_os = "android", target_os = "linux"))] {
-        sockopt_impl!(SetOnly, Ipv6AddMembership, libc::IPPROTO_IPV6, libc::IPV6_ADD_MEMBERSHIP, super::Ipv6MembershipRequest);
-        sockopt_impl!(SetOnly, Ipv6DropMembership, libc::IPPROTO_IPV6, libc::IPV6_DROP_MEMBERSHIP, super::Ipv6MembershipRequest);
+        sockopt_impl!(
+            /// Join an IPv6 multicast group.
+            Ipv6AddMembership, SetOnly, libc::IPPROTO_IPV6, libc::IPV6_ADD_MEMBERSHIP, super::Ipv6MembershipRequest);
+        sockopt_impl!(
+            /// Leave an IPv6 multicast group.
+            Ipv6DropMembership, SetOnly, libc::IPPROTO_IPV6, libc::IPV6_DROP_MEMBERSHIP, super::Ipv6MembershipRequest);
     } else if #[cfg(any(target_os = "dragonfly",
                         target_os = "freebsd",
+                        target_os = "illumos",
                         target_os = "ios",
                         target_os = "macos",
                         target_os = "netbsd",
-                        target_os = "openbsd"))] {
-        sockopt_impl!(SetOnly, Ipv6AddMembership, libc::IPPROTO_IPV6, libc::IPV6_JOIN_GROUP, super::Ipv6MembershipRequest);
-        sockopt_impl!(SetOnly, Ipv6DropMembership, libc::IPPROTO_IPV6, libc::IPV6_LEAVE_GROUP, super::Ipv6MembershipRequest);
+                        target_os = "openbsd",
+                        target_os = "solaris"))] {
+        sockopt_impl!(
+            /// Join an IPv6 multicast group.
+            Ipv6AddMembership, SetOnly, libc::IPPROTO_IPV6,
+            libc::IPV6_JOIN_GROUP, super::Ipv6MembershipRequest);
+        sockopt_impl!(
+            /// Leave an IPv6 multicast group.
+            Ipv6DropMembership, SetOnly, libc::IPPROTO_IPV6,
+            libc::IPV6_LEAVE_GROUP, super::Ipv6MembershipRequest);
     }
 }
-sockopt_impl!(Both, IpMulticastTtl, libc::IPPROTO_IP, libc::IP_MULTICAST_TTL, u8);
-sockopt_impl!(Both, IpMulticastLoop, libc::IPPROTO_IP, libc::IP_MULTICAST_LOOP, bool);
-sockopt_impl!(Both, ReceiveTimeout, libc::SOL_SOCKET, libc::SO_RCVTIMEO, TimeVal);
-sockopt_impl!(Both, SendTimeout, libc::SOL_SOCKET, libc::SO_SNDTIMEO, TimeVal);
-sockopt_impl!(Both, Broadcast, libc::SOL_SOCKET, libc::SO_BROADCAST, bool);
-sockopt_impl!(Both, OobInline, libc::SOL_SOCKET, libc::SO_OOBINLINE, bool);
-sockopt_impl!(GetOnly, SocketError, libc::SOL_SOCKET, libc::SO_ERROR, i32);
-sockopt_impl!(Both, KeepAlive, libc::SOL_SOCKET, libc::SO_KEEPALIVE, bool);
+sockopt_impl!(
+    /// Set or read the time-to-live value of outgoing multicast packets for
+    /// this socket.
+    IpMulticastTtl, Both, libc::IPPROTO_IP, libc::IP_MULTICAST_TTL, u8);
+sockopt_impl!(
+    /// Set or read a boolean integer argument that determines whether sent
+    /// multicast packets should be looped back to the local sockets.
+    IpMulticastLoop, Both, libc::IPPROTO_IP, libc::IP_MULTICAST_LOOP, bool);
+#[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+sockopt_impl!(
+    /// If enabled, this boolean option allows binding to an IP address that
+    /// is nonlocal or does not (yet) exist.
+    IpFreebind, Both, libc::IPPROTO_IP, libc::IP_FREEBIND, bool);
+sockopt_impl!(
+    /// Specify the receiving timeout until reporting an error.
+    ReceiveTimeout, Both, libc::SOL_SOCKET, libc::SO_RCVTIMEO, TimeVal);
+sockopt_impl!(
+    /// Specify the sending timeout until reporting an error.
+    SendTimeout, Both, libc::SOL_SOCKET, libc::SO_SNDTIMEO, TimeVal);
+sockopt_impl!(
+    /// Set or get the broadcast flag.
+    Broadcast, Both, libc::SOL_SOCKET, libc::SO_BROADCAST, bool);
+sockopt_impl!(
+    /// If this option is enabled, out-of-band data is directly placed into
+    /// the receive data stream.
+    OobInline, Both, libc::SOL_SOCKET, libc::SO_OOBINLINE, bool);
+sockopt_impl!(
+    /// Get and clear the pending socket error.
+    SocketError, GetOnly, libc::SOL_SOCKET, libc::SO_ERROR, i32);
+sockopt_impl!(
+    /// Enable sending of keep-alive messages on connection-oriented sockets.
+    KeepAlive, Both, libc::SOL_SOCKET, libc::SO_KEEPALIVE, bool);
+#[cfg(any(
+        target_os = "dragonfly",
+        target_os = "freebsd",
+        target_os = "macos",
+        target_os = "ios"
+))]
+sockopt_impl!(
+    /// Get the credentials of the peer process of a connected unix domain
+    /// socket.
+    LocalPeerCred, GetOnly, 0, libc::LOCAL_PEERCRED, super::XuCred);
 #[cfg(any(target_os = "android", target_os = "linux"))]
-sockopt_impl!(GetOnly, PeerCredentials, libc::SOL_SOCKET, libc::SO_PEERCRED, super::UnixCredentials);
+sockopt_impl!(
+    /// Return the credentials of the foreign process connected to this socket.
+    PeerCredentials, GetOnly, libc::SOL_SOCKET, libc::SO_PEERCRED, super::UnixCredentials);
 #[cfg(any(target_os = "ios",
           target_os = "macos"))]
-sockopt_impl!(Both, TcpKeepAlive, libc::IPPROTO_TCP, libc::TCP_KEEPALIVE, u32);
+sockopt_impl!(
+    /// Specify the amount of time, in seconds, that the connection must be idle
+    /// before keepalive probes (if enabled) are sent.
+    TcpKeepAlive, Both, libc::IPPROTO_TCP, libc::TCP_KEEPALIVE, u32);
 #[cfg(any(target_os = "android",
           target_os = "dragonfly",
           target_os = "freebsd",
           target_os = "linux",
           target_os = "nacl"))]
-sockopt_impl!(Both, TcpKeepIdle, libc::IPPROTO_TCP, libc::TCP_KEEPIDLE, u32);
-sockopt_impl!(Both, RcvBuf, libc::SOL_SOCKET, libc::SO_RCVBUF, usize);
-sockopt_impl!(Both, SndBuf, libc::SOL_SOCKET, libc::SO_SNDBUF, usize);
+sockopt_impl!(
+    /// The time (in seconds) the connection needs to remain idle before TCP
+    /// starts sending keepalive probes
+    TcpKeepIdle, Both, libc::IPPROTO_TCP, libc::TCP_KEEPIDLE, u32);
+cfg_if! {
+    if #[cfg(any(target_os = "android", target_os = "linux"))] {
+        sockopt_impl!(
+            /// The maximum segment size for outgoing TCP packets.
+            TcpMaxSeg, Both, libc::IPPROTO_TCP, libc::TCP_MAXSEG, u32);
+    } else {
+        sockopt_impl!(
+            /// The maximum segment size for outgoing TCP packets.
+            TcpMaxSeg, GetOnly, libc::IPPROTO_TCP, libc::TCP_MAXSEG, u32);
+    }
+}
+#[cfg(not(target_os = "openbsd"))]
+sockopt_impl!(
+    /// The maximum number of keepalive probes TCP should send before
+    /// dropping the connection.
+    TcpKeepCount, Both, libc::IPPROTO_TCP, libc::TCP_KEEPCNT, u32);
+#[cfg(any(target_os = "android",
+          target_os = "fuchsia",
+          target_os = "linux"))]
+sockopt_impl!(
+    #[allow(missing_docs)]
+    // Not documented by Linux!
+    TcpRepair, Both, libc::IPPROTO_TCP, libc::TCP_REPAIR, u32);
+#[cfg(not(target_os = "openbsd"))]
+sockopt_impl!(
+    /// The time (in seconds) between individual keepalive probes.
+    TcpKeepInterval, Both, libc::IPPROTO_TCP, libc::TCP_KEEPINTVL, u32);
+#[cfg(any(target_os = "fuchsia", target_os = "linux"))]
+sockopt_impl!(
+    /// Specifies the maximum amount of time in milliseconds that transmitted
+    /// data may remain unacknowledged before TCP will forcibly close the
+    /// corresponding connection
+    TcpUserTimeout, Both, libc::IPPROTO_TCP, libc::TCP_USER_TIMEOUT, u32);
+sockopt_impl!(
+    /// Sets or gets the maximum socket receive buffer in bytes.
+    RcvBuf, Both, libc::SOL_SOCKET, libc::SO_RCVBUF, usize);
+sockopt_impl!(
+    /// Sets or gets the maximum socket send buffer in bytes.
+    SndBuf, Both, libc::SOL_SOCKET, libc::SO_SNDBUF, usize);
+#[cfg(any(target_os = "android", target_os = "linux"))]
+sockopt_impl!(
+    /// Using this socket option, a privileged (`CAP_NET_ADMIN`) process can
+    /// perform the same task as `SO_RCVBUF`, but the `rmem_max limit` can be
+    /// overridden.
+    RcvBufForce, SetOnly, libc::SOL_SOCKET, libc::SO_RCVBUFFORCE, usize);
+#[cfg(any(target_os = "android", target_os = "linux"))]
+sockopt_impl!(
+    /// Using this socket option, a privileged (`CAP_NET_ADMIN`)  process can
+    /// perform the same task as `SO_SNDBUF`, but the `wmem_max` limit can be
+    /// overridden.
+    SndBufForce, SetOnly, libc::SOL_SOCKET, libc::SO_SNDBUFFORCE, usize);
+sockopt_impl!(
+    /// Gets the socket type as an integer.
+    SockType, GetOnly, libc::SOL_SOCKET, libc::SO_TYPE, super::SockType);
+sockopt_impl!(
+    /// Returns a value indicating whether or not this socket has been marked to
+    /// accept connections with `listen(2)`.
+    AcceptConn, GetOnly, libc::SOL_SOCKET, libc::SO_ACCEPTCONN, bool);
 #[cfg(any(target_os = "android", target_os = "linux"))]
-sockopt_impl!(SetOnly, RcvBufForce, libc::SOL_SOCKET, libc::SO_RCVBUFFORCE, usize);
+sockopt_impl!(
+    /// Bind this socket to a particular device like “eth0”.
+    BindToDevice, Both, libc::SOL_SOCKET, libc::SO_BINDTODEVICE, OsString<[u8; libc::IFNAMSIZ]>);
 #[cfg(any(target_os = "android", target_os = "linux"))]
-sockopt_impl!(SetOnly, SndBufForce, libc::SOL_SOCKET, libc::SO_SNDBUFFORCE, usize);
-sockopt_impl!(GetOnly, SockType, libc::SOL_SOCKET, libc::SO_TYPE, super::SockType);
-sockopt_impl!(GetOnly, AcceptConn, libc::SOL_SOCKET, libc::SO_ACCEPTCONN, bool);
+sockopt_impl!(
+    #[allow(missing_docs)]
+    // Not documented by Linux!
+    OriginalDst, GetOnly, libc::SOL_IP, libc::SO_ORIGINAL_DST, libc::sockaddr_in);
 #[cfg(any(target_os = "android", target_os = "linux"))]
-sockopt_impl!(GetOnly, OriginalDst, libc::SOL_IP, libc::SO_ORIGINAL_DST, libc::sockaddr_in);
-sockopt_impl!(Both, ReceiveTimestamp, libc::SOL_SOCKET, libc::SO_TIMESTAMP, bool);
+sockopt_impl!(
+    #[allow(missing_docs)]
+    // Not documented by Linux!
+    Ip6tOriginalDst, GetOnly, libc::SOL_IPV6, libc::IP6T_SO_ORIGINAL_DST, libc::sockaddr_in6);
+sockopt_impl!( 
+    /// Enable or disable the receiving of the `SO_TIMESTAMP` control message.
+    ReceiveTimestamp, Both, libc::SOL_SOCKET, libc::SO_TIMESTAMP, bool);
+#[cfg(all(target_os = "linux"))]
+sockopt_impl!(
+    /// Enable or disable the receiving of the `SO_TIMESTAMPNS` control message.
+    ReceiveTimestampns, Both, libc::SOL_SOCKET, libc::SO_TIMESTAMPNS, bool);
 #[cfg(any(target_os = "android", target_os = "linux"))]
-sockopt_impl!(Both, IpTransparent, libc::SOL_IP, libc::IP_TRANSPARENT, bool);
+sockopt_impl!(
+    /// Setting this boolean option enables transparent proxying on this socket.
+    IpTransparent, Both, libc::SOL_IP, libc::IP_TRANSPARENT, bool);
 #[cfg(target_os = "openbsd")]
-sockopt_impl!(Both, BindAny, libc::SOL_SOCKET, libc::SO_BINDANY, bool);
+sockopt_impl!(
+    /// Allows the socket to be bound to addresses which are not local to the
+    /// machine, so it can be used to make a transparent proxy.
+    BindAny, Both, libc::SOL_SOCKET, libc::SO_BINDANY, bool);
 #[cfg(target_os = "freebsd")]
-sockopt_impl!(Both, BindAny, libc::IPPROTO_IP, libc::IP_BINDANY, bool);
+sockopt_impl!(
+    /// Can `bind(2)` to any address, even one not bound to any available
+    /// network interface in the system.
+    BindAny, Both, libc::IPPROTO_IP, libc::IP_BINDANY, bool);
 #[cfg(target_os = "linux")]
-sockopt_impl!(Both, Mark, libc::SOL_SOCKET, libc::SO_MARK, u32);
+sockopt_impl!(
+    /// Set the mark for each packet sent through this socket (similar to the
+    /// netfilter MARK target but socket-based).
+    Mark, Both, libc::SOL_SOCKET, libc::SO_MARK, u32);
 #[cfg(any(target_os = "android", target_os = "linux"))]
-sockopt_impl!(Both, PassCred, libc::SOL_SOCKET, libc::SO_PASSCRED, bool);
+sockopt_impl!(
+    /// Enable or disable the receiving of the `SCM_CREDENTIALS` control
+    /// message.
+    PassCred, Both, libc::SOL_SOCKET, libc::SO_PASSCRED, bool);
 #[cfg(any(target_os = "freebsd", target_os = "linux"))] 
-sockopt_impl!(Both, TcpCongestion, libc::IPPROTO_TCP, libc::TCP_CONGESTION, OsString<[u8; TCP_CA_NAME_MAX]>);
+sockopt_impl!(
+    /// This option allows the caller to set the TCP congestion control
+    /// algorithm to be used,  on a per-socket basis.
+    TcpCongestion, Both, libc::IPPROTO_TCP, libc::TCP_CONGESTION, OsString<[u8; TCP_CA_NAME_MAX]>);
 #[cfg(any(
     target_os = "android",
     target_os = "ios",
@@ -278,7 +475,10 @@ sockopt_impl!(Both, TcpCongestion, libc::IPPROTO_TCP, libc::TCP_CONGESTION, OsSt
     target_os = "macos",
     target_os = "netbsd",
 ))]
-sockopt_impl!(Both, Ipv4PacketInfo, libc::IPPROTO_IP, libc::IP_PKTINFO, bool);
+sockopt_impl!(
+    /// Pass an `IP_PKTINFO` ancillary message that contains a pktinfo
+    /// structure that supplies some information about the incoming packet.
+    Ipv4PacketInfo, Both, libc::IPPROTO_IP, libc::IP_PKTINFO, bool);
 #[cfg(any(
     target_os = "android",
     target_os = "freebsd",
@@ -288,7 +488,10 @@ sockopt_impl!(Both, Ipv4PacketInfo, libc::IPPROTO_IP, libc::IP_PKTINFO, bool);
     target_os = "netbsd",
     target_os = "openbsd",
 ))]
-sockopt_impl!(Both, Ipv6RecvPacketInfo, libc::IPPROTO_IPV6, libc::IPV6_RECVPKTINFO, bool);
+sockopt_impl!(
+    /// Set delivery of the `IPV6_PKTINFO` control message on incoming
+    /// datagrams.
+    Ipv6RecvPacketInfo, Both, libc::IPPROTO_IPV6, libc::IPV6_RECVPKTINFO, bool);
 #[cfg(any(
     target_os = "freebsd",
     target_os = "ios",
@@ -296,7 +499,10 @@ sockopt_impl!(Both, Ipv6RecvPacketInfo, libc::IPPROTO_IPV6, libc::IPV6_RECVPKTIN
     target_os = "netbsd",
     target_os = "openbsd",
 ))]
-sockopt_impl!(Both, Ipv4RecvIf, libc::IPPROTO_IP, libc::IP_RECVIF, bool);
+sockopt_impl!(
+    /// The `recvmsg(2)` call returns a `struct sockaddr_dl` corresponding to
+    /// the interface on which the packet was received.
+    Ipv4RecvIf, Both, libc::IPPROTO_IP, libc::IP_RECVIF, bool);
 #[cfg(any(
     target_os = "freebsd",
     target_os = "ios",
@@ -304,9 +510,49 @@ sockopt_impl!(Both, Ipv4RecvIf, libc::IPPROTO_IP, libc::IP_RECVIF, bool);
     target_os = "netbsd",
     target_os = "openbsd",
 ))]
-sockopt_impl!(Both, Ipv4RecvDstAddr, libc::IPPROTO_IP, libc::IP_RECVDSTADDR, bool);
-
-
+sockopt_impl!(
+    /// The `recvmsg(2)` call will return the destination IP address for a UDP
+    /// datagram.
+    Ipv4RecvDstAddr, Both, libc::IPPROTO_IP, libc::IP_RECVDSTADDR, bool);
+#[cfg(target_os = "linux")]
+sockopt_impl!(
+    #[allow(missing_docs)]
+    // Not documented by Linux!
+    UdpGsoSegment, Both, libc::SOL_UDP, libc::UDP_SEGMENT, libc::c_int);
+#[cfg(target_os = "linux")]
+sockopt_impl!(
+    #[allow(missing_docs)]
+    // Not documented by Linux!
+    UdpGroSegment, Both, libc::IPPROTO_UDP, libc::UDP_GRO, bool);
+#[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+sockopt_impl!(
+    /// Indicates that an unsigned 32-bit value ancillary message (cmsg) should
+    /// be attached to received skbs indicating the number of packets dropped by
+    /// the socket since its creation.
+    RxqOvfl, Both, libc::SOL_SOCKET, libc::SO_RXQ_OVFL, libc::c_int);
+sockopt_impl!(
+    /// The socket is restricted to sending and receiving IPv6 packets only.
+    Ipv6V6Only, Both, libc::IPPROTO_IPV6, libc::IPV6_V6ONLY, bool);
+#[cfg(any(target_os = "android", target_os = "linux"))]
+sockopt_impl!(
+    /// Enable extended reliable error message passing.
+    Ipv4RecvErr, Both, libc::IPPROTO_IP, libc::IP_RECVERR, bool);
+#[cfg(any(target_os = "android", target_os = "linux"))]
+sockopt_impl!(
+    /// Control receiving of asynchronous error options.
+    Ipv6RecvErr, Both, libc::IPPROTO_IPV6, libc::IPV6_RECVERR, bool);
+#[cfg(any(target_os = "android", target_os = "freebsd", target_os = "linux"))]
+sockopt_impl!(
+    /// Set or retrieve the current time-to-live field that is used in every
+    /// packet sent from this socket.
+    Ipv4Ttl, Both, libc::IPPROTO_IP, libc::IP_TTL, libc::c_int);
+#[cfg(any(target_os = "android", target_os = "freebsd", target_os = "linux"))]
+sockopt_impl!(
+    /// Set the unicast hop limit for the socket.
+    Ipv6Ttl, Both, libc::IPPROTO_IPV6, libc::IPV6_UNICAST_HOPS, libc::c_int);
+
+#[allow(missing_docs)]
+// Not documented by Linux!
 #[cfg(any(target_os = "android", target_os = "linux"))]
 #[derive(Copy, Clone, Debug)]
 pub struct AlgSetAeadAuthSize;
@@ -329,6 +575,8 @@ impl SetSockOpt for AlgSetAeadAuthSize {
     }
 }
 
+#[allow(missing_docs)]
+// Not documented by Linux!
 #[cfg(any(target_os = "android", target_os = "linux"))]
 #[derive(Clone, Debug)]
 pub struct AlgSetKey<T>(::std::marker::PhantomData<T>);
@@ -363,21 +611,21 @@ impl<T> SetSockOpt for AlgSetKey<T> where T: AsRef<[u8]> + Clone {
  */
 
 /// Helper trait that describes what is expected from a `GetSockOpt` getter.
-unsafe trait Get<T> {
-    /// Returns an empty value.
-    unsafe fn blank() -> Self;
+trait Get<T> {
+    /// Returns an uninitialized value.
+    fn uninit() -> Self;
     /// Returns a pointer to the stored value. This pointer will be passed to the system's
     /// `getsockopt` call (`man 3p getsockopt`, argument `option_value`).
     fn ffi_ptr(&mut self) -> *mut c_void;
     /// Returns length of the stored value. This pointer will be passed to the system's
     /// `getsockopt` call (`man 3p getsockopt`, argument `option_len`).
     fn ffi_len(&mut self) -> *mut socklen_t;
-    /// Returns the stored value.
-    unsafe fn unwrap(self) -> T;
+    /// Returns the hopefully initialized inner value.
+    unsafe fn assume_init(self) -> T;
 }
 
 /// Helper trait that describes what is expected from a `SetSockOpt` setter.
-unsafe trait Set<'a, T> {
+trait Set<'a, T> {
     /// Initialize the setter with a given value.
     fn new(val: &'a T) -> Self;
     /// Returns a pointer to the stored value. This pointer will be passed to the system's
@@ -391,28 +639,28 @@ unsafe trait Set<'a, T> {
 /// Getter for an arbitrary `struct`.
 struct GetStruct<T> {
     len: socklen_t,
-    val: T,
+    val: MaybeUninit<T>,
 }
 
-unsafe impl<T> Get<T> for GetStruct<T> {
-    unsafe fn blank() -> Self {
+impl<T> Get<T> for GetStruct<T> {
+    fn uninit() -> Self {
         GetStruct {
             len: mem::size_of::<T>() as socklen_t,
-            val: mem::zeroed(),
+            val: MaybeUninit::uninit(),
         }
     }
 
     fn ffi_ptr(&mut self) -> *mut c_void {
-        &mut self.val as *mut T as *mut c_void
+        self.val.as_mut_ptr() as *mut c_void
     }
 
     fn ffi_len(&mut self) -> *mut socklen_t {
         &mut self.len
     }
 
-    unsafe fn unwrap(self) -> T {
-        assert!(self.len as usize == mem::size_of::<T>(), "invalid getsockopt implementation");
-        self.val
+    unsafe fn assume_init(self) -> T {
+        assert_eq!(self.len as usize, mem::size_of::<T>(), "invalid getsockopt implementation");
+        self.val.assume_init()
     }
 }
 
@@ -421,9 +669,9 @@ struct SetStruct<'a, T: 'static> {
     ptr: &'a T,
 }
 
-unsafe impl<'a, T> Set<'a, T> for SetStruct<'a, T> {
+impl<'a, T> Set<'a, T> for SetStruct<'a, T> {
     fn new(ptr: &'a T) -> SetStruct<'a, T> {
-        SetStruct { ptr: ptr }
+        SetStruct { ptr }
     }
 
     fn ffi_ptr(&self) -> *const c_void {
@@ -438,28 +686,28 @@ unsafe impl<'a, T> Set<'a, T> for SetStruct<'a, T> {
 /// Getter for a boolean value.
 struct GetBool {
     len: socklen_t,
-    val: c_int,
+    val: MaybeUninit<c_int>,
 }
 
-unsafe impl Get<bool> for GetBool {
-    unsafe fn blank() -> Self {
+impl Get<bool> for GetBool {
+    fn uninit() -> Self {
         GetBool {
             len: mem::size_of::<c_int>() as socklen_t,
-            val: mem::zeroed(),
+            val: MaybeUninit::uninit(),
         }
     }
 
     fn ffi_ptr(&mut self) -> *mut c_void {
-        &mut self.val as *mut c_int as *mut c_void
+        self.val.as_mut_ptr() as *mut c_void
     }
 
     fn ffi_len(&mut self) -> *mut socklen_t {
         &mut self.len
     }
 
-    unsafe fn unwrap(self) -> bool {
-        assert!(self.len as usize == mem::size_of::<c_int>(), "invalid getsockopt implementation");
-        self.val != 0
+    unsafe fn assume_init(self) -> bool {
+        assert_eq!(self.len as usize, mem::size_of::<c_int>(), "invalid getsockopt implementation");
+        self.val.assume_init() != 0
     }
 }
 
@@ -468,7 +716,7 @@ struct SetBool {
     val: c_int,
 }
 
-unsafe impl<'a> Set<'a, bool> for SetBool {
+impl<'a> Set<'a, bool> for SetBool {
     fn new(val: &'a bool) -> SetBool {
         SetBool { val: if *val { 1 } else { 0 } }
     }
@@ -485,28 +733,28 @@ unsafe impl<'a> Set<'a, bool> for SetBool {
 /// Getter for an `u8` value.
 struct GetU8 {
     len: socklen_t,
-    val: u8,
+    val: MaybeUninit<u8>,
 }
 
-unsafe impl Get<u8> for GetU8 {
-    unsafe fn blank() -> Self {
+impl Get<u8> for GetU8 {
+    fn uninit() -> Self {
         GetU8 {
             len: mem::size_of::<u8>() as socklen_t,
-            val: mem::zeroed(),
+            val: MaybeUninit::uninit(),
         }
     }
 
     fn ffi_ptr(&mut self) -> *mut c_void {
-        &mut self.val as *mut u8 as *mut c_void
+        self.val.as_mut_ptr() as *mut c_void
     }
 
     fn ffi_len(&mut self) -> *mut socklen_t {
         &mut self.len
     }
 
-    unsafe fn unwrap(self) -> u8 {
-        assert!(self.len as usize == mem::size_of::<u8>(), "invalid getsockopt implementation");
-        self.val as u8
+    unsafe fn assume_init(self) -> u8 {
+        assert_eq!(self.len as usize, mem::size_of::<u8>(), "invalid getsockopt implementation");
+        self.val.assume_init()
     }
 }
 
@@ -515,7 +763,7 @@ struct SetU8 {
     val: u8,
 }
 
-unsafe impl<'a> Set<'a, u8> for SetU8 {
+impl<'a> Set<'a, u8> for SetU8 {
     fn new(val: &'a u8) -> SetU8 {
         SetU8 { val: *val as u8 }
     }
@@ -532,28 +780,28 @@ unsafe impl<'a> Set<'a, u8> for SetU8 {
 /// Getter for an `usize` value.
 struct GetUsize {
     len: socklen_t,
-    val: c_int,
+    val: MaybeUninit<c_int>,
 }
 
-unsafe impl Get<usize> for GetUsize {
-    unsafe fn blank() -> Self {
+impl Get<usize> for GetUsize {
+    fn uninit() -> Self {
         GetUsize {
             len: mem::size_of::<c_int>() as socklen_t,
-            val: mem::zeroed(),
+            val: MaybeUninit::uninit(),
         }
     }
 
     fn ffi_ptr(&mut self) -> *mut c_void {
-        &mut self.val as *mut c_int as *mut c_void
+        self.val.as_mut_ptr() as *mut c_void
     }
 
     fn ffi_len(&mut self) -> *mut socklen_t {
         &mut self.len
     }
 
-    unsafe fn unwrap(self) -> usize {
-        assert!(self.len as usize == mem::size_of::<c_int>(), "invalid getsockopt implementation");
-        self.val as usize
+    unsafe fn assume_init(self) -> usize {
+        assert_eq!(self.len as usize, mem::size_of::<c_int>(), "invalid getsockopt implementation");
+        self.val.assume_init() as usize
     }
 }
 
@@ -562,7 +810,7 @@ struct SetUsize {
     val: c_int,
 }
 
-unsafe impl<'a> Set<'a, usize> for SetUsize {
+impl<'a> Set<'a, usize> for SetUsize {
     fn new(val: &'a usize) -> SetUsize {
         SetUsize { val: *val as c_int }
     }
@@ -579,27 +827,29 @@ unsafe impl<'a> Set<'a, usize> for SetUsize {
 /// Getter for a `OsString` value.
 struct GetOsString<T: AsMut<[u8]>> {
     len: socklen_t,
-    val: T,
+    val: MaybeUninit<T>,
 }
 
-unsafe impl<T: AsMut<[u8]>> Get<OsString> for GetOsString<T> {
-    unsafe fn blank() -> Self {
+impl<T: AsMut<[u8]>> Get<OsString> for GetOsString<T> {
+    fn uninit() -> Self {
         GetOsString {
             len: mem::size_of::<T>() as socklen_t,
-            val: mem::zeroed(),
+            val: MaybeUninit::uninit(),
         }
     }
 
     fn ffi_ptr(&mut self) -> *mut c_void {
-        &mut self.val as *mut T as *mut c_void
+        self.val.as_mut_ptr() as *mut c_void
     }
 
     fn ffi_len(&mut self) -> *mut socklen_t {
         &mut self.len
     }
 
-    unsafe fn unwrap(mut self) -> OsString {
-        OsStr::from_bytes(self.val.as_mut()).to_owned()
+    unsafe fn assume_init(self) -> OsString {
+        let len = self.len as usize;
+        let mut v = self.val.assume_init();
+        OsStr::from_bytes(&v.as_mut()[0..len]).to_owned()
     }
 }
 
@@ -608,7 +858,7 @@ struct SetOsString<'a> {
     val: &'a OsStr,
 }
 
-unsafe impl<'a> Set<'a, OsString> for SetOsString<'a> {
+impl<'a> Set<'a, OsString> for SetOsString<'a> {
     fn new(val: &'a OsString) -> SetOsString {
         SetOsString { val: val.as_os_str() }
     }
@@ -640,11 +890,11 @@ mod test {
     #[test]
     fn is_socket_type_unix() {
         use super::super::*;
-        use ::unistd::close;
+        use crate::unistd::close;
 
         let (a, b) = socketpair(AddressFamily::Unix, SockType::Stream, None, SockFlag::empty()).unwrap();
         let a_type = getsockopt(a, super::SockType).unwrap();
-        assert!(a_type == SockType::Stream);
+        assert_eq!(a_type, SockType::Stream);
         close(a).unwrap();
         close(b).unwrap();
     }
@@ -652,11 +902,11 @@ mod test {
     #[test]
     fn is_socket_type_dgram() {
         use super::super::*;
-        use ::unistd::close;
+        use crate::unistd::close;
 
         let s = socket(AddressFamily::Inet, SockType::Datagram, SockFlag::empty(), None).unwrap();
         let s_type = getsockopt(s, super::SockType).unwrap();
-        assert!(s_type == SockType::Datagram);
+        assert_eq!(s_type, SockType::Datagram);
         close(s).unwrap();
     }
 
@@ -666,7 +916,7 @@ mod test {
     #[test]
     fn can_get_listen_on_tcp_socket() {
         use super::super::*;
-        use ::unistd::close;
+        use crate::unistd::close;
 
         let s = socket(AddressFamily::Inet, SockType::Stream, SockFlag::empty(), None).unwrap();
         let s_listening = getsockopt(s, super::AcceptConn).unwrap();
diff --git a/third_party/rust/nix/src/sys/stat.rs b/third_party/rust/nix/src/sys/stat.rs
index 66c8c9dd1b720..c8f10419c31b5 100644
--- a/third_party/rust/nix/src/sys/stat.rs
+++ b/third_party/rust/nix/src/sys/stat.rs
@@ -1,15 +1,15 @@
 pub use libc::{dev_t, mode_t};
 pub use libc::stat as FileStat;
 
-use {Result, NixPath};
-use errno::Errno;
-use fcntl::{AtFlags, at_rawfd};
-use libc;
+use crate::{Result, NixPath, errno::Errno};
+#[cfg(not(target_os = "redox"))]
+use crate::fcntl::{AtFlags, at_rawfd};
 use std::mem;
 use std::os::unix::io::RawFd;
-use sys::time::{TimeSpec, TimeVal};
+use crate::sys::time::{TimeSpec, TimeVal};
 
 libc_bitflags!(
+    /// "File type" flags for `mknod` and related functions.
     pub struct SFlag: mode_t {
         S_IFIFO;
         S_IFCHR;
@@ -23,6 +23,7 @@ libc_bitflags!(
 );
 
 libc_bitflags! {
+    /// "File mode / permissions" flags.
     pub struct Mode: mode_t {
         S_IRWXU;
         S_IRUSR;
@@ -42,30 +43,45 @@ libc_bitflags! {
     }
 }
 
+/// Create a special or ordinary file, by pathname.
 pub fn mknod<P: ?Sized + NixPath>(path: &P, kind: SFlag, perm: Mode, dev: dev_t) -> Result<()> {
-    let res = path.with_nix_path(|cstr| {
-        unsafe {
-            libc::mknod(cstr.as_ptr(), kind.bits | perm.bits() as mode_t, dev)
-        }
+    let res = path.with_nix_path(|cstr| unsafe {
+        libc::mknod(cstr.as_ptr(), kind.bits | perm.bits() as mode_t, dev)
+    })?;
+
+    Errno::result(res).map(drop)
+}
+
+/// Create a special or ordinary file, relative to a given directory.
+#[cfg(not(any(target_os = "ios", target_os = "macos", target_os = "redox")))]
+pub fn mknodat<P: ?Sized + NixPath>(
+    dirfd: RawFd,
+    path: &P,
+    kind: SFlag,
+    perm: Mode,
+    dev: dev_t,
+) -> Result<()> {
+    let res = path.with_nix_path(|cstr| unsafe {
+        libc::mknodat(dirfd, cstr.as_ptr(), kind.bits | perm.bits() as mode_t, dev)
     })?;
 
     Errno::result(res).map(drop)
 }
 
 #[cfg(target_os = "linux")]
-pub fn major(dev: dev_t) -> u64 {
+pub const fn major(dev: dev_t) -> u64 {
     ((dev >> 32) & 0xffff_f000) |
     ((dev >>  8) & 0x0000_0fff)
 }
 
 #[cfg(target_os = "linux")]
-pub fn minor(dev: dev_t) -> u64 {
+pub const fn minor(dev: dev_t) -> u64 {
     ((dev >> 12) & 0xffff_ff00) |
     ((dev      ) & 0x0000_00ff)
 }
 
 #[cfg(target_os = "linux")]
-pub fn makedev(major: u64, minor: u64) -> dev_t {
+pub const fn makedev(major: u64, minor: u64) -> dev_t {
     ((major & 0xffff_f000) << 32) |
     ((major & 0x0000_0fff) <<  8) |
     ((minor & 0xffff_ff00) << 12) |
@@ -78,56 +94,57 @@ pub fn umask(mode: Mode) -> Mode {
 }
 
 pub fn stat<P: ?Sized + NixPath>(path: &P) -> Result<FileStat> {
-    let mut dst = unsafe { mem::uninitialized() };
+    let mut dst = mem::MaybeUninit::uninit();
     let res = path.with_nix_path(|cstr| {
         unsafe {
-            libc::stat(cstr.as_ptr(), &mut dst as *mut FileStat)
+            libc::stat(cstr.as_ptr(), dst.as_mut_ptr())
         }
     })?;
 
     Errno::result(res)?;
 
-    Ok(dst)
+    Ok(unsafe{dst.assume_init()})
 }
 
 pub fn lstat<P: ?Sized + NixPath>(path: &P) -> Result<FileStat> {
-    let mut dst = unsafe { mem::uninitialized() };
+    let mut dst = mem::MaybeUninit::uninit();
     let res = path.with_nix_path(|cstr| {
         unsafe {
-            libc::lstat(cstr.as_ptr(), &mut dst as *mut FileStat)
+            libc::lstat(cstr.as_ptr(), dst.as_mut_ptr())
         }
     })?;
 
     Errno::result(res)?;
 
-    Ok(dst)
+    Ok(unsafe{dst.assume_init()})
 }
 
 pub fn fstat(fd: RawFd) -> Result<FileStat> {
-    let mut dst = unsafe { mem::uninitialized() };
-    let res = unsafe { libc::fstat(fd, &mut dst as *mut FileStat) };
+    let mut dst = mem::MaybeUninit::uninit();
+    let res = unsafe { libc::fstat(fd, dst.as_mut_ptr()) };
 
     Errno::result(res)?;
 
-    Ok(dst)
+    Ok(unsafe{dst.assume_init()})
 }
 
+#[cfg(not(target_os = "redox"))]
 pub fn fstatat<P: ?Sized + NixPath>(dirfd: RawFd, pathname: &P, f: AtFlags) -> Result<FileStat> {
-    let mut dst = unsafe { mem::uninitialized() };
+    let mut dst = mem::MaybeUninit::uninit();
     let res = pathname.with_nix_path(|cstr| {
-        unsafe { libc::fstatat(dirfd, cstr.as_ptr(), &mut dst as *mut FileStat, f.bits() as libc::c_int) }
+        unsafe { libc::fstatat(dirfd, cstr.as_ptr(), dst.as_mut_ptr(), f.bits() as libc::c_int) }
     })?;
 
     Errno::result(res)?;
 
-    Ok(dst)
+    Ok(unsafe{dst.assume_init()})
 }
 
 /// Change the file permission bits of the file specified by a file descriptor.
 ///
 /// # References
 ///
-/// [fchmod(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fchmod.html).
+/// [fchmod(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fchmod.html).
 pub fn fchmod(fd: RawFd, mode: Mode) -> Result<()> {
     let res = unsafe { libc::fchmod(fd, mode.bits() as mode_t) };
 
@@ -150,13 +167,14 @@ pub enum FchmodatFlags {
 /// If `flag` is `FchmodatFlags::NoFollowSymlink` and `path` names a symbolic link,
 /// then the mode of the symbolic link is changed.
 ///
-/// `fchmod(None, path, mode, FchmodatFlags::FollowSymlink)` is identical to
+/// `fchmodat(None, path, mode, FchmodatFlags::FollowSymlink)` is identical to
 /// a call `libc::chmod(path, mode)`. That's why `chmod` is unimplemented
 /// in the `nix` crate.
 ///
 /// # References
 ///
-/// [fchmodat(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fchmodat.html).
+/// [fchmodat(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fchmodat.html).
+#[cfg(not(target_os = "redox"))]
 pub fn fchmodat<P: ?Sized + NixPath>(
     dirfd: Option<RawFd>,
     path: &P,
@@ -189,7 +207,7 @@ pub fn fchmodat<P: ?Sized + NixPath>(
 ///
 /// # References
 ///
-/// [utimes(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/utimes.html).
+/// [utimes(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/utimes.html).
 pub fn utimes<P: ?Sized + NixPath>(path: &P, atime: &TimeVal, mtime: &TimeVal) -> Result<()> {
     let times: [libc::timeval; 2] = [*atime.as_ref(), *mtime.as_ref()];
     let res = path.with_nix_path(|cstr| unsafe {
@@ -208,7 +226,7 @@ pub fn utimes<P: ?Sized + NixPath>(path: &P, atime: &TimeVal, mtime: &TimeVal) -
 ///
 /// # References
 ///
-/// [lutimes(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lutimes.html).
+/// [lutimes(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/lutimes.html).
 #[cfg(any(target_os = "linux",
           target_os = "haiku",
           target_os = "ios",
@@ -228,7 +246,7 @@ pub fn lutimes<P: ?Sized + NixPath>(path: &P, atime: &TimeVal, mtime: &TimeVal)
 ///
 /// # References
 ///
-/// [futimens(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/futimens.html).
+/// [futimens(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/futimens.html).
 #[inline]
 pub fn futimens(fd: RawFd, atime: &TimeSpec, mtime: &TimeSpec) -> Result<()> {
     let times: [libc::timespec; 2] = [*atime.as_ref(), *mtime.as_ref()];
@@ -238,6 +256,7 @@ pub fn futimens(fd: RawFd, atime: &TimeSpec, mtime: &TimeSpec) -> Result<()> {
 }
 
 /// Flags for `utimensat` function.
+// TODO: replace with fcntl::AtFlags
 #[derive(Clone, Copy, Debug)]
 pub enum UtimensatFlags {
     FollowSymlink,
@@ -259,7 +278,8 @@ pub enum UtimensatFlags {
 ///
 /// # References
 ///
-/// [utimensat(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/utimens.html).
+/// [utimensat(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/utimens.html).
+#[cfg(not(target_os = "redox"))]
 pub fn utimensat<P: ?Sized + NixPath>(
     dirfd: Option<RawFd>,
     path: &P,
@@ -285,6 +305,7 @@ pub fn utimensat<P: ?Sized + NixPath>(
     Errno::result(res).map(drop)
 }
 
+#[cfg(not(target_os = "redox"))]
 pub fn mkdirat<P: ?Sized + NixPath>(fd: RawFd, path: &P, mode: Mode) -> Result<()> {
     let res = path.with_nix_path(|cstr| {
         unsafe { libc::mkdirat(fd, cstr.as_ptr(), mode.bits() as mode_t) }
diff --git a/third_party/rust/nix/src/sys/statfs.rs b/third_party/rust/nix/src/sys/statfs.rs
index d4596bf336958..829be57f635c5 100644
--- a/third_party/rust/nix/src/sys/statfs.rs
+++ b/third_party/rust/nix/src/sys/statfs.rs
@@ -1,95 +1,144 @@
+//! Get filesystem statistics, non-portably
+//!
+//! See [`statvfs`](crate::sys::statvfs) for a portable alternative.
 use std::fmt::{self, Debug};
 use std::mem;
 use std::os::unix::io::AsRawFd;
 #[cfg(not(any(target_os = "linux", target_os = "android")))]
 use std::ffi::CStr;
 
-use libc;
-
-use {NixPath, Result};
-use errno::Errno;
+use crate::{NixPath, Result, errno::Errno};
 
+/// Identifies a mounted file system
 #[cfg(target_os = "android")]
 pub type fsid_t = libc::__fsid_t;
+/// Identifies a mounted file system
 #[cfg(not(target_os = "android"))]
 pub type fsid_t = libc::fsid_t;
 
+/// Describes a mounted file system
 #[derive(Clone, Copy)]
+#[repr(transparent)]
 pub struct Statfs(libc::statfs);
 
 #[cfg(target_os = "freebsd")]
-#[derive(Eq, Copy, Clone, PartialEq, Debug)]
-pub struct FsType(u32);
+type fs_type_t = u32;
 #[cfg(target_os = "android")]
-#[derive(Eq, Copy, Clone, PartialEq, Debug)]
-pub struct FsType(libc::c_ulong);
+type fs_type_t = libc::c_ulong;
 #[cfg(all(target_os = "linux", target_arch = "s390x"))]
-#[derive(Eq, Copy, Clone, PartialEq, Debug)]
-pub struct FsType(u32);
+type fs_type_t = libc::c_uint;
 #[cfg(all(target_os = "linux", target_env = "musl"))]
-#[derive(Eq, Copy, Clone, PartialEq, Debug)]
-pub struct FsType(libc::c_ulong);
+type fs_type_t = libc::c_ulong;
 #[cfg(all(target_os = "linux", not(any(target_arch = "s390x", target_env = "musl"))))]
+type fs_type_t = libc::__fsword_t;
+
+/// Describes the file system type as known by the operating system.
+#[cfg(any(
+    target_os = "freebsd",
+    target_os = "android",
+    all(target_os = "linux", target_arch = "s390x"),
+    all(target_os = "linux", target_env = "musl"),
+    all(target_os = "linux", not(any(target_arch = "s390x", target_env = "musl"))),
+))]
 #[derive(Eq, Copy, Clone, PartialEq, Debug)]
-pub struct FsType(libc::c_long);
-
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const ADFS_SUPER_MAGIC: FsType = FsType(libc::ADFS_SUPER_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const AFFS_SUPER_MAGIC: FsType = FsType(libc::AFFS_SUPER_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const CODA_SUPER_MAGIC: FsType = FsType(libc::CODA_SUPER_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const CRAMFS_MAGIC: FsType = FsType(libc::CRAMFS_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const EFS_SUPER_MAGIC: FsType = FsType(libc::EFS_SUPER_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const EXT2_SUPER_MAGIC: FsType = FsType(libc::EXT2_SUPER_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const EXT3_SUPER_MAGIC: FsType = FsType(libc::EXT3_SUPER_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const EXT4_SUPER_MAGIC: FsType = FsType(libc::EXT4_SUPER_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const HPFS_SUPER_MAGIC: FsType = FsType(libc::HPFS_SUPER_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const HUGETLBFS_MAGIC: FsType = FsType(libc::HUGETLBFS_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const ISOFS_SUPER_MAGIC: FsType = FsType(libc::ISOFS_SUPER_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const JFFS2_SUPER_MAGIC: FsType = FsType(libc::JFFS2_SUPER_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const MINIX_SUPER_MAGIC: FsType = FsType(libc::MINIX_SUPER_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const MINIX_SUPER_MAGIC2: FsType = FsType(libc::MINIX_SUPER_MAGIC2);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const MINIX2_SUPER_MAGIC: FsType = FsType(libc::MINIX2_SUPER_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const MINIX2_SUPER_MAGIC2: FsType = FsType(libc::MINIX2_SUPER_MAGIC2);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const MSDOS_SUPER_MAGIC: FsType = FsType(libc::MSDOS_SUPER_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const NCP_SUPER_MAGIC: FsType = FsType(libc::NCP_SUPER_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const NFS_SUPER_MAGIC: FsType = FsType(libc::NFS_SUPER_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const OPENPROM_SUPER_MAGIC: FsType = FsType(libc::OPENPROM_SUPER_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const PROC_SUPER_MAGIC: FsType = FsType(libc::PROC_SUPER_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const QNX4_SUPER_MAGIC: FsType = FsType(libc::QNX4_SUPER_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const REISERFS_SUPER_MAGIC: FsType = FsType(libc::REISERFS_SUPER_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const SMB_SUPER_MAGIC: FsType = FsType(libc::SMB_SUPER_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const TMPFS_MAGIC: FsType = FsType(libc::TMPFS_MAGIC);
-#[cfg(all(target_os = "linux", not(target_env = "musl"), not(target_arch = "s390x")))]
-pub const USBDEVICE_SUPER_MAGIC: FsType = FsType(libc::USBDEVICE_SUPER_MAGIC);
+pub struct FsType(pub fs_type_t);
+
+// These constants are defined without documentation in the Linux headers, so we
+// can't very well document them here.
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const ADFS_SUPER_MAGIC: FsType = FsType(libc::ADFS_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const AFFS_SUPER_MAGIC: FsType = FsType(libc::AFFS_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const CODA_SUPER_MAGIC: FsType = FsType(libc::CODA_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const CRAMFS_MAGIC: FsType = FsType(libc::CRAMFS_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const EFS_SUPER_MAGIC: FsType = FsType(libc::EFS_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const EXT2_SUPER_MAGIC: FsType = FsType(libc::EXT2_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const EXT3_SUPER_MAGIC: FsType = FsType(libc::EXT3_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const EXT4_SUPER_MAGIC: FsType = FsType(libc::EXT4_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const HPFS_SUPER_MAGIC: FsType = FsType(libc::HPFS_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const HUGETLBFS_MAGIC: FsType = FsType(libc::HUGETLBFS_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const ISOFS_SUPER_MAGIC: FsType = FsType(libc::ISOFS_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const JFFS2_SUPER_MAGIC: FsType = FsType(libc::JFFS2_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const MINIX_SUPER_MAGIC: FsType = FsType(libc::MINIX_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const MINIX_SUPER_MAGIC2: FsType = FsType(libc::MINIX_SUPER_MAGIC2 as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const MINIX2_SUPER_MAGIC: FsType = FsType(libc::MINIX2_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const MINIX2_SUPER_MAGIC2: FsType = FsType(libc::MINIX2_SUPER_MAGIC2 as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const MSDOS_SUPER_MAGIC: FsType = FsType(libc::MSDOS_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const NCP_SUPER_MAGIC: FsType = FsType(libc::NCP_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const NFS_SUPER_MAGIC: FsType = FsType(libc::NFS_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const OPENPROM_SUPER_MAGIC: FsType = FsType(libc::OPENPROM_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const OVERLAYFS_SUPER_MAGIC: FsType = FsType(libc::OVERLAYFS_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const PROC_SUPER_MAGIC: FsType = FsType(libc::PROC_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const QNX4_SUPER_MAGIC: FsType = FsType(libc::QNX4_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const REISERFS_SUPER_MAGIC: FsType = FsType(libc::REISERFS_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const SMB_SUPER_MAGIC: FsType = FsType(libc::SMB_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const TMPFS_MAGIC: FsType = FsType(libc::TMPFS_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const USBDEVICE_SUPER_MAGIC: FsType = FsType(libc::USBDEVICE_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const CGROUP_SUPER_MAGIC: FsType = FsType(libc::CGROUP_SUPER_MAGIC as fs_type_t);
+#[cfg(all(target_os = "linux", not(target_env = "musl")))]
+#[allow(missing_docs)]
+pub const CGROUP2_SUPER_MAGIC: FsType = FsType(libc::CGROUP2_SUPER_MAGIC as fs_type_t);
+
 
 impl Statfs {
     /// Magic code defining system type
     #[cfg(not(any(
         target_os = "openbsd",
+        target_os = "dragonfly",
         target_os = "ios",
         target_os = "macos"
     )))]
@@ -105,32 +154,35 @@ impl Statfs {
     }
 
     /// Optimal transfer block size
-    #[cfg(any(target_os = "ios", target_os = "macos", target_os = "openbsd"))]
+    #[cfg(any(target_os = "ios", target_os = "macos"))]
     pub fn optimal_transfer_size(&self) -> i32 {
         self.0.f_iosize
     }
 
     /// Optimal transfer block size
-    #[cfg(all(target_os = "linux", target_arch = "s390x"))]
+    #[cfg(target_os = "openbsd")]
     pub fn optimal_transfer_size(&self) -> u32 {
-        self.0.f_bsize
+        self.0.f_iosize
     }
 
     /// Optimal transfer block size
-    #[cfg(all(target_os = "linux", target_env = "musl"))]
-    pub fn optimal_transfer_size(&self) -> libc::c_ulong {
+    #[cfg(all(target_os = "linux", target_arch = "s390x"))]
+    pub fn optimal_transfer_size(&self) -> u32 {
         self.0.f_bsize
     }
 
     /// Optimal transfer block size
-    #[cfg(all(target_os = "linux", not(any(target_arch = "s390x", target_env = "musl"))))]
-    pub fn optimal_transfer_size(&self) -> libc::c_long {
+    #[cfg(any(
+        target_os = "android",
+        all(target_os = "linux", target_env = "musl")
+    ))]
+    pub fn optimal_transfer_size(&self) -> libc::c_ulong {
         self.0.f_bsize
     }
 
     /// Optimal transfer block size
-    #[cfg(target_os = "android")]
-    pub fn optimal_transfer_size(&self) -> libc::c_ulong {
+    #[cfg(all(target_os = "linux", not(any(target_arch = "s390x", target_env = "musl"))))]
+    pub fn optimal_transfer_size(&self) -> libc::__fsword_t {
         self.0.f_bsize
     }
 
@@ -169,7 +221,7 @@ impl Statfs {
     /// Size of a block
     // f_bsize on linux: https://github.com/torvalds/linux/blob/master/fs/nfs/super.c#L471
     #[cfg(all(target_os = "linux", not(any(target_arch = "s390x", target_env = "musl"))))]
-    pub fn block_size(&self) -> libc::c_long {
+    pub fn block_size(&self) -> libc::__fsword_t {
         self.0.f_bsize
     }
 
@@ -211,7 +263,7 @@ impl Statfs {
 
     /// Maximum length of filenames
     #[cfg(all(target_os = "linux", not(any(target_arch = "s390x", target_env = "musl"))))]
-    pub fn maximum_name_length(&self) -> libc::c_long {
+    pub fn maximum_name_length(&self) -> libc::__fsword_t {
         self.0.f_namelen
     }
 
@@ -240,7 +292,7 @@ impl Statfs {
     }
 
     /// Total data blocks in filesystem
-    #[cfg(all(target_os = "linux", target_env = "musl"))]
+    #[cfg(all(target_os = "linux", any(target_env = "musl", all(target_arch = "x86_64", target_pointer_width = "32"))))]
     pub fn blocks(&self) -> u64 {
         self.0.f_blocks
     }
@@ -253,7 +305,7 @@ impl Statfs {
         target_os = "freebsd",
         target_os = "openbsd",
         target_os = "dragonfly",
-        all(target_os = "linux", target_env = "musl")
+        all(target_os = "linux", any(target_env = "musl", all(target_arch = "x86_64", target_pointer_width = "32")))
     )))]
     pub fn blocks(&self) -> libc::c_ulong {
         self.0.f_blocks
@@ -278,7 +330,7 @@ impl Statfs {
     }
 
     /// Free blocks in filesystem
-    #[cfg(all(target_os = "linux", target_env = "musl"))]
+    #[cfg(all(target_os = "linux", any(target_env = "musl", all(target_arch = "x86_64", target_pointer_width = "32"))))]
     pub fn blocks_free(&self) -> u64 {
         self.0.f_bfree
     }
@@ -291,7 +343,7 @@ impl Statfs {
         target_os = "freebsd",
         target_os = "openbsd",
         target_os = "dragonfly",
-        all(target_os = "linux", target_env = "musl")
+        all(target_os = "linux", any(target_env = "musl", all(target_arch = "x86_64", target_pointer_width = "32")))
     )))]
     pub fn blocks_free(&self) -> libc::c_ulong {
         self.0.f_bfree
@@ -316,7 +368,7 @@ impl Statfs {
     }
 
     /// Free blocks available to unprivileged user
-    #[cfg(all(target_os = "linux", target_env = "musl"))]
+    #[cfg(all(target_os = "linux", any(target_env = "musl", all(target_arch = "x86_64", target_pointer_width = "32"))))]
     pub fn blocks_available(&self) -> u64 {
         self.0.f_bavail
     }
@@ -329,7 +381,7 @@ impl Statfs {
         target_os = "freebsd",
         target_os = "openbsd",
         target_os = "dragonfly",
-        all(target_os = "linux", target_env = "musl")
+        all(target_os = "linux", any(target_env = "musl", all(target_arch = "x86_64", target_pointer_width = "32")))
     )))]
     pub fn blocks_available(&self) -> libc::c_ulong {
         self.0.f_bavail
@@ -354,8 +406,8 @@ impl Statfs {
     }
 
     /// Total file nodes in filesystem
-    #[cfg(all(target_os = "linux", target_env = "musl"))]
-    pub fn files(&self) -> u64 {
+    #[cfg(all(target_os = "linux", any(target_env = "musl", all(target_arch = "x86_64", target_pointer_width = "32"))))]
+    pub fn files(&self) -> libc::fsfilcnt_t {
         self.0.f_files
     }
 
@@ -367,14 +419,19 @@ impl Statfs {
         target_os = "freebsd",
         target_os = "openbsd",
         target_os = "dragonfly",
-        all(target_os = "linux", target_env = "musl")
+        all(target_os = "linux", any(target_env = "musl", all(target_arch = "x86_64", target_pointer_width = "32")))
     )))]
     pub fn files(&self) -> libc::c_ulong {
         self.0.f_files
     }
 
     /// Free file nodes in filesystem
-    #[cfg(any(target_os = "ios", target_os = "macos", target_os = "android"))]
+    #[cfg(any(
+            target_os = "android",
+            target_os = "ios",
+            target_os = "macos",
+            target_os = "openbsd"
+    ))]
     pub fn files_free(&self) -> u64 {
         self.0.f_ffree
     }
@@ -386,14 +443,14 @@ impl Statfs {
     }
 
     /// Free file nodes in filesystem
-    #[cfg(any(target_os = "freebsd", target_os = "openbsd"))]
+    #[cfg(target_os = "freebsd")]
     pub fn files_free(&self) -> i64 {
         self.0.f_ffree
     }
 
     /// Free file nodes in filesystem
-    #[cfg(all(target_os = "linux", target_env = "musl"))]
-    pub fn files_free(&self) -> u64 {
+    #[cfg(all(target_os = "linux", any(target_env = "musl", all(target_arch = "x86_64", target_pointer_width = "32"))))]
+    pub fn files_free(&self) -> libc::fsfilcnt_t {
         self.0.f_ffree
     }
 
@@ -405,7 +462,7 @@ impl Statfs {
         target_os = "freebsd",
         target_os = "openbsd",
         target_os = "dragonfly",
-        all(target_os = "linux", target_env = "musl")
+        all(target_os = "linux", any(target_env = "musl", all(target_arch = "x86_64", target_pointer_width = "32")))
     )))]
     pub fn files_free(&self) -> libc::c_ulong {
         self.0.f_ffree
@@ -432,18 +489,35 @@ impl Debug for Statfs {
     }
 }
 
+/// Describes a mounted file system.
+///
+/// The result is OS-dependent.  For a portabable alternative, see
+/// [`statvfs`](crate::sys::statvfs::statvfs).
+///
+/// # Arguments
+///
+/// `path` - Path to any file within the file system to describe
 pub fn statfs<P: ?Sized + NixPath>(path: &P) -> Result<Statfs> {
     unsafe {
-        let mut stat: Statfs = mem::uninitialized();
-        let res = path.with_nix_path(|path| libc::statfs(path.as_ptr(), &mut stat.0))?;
-        Errno::result(res).map(|_| stat)
+        let mut stat = mem::MaybeUninit::<libc::statfs>::uninit();
+        let res = path.with_nix_path(|path| libc::statfs(path.as_ptr(), stat.as_mut_ptr()))?;
+        Errno::result(res).map(|_| Statfs(stat.assume_init()))
     }
 }
 
+/// Describes a mounted file system.
+///
+/// The result is OS-dependent.  For a portabable alternative, see
+/// [`fstatvfs`](crate::sys::statvfs::fstatvfs).
+///
+/// # Arguments
+///
+/// `fd` - File descriptor of any open file within the file system to describe
 pub fn fstatfs<T: AsRawFd>(fd: &T) -> Result<Statfs> {
     unsafe {
-        let mut stat: Statfs = mem::uninitialized();
-        Errno::result(libc::fstatfs(fd.as_raw_fd(), &mut stat.0)).map(|_| stat)
+        let mut stat = mem::MaybeUninit::<libc::statfs>::uninit();
+        Errno::result(libc::fstatfs(fd.as_raw_fd(), stat.as_mut_ptr()))
+            .map(|_| Statfs(stat.assume_init()))
     }
 }
 
@@ -451,8 +525,8 @@ pub fn fstatfs<T: AsRawFd>(fd: &T) -> Result<Statfs> {
 mod test {
     use std::fs::File;
 
-    use sys::statfs::*;
-    use sys::statvfs::*;
+    use crate::sys::statfs::*;
+    use crate::sys::statvfs::*;
     use std::path::Path;
 
     #[test]
diff --git a/third_party/rust/nix/src/sys/statvfs.rs b/third_party/rust/nix/src/sys/statvfs.rs
index e5980369d5119..15e7a7d4ab2e4 100644
--- a/third_party/rust/nix/src/sys/statvfs.rs
+++ b/third_party/rust/nix/src/sys/statvfs.rs
@@ -1,15 +1,15 @@
 //! Get filesystem statistics
 //!
-//! See [the man pages](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fstatvfs.html)
+//! See [the man pages](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fstatvfs.html)
 //! for more details.
 use std::mem;
 use std::os::unix::io::AsRawFd;
 
 use libc::{self, c_ulong};
 
-use {Result, NixPath};
-use errno::Errno;
+use crate::{Result, NixPath, errno::Errno};
 
+#[cfg(not(target_os = "redox"))]
 libc_bitflags!(
     /// File system mount Flags
     #[repr(C)]
@@ -54,9 +54,8 @@ libc_bitflags!(
 
 /// Wrapper around the POSIX `statvfs` struct
 ///
-/// For more information see the [`statvfs(3)` man pages](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_statvfs.h.html).
-// FIXME: Replace with repr(transparent)
-#[repr(C)]
+/// For more information see the [`statvfs(3)` man pages](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_statvfs.h.html).
+#[repr(transparent)]
 #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
 pub struct Statvfs(libc::statvfs);
 
@@ -109,6 +108,7 @@ impl Statvfs {
     }
 
     /// Get the mount flags
+    #[cfg(not(target_os = "redox"))]
     pub fn flags(&self) -> FsFlags {
         FsFlags::from_bits_truncate(self.0.f_flag)
     }
@@ -124,12 +124,12 @@ impl Statvfs {
 pub fn statvfs<P: ?Sized + NixPath>(path: &P) -> Result<Statvfs> {
     unsafe {
         Errno::clear();
-        let mut stat: Statvfs = mem::uninitialized();
+        let mut stat = mem::MaybeUninit::<libc::statvfs>::uninit();
         let res = path.with_nix_path(|path|
-            libc::statvfs(path.as_ptr(), &mut stat.0)
+            libc::statvfs(path.as_ptr(), stat.as_mut_ptr())
         )?;
 
-        Errno::result(res).map(|_| stat)
+        Errno::result(res).map(|_| Statvfs(stat.assume_init()))
     }
 }
 
@@ -137,19 +137,20 @@ pub fn statvfs<P: ?Sized + NixPath>(path: &P) -> Result<Statvfs> {
 pub fn fstatvfs<T: AsRawFd>(fd: &T) -> Result<Statvfs> {
     unsafe {
         Errno::clear();
-        let mut stat: Statvfs = mem::uninitialized();
-        Errno::result(libc::fstatvfs(fd.as_raw_fd(), &mut stat.0)).map(|_| stat)
+        let mut stat = mem::MaybeUninit::<libc::statvfs>::uninit();
+        Errno::result(libc::fstatvfs(fd.as_raw_fd(), stat.as_mut_ptr()))
+            .map(|_| Statvfs(stat.assume_init()))
     }
 }
 
 #[cfg(test)]
 mod test {
     use std::fs::File;
-    use sys::statvfs::*;
+    use crate::sys::statvfs::*;
 
     #[test]
     fn statvfs_call() {
-        statvfs("/".as_bytes()).unwrap();
+        statvfs(&b"/"[..]).unwrap();
     }
 
     #[test]
diff --git a/third_party/rust/nix/src/sys/sysinfo.rs b/third_party/rust/nix/src/sys/sysinfo.rs
index 4c8e38988886d..dc943c1adce12 100644
--- a/third_party/rust/nix/src/sys/sysinfo.rs
+++ b/third_party/rust/nix/src/sys/sysinfo.rs
@@ -2,13 +2,20 @@ use libc::{self, SI_LOAD_SHIFT};
 use std::{cmp, mem};
 use std::time::Duration;
 
-use Result;
-use errno::Errno;
+use crate::Result;
+use crate::errno::Errno;
 
 /// System info structure returned by `sysinfo`.
 #[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]
+#[repr(transparent)]
 pub struct SysInfo(libc::sysinfo);
 
+// The fields are c_ulong on 32-bit linux, u64 on 64-bit linux; x32's ulong is u32
+#[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+type mem_blocks_t = u64;
+#[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+type mem_blocks_t = libc::c_ulong;
+
 impl SysInfo {
     /// Returns the load average tuple.
     ///
@@ -57,16 +64,16 @@ impl SysInfo {
         self.scale_mem(self.0.freeram)
     }
 
-    fn scale_mem(&self, units: libc::c_ulong) -> u64 {
+    fn scale_mem(&self, units: mem_blocks_t) -> u64 {
         units as u64 * self.0.mem_unit as u64
     }
 }
 
 /// Returns system information.
 ///
-/// [See `sysinfo(2)`](http://man7.org/linux/man-pages/man2/sysinfo.2.html).
+/// [See `sysinfo(2)`](https://man7.org/linux/man-pages/man2/sysinfo.2.html).
 pub fn sysinfo() -> Result<SysInfo> {
-    let mut info: libc::sysinfo = unsafe { mem::uninitialized() };
-    let res = unsafe { libc::sysinfo(&mut info) };
-    Errno::result(res).map(|_| SysInfo(info))
+    let mut info = mem::MaybeUninit::uninit();
+    let res = unsafe { libc::sysinfo(info.as_mut_ptr()) };
+    Errno::result(res).map(|_| unsafe{ SysInfo(info.assume_init()) })
 }
diff --git a/third_party/rust/nix/src/sys/termios.rs b/third_party/rust/nix/src/sys/termios.rs
index c7cdf10b461c1..01d460803913a 100644
--- a/third_party/rust/nix/src/sys/termios.rs
+++ b/third_party/rust/nix/src/sys/termios.rs
@@ -5,7 +5,7 @@
 //! types here or exported directly.
 //!
 //! If you are unfamiliar with the `termios` API, you should first read the
-//! [API documentation](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/termios.h.html) and
+//! [API documentation](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/termios.h.html) and
 //! then come back to understand how `nix` safely wraps it.
 //!
 //! It should be noted that this API incurs some runtime overhead above the base `libc` definitions.
@@ -25,7 +25,7 @@
 //! ```
 //! # use self::nix::sys::termios::SpecialCharacterIndices::VEOF;
 //! # use self::nix::sys::termios::{_POSIX_VDISABLE, Termios};
-//! # let mut termios = unsafe { Termios::default_uninit() };
+//! # let mut termios: Termios = unsafe { std::mem::zeroed() };
 //! termios.control_chars[VEOF as usize] = _POSIX_VDISABLE;
 //! ```
 //!
@@ -38,7 +38,7 @@
 //!
 //! ```
 //! # use self::nix::sys::termios::{ControlFlags, Termios};
-//! # let mut termios = unsafe { Termios::default_uninit() };
+//! # let mut termios: Termios = unsafe { std::mem::zeroed() };
 //! termios.control_flags & ControlFlags::CSIZE == ControlFlags::CS5;
 //! termios.control_flags |= ControlFlags::CS5;
 //! ```
@@ -61,10 +61,9 @@
 //! platforms:
 //!
 //! ```rust
-//! # #[macro_use] extern crate nix;
 //! # use nix::sys::termios::{BaudRate, cfsetispeed, cfsetospeed, cfsetspeed, Termios};
 //! # fn main() {
-//! # let mut t = unsafe { Termios::default_uninit() };
+//! # let mut t: Termios = unsafe { std::mem::zeroed() };
 //! cfsetispeed(&mut t, BaudRate::B9600);
 //! cfsetospeed(&mut t, BaudRate::B9600);
 //! cfsetspeed(&mut t, BaudRate::B9600);
@@ -74,102 +73,94 @@
 //! Additionally round-tripping baud rates is consistent across platforms:
 //!
 //! ```rust
-//! # extern crate nix;
 //! # use nix::sys::termios::{BaudRate, cfgetispeed, cfgetospeed, cfsetispeed, cfsetspeed, Termios};
 //! # fn main() {
-//! # let mut t = unsafe { Termios::default_uninit() };
+//! # let mut t: Termios = unsafe { std::mem::zeroed() };
 //! # cfsetspeed(&mut t, BaudRate::B9600);
 //! let speed = cfgetispeed(&t);
-//! assert!(speed == cfgetospeed(&t));
+//! assert_eq!(speed, cfgetospeed(&t));
 //! cfsetispeed(&mut t, speed);
 //! # }
 //! ```
 //!
 //! On non-BSDs, `cfgetispeed()` and `cfgetospeed()` both return a `BaudRate`:
 //!
-// FIXME: Replace `ignore` with `compile_fail` once 1.22 is the minimum support Rust version
 #![cfg_attr(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
                 target_os = "macos", target_os = "netbsd", target_os = "openbsd"),
             doc = " ```rust,ignore")]
 #![cfg_attr(not(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
                     target_os = "macos", target_os = "netbsd", target_os = "openbsd")),
             doc = " ```rust")]
-//! # extern crate nix;
 //! # use nix::sys::termios::{BaudRate, cfgetispeed, cfgetospeed, cfsetspeed, Termios};
 //! # fn main() {
-//! # let mut t = unsafe { Termios::default_uninit() };
+//! # let mut t: Termios = unsafe { std::mem::zeroed() };
 //! # cfsetspeed(&mut t, BaudRate::B9600);
-//! assert!(cfgetispeed(&t) == BaudRate::B9600);
-//! assert!(cfgetospeed(&t) == BaudRate::B9600);
+//! assert_eq!(cfgetispeed(&t), BaudRate::B9600);
+//! assert_eq!(cfgetospeed(&t), BaudRate::B9600);
 //! # }
 //! ```
 //!
 //! But on the BSDs, `cfgetispeed()` and `cfgetospeed()` both return `u32`s:
 //!
-// FIXME: Replace `ignore` with `compile_fail` once 1.22 is the minimum support Rust version
 #![cfg_attr(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
                 target_os = "macos", target_os = "netbsd", target_os = "openbsd"),
             doc = " ```rust")]
 #![cfg_attr(not(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
                     target_os = "macos", target_os = "netbsd", target_os = "openbsd")),
             doc = " ```rust,ignore")]
-//! # extern crate nix;
 //! # use nix::sys::termios::{BaudRate, cfgetispeed, cfgetospeed, cfsetspeed, Termios};
 //! # fn main() {
-//! # let mut t = unsafe { Termios::default_uninit() };
+//! # let mut t: Termios = unsafe { std::mem::zeroed() };
 //! # cfsetspeed(&mut t, 9600u32);
-//! assert!(cfgetispeed(&t) == 9600u32);
-//! assert!(cfgetospeed(&t) == 9600u32);
+//! assert_eq!(cfgetispeed(&t), 9600u32);
+//! assert_eq!(cfgetospeed(&t), 9600u32);
 //! # }
 //! ```
 //!
 //! It's trivial to convert from a `BaudRate` to a `u32` on BSDs:
 //!
-// FIXME: Replace `ignore` with `compile_fail` once 1.22 is the minimum support Rust version
 #![cfg_attr(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
                 target_os = "macos", target_os = "netbsd", target_os = "openbsd"),
             doc = " ```rust")]
 #![cfg_attr(not(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
                     target_os = "macos", target_os = "netbsd", target_os = "openbsd")),
             doc = " ```rust,ignore")]
-//! # extern crate nix;
 //! # use nix::sys::termios::{BaudRate, cfgetispeed, cfsetspeed, Termios};
 //! # fn main() {
-//! # let mut t = unsafe { Termios::default_uninit() };
+//! # let mut t: Termios = unsafe { std::mem::zeroed() };
 //! # cfsetspeed(&mut t, 9600u32);
-//! assert!(cfgetispeed(&t) == BaudRate::B9600.into());
-//! assert!(u32::from(BaudRate::B9600) == 9600u32);
+//! assert_eq!(cfgetispeed(&t), BaudRate::B9600.into());
+//! assert_eq!(u32::from(BaudRate::B9600), 9600u32);
 //! # }
 //! ```
 //!
 //! And on BSDs you can specify arbitrary baud rates (**note** this depends on hardware support)
 //! by specifying baud rates directly using `u32`s:
 //!
-// FIXME: Replace `ignore` with `compile_fail` once 1.22 is the minimum support Rust version
 #![cfg_attr(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
                 target_os = "macos", target_os = "netbsd", target_os = "openbsd"),
             doc = " ```rust")]
 #![cfg_attr(not(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
                     target_os = "macos", target_os = "netbsd", target_os = "openbsd")),
             doc = " ```rust,ignore")]
-//! # extern crate nix;
 //! # use nix::sys::termios::{cfsetispeed, cfsetospeed, cfsetspeed, Termios};
 //! # fn main() {
-//! # let mut t = unsafe { Termios::default_uninit() };
+//! # let mut t: Termios = unsafe { std::mem::zeroed() };
 //! cfsetispeed(&mut t, 9600u32);
 //! cfsetospeed(&mut t, 9600u32);
 //! cfsetspeed(&mut t, 9600u32);
 //! # }
 //! ```
-use Result;
-use errno::Errno;
+use cfg_if::cfg_if;
+use crate::Result;
+use crate::errno::Errno;
 use libc::{self, c_int, tcflag_t};
 use std::cell::{Ref, RefCell};
 use std::convert::From;
 use std::mem;
 use std::os::unix::io::RawFd;
 
-use ::unistd::Pid;
+use crate::unistd::Pid;
 
 /// Stores settings for the termios API
 ///
@@ -194,24 +185,9 @@ pub struct Termios {
 impl Termios {
     /// Exposes an immutable reference to the underlying `libc::termios` data structure.
     ///
-    /// This can be used for interfacing with other FFI functions like:
-    ///
-    /// ```rust
-    /// # extern crate libc;
-    /// # extern crate nix;
-    /// # fn main() {
-    /// # use nix::sys::termios::Termios;
-    /// # let mut termios = unsafe { Termios::default_uninit() };
-    /// let inner_termios = termios.get_libc_termios();
-    /// unsafe { libc::cfgetispeed(&*inner_termios) };
-    /// # }
-    /// ```
-    ///
-    /// There is no public API exposed for functions that modify the underlying `libc::termios`
-    /// data because it requires additional work to maintain type safety.
-    // FIXME: Switch this over to use pub(crate)
-    #[doc(hidden)]
-    pub fn get_libc_termios(&self) -> Ref<libc::termios> {
+    /// This is not part of `nix`'s public API because it requires additional work to maintain type
+    /// safety.
+    pub(crate) fn get_libc_termios(&self) -> Ref<libc::termios> {
         {
             let mut termios = self.inner.borrow_mut();
             termios.c_iflag = self.input_flags.bits();
@@ -225,12 +201,11 @@ impl Termios {
 
     /// Exposes the inner `libc::termios` datastore within `Termios`.
     ///
-    /// This is unsafe because if this is used to modify the inner libc::termios struct, it will not
-    /// automatically update the safe wrapper type around it. Therefore we disable docs to
-    /// effectively limit its use to nix internals. In this case it should also be paired with a
-    /// call to `update_wrapper()` so that the wrapper-type and internal representation stay
-    /// consistent.
-    unsafe fn get_libc_termios_mut(&mut self) -> *mut libc::termios {
+    /// This is unsafe because if this is used to modify the inner `libc::termios` struct, it will
+    /// not automatically update the safe wrapper type around it. In this case it should also be
+    /// paired with a call to `update_wrapper()` so that the wrapper-type and internal
+    /// representation stay consistent.
+    pub(crate) unsafe fn get_libc_termios_mut(&mut self) -> *mut libc::termios {
         {
             let mut termios = self.inner.borrow_mut();
             termios.c_iflag = self.input_flags.bits();
@@ -242,26 +217,8 @@ impl Termios {
         self.inner.as_ptr()
     }
 
-    /// Allows for easily creating new `Termios` structs that will be overwritten with real data.
-    ///
-    /// This should only be used when the inner libc::termios struct will be overwritten before it's
-    /// read.
-    // FIXME: Switch this over to use pub(crate)
-    #[doc(hidden)]
-    pub unsafe fn default_uninit() -> Self {
-        Termios {
-            inner: RefCell::new(mem::uninitialized()),
-            input_flags: InputFlags::empty(),
-            output_flags: OutputFlags::empty(),
-            control_flags: ControlFlags::empty(),
-            local_flags: LocalFlags::empty(),
-            control_chars: [0 as libc::cc_t; NCCS],
-        }
-    }
-
     /// Updates the wrapper values from the internal `libc::termios` data structure.
-    #[doc(hidden)]
-    pub fn update_wrapper(&mut self) {
+    pub(crate) fn update_wrapper(&mut self) {
         let termios = *self.inner.borrow_mut();
         self.input_flags = InputFlags::from_bits_truncate(termios.c_iflag);
         self.output_flags = OutputFlags::from_bits_truncate(termios.c_oflag);
@@ -299,6 +256,7 @@ libc_enum!{
     /// B0 is special and will disable the port.
     #[cfg_attr(all(any(target_os = "ios", target_os = "macos"), target_pointer_width = "64"), repr(u64))]
     #[cfg_attr(not(all(any(target_os = "ios", target_os = "macos"), target_pointer_width = "64")), repr(u32))]
+    #[non_exhaustive]
     pub enum BaudRate {
         B0,
         B50,
@@ -342,11 +300,17 @@ libc_enum!{
                 target_os = "openbsd"))]
         B76800,
         B115200,
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        B153600,
         B230400,
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        B307200,
         #[cfg(any(target_os = "android",
                   target_os = "freebsd",
+                  target_os = "illumos",
                   target_os = "linux",
-                  target_os = "netbsd"))]
+                  target_os = "netbsd",
+                  target_os = "solaris"))]
         B460800,
         #[cfg(any(target_os = "android", target_os = "linux"))]
         B500000,
@@ -354,8 +318,10 @@ libc_enum!{
         B576000,
         #[cfg(any(target_os = "android",
                   target_os = "freebsd",
+                  target_os = "illumos",
                   target_os = "linux",
-                  target_os = "netbsd"))]
+                  target_os = "netbsd",
+                  target_os = "solaris"))]
         B921600,
         #[cfg(any(target_os = "android", target_os = "linux"))]
         B1000000,
@@ -374,109 +340,9 @@ libc_enum!{
         #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
         B4000000,
     }
+    impl TryFrom<libc::speed_t>
 }
 
-impl From<libc::speed_t> for BaudRate {
-    fn from(s: libc::speed_t) -> BaudRate {
-
-        use libc::{B0, B50, B75, B110, B134, B150, B200, B300, B600, B1200, B1800, B2400, B4800,
-                   B9600, B19200, B38400, B57600, B115200, B230400};
-        #[cfg(any(target_os = "android", target_os = "linux"))]
-        use libc::{B500000, B576000, B1000000, B1152000, B1500000, B2000000};
-        #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
-        use libc::{B2500000, B3000000, B3500000, B4000000};
-        #[cfg(any(target_os = "dragonfly",
-                  target_os = "freebsd",
-                  target_os = "macos",
-                  target_os = "netbsd",
-                  target_os = "openbsd"))]
-        use libc::{B7200, B14400, B28800, B76800};
-        #[cfg(any(target_os = "android",
-                  target_os = "freebsd",
-                  target_os = "linux",
-                  target_os = "netbsd"))]
-        use libc::{B460800, B921600};
-
-        match s {
-            B0 => BaudRate::B0,
-            B50 => BaudRate::B50,
-            B75 => BaudRate::B75,
-            B110 => BaudRate::B110,
-            B134 => BaudRate::B134,
-            B150 => BaudRate::B150,
-            B200 => BaudRate::B200,
-            B300 => BaudRate::B300,
-            B600 => BaudRate::B600,
-            B1200 => BaudRate::B1200,
-            B1800 => BaudRate::B1800,
-            B2400 => BaudRate::B2400,
-            B4800 => BaudRate::B4800,
-            #[cfg(any(target_os = "dragonfly",
-                      target_os = "freebsd",
-                      target_os = "macos",
-                      target_os = "netbsd",
-                      target_os = "openbsd"))]
-            B7200 => BaudRate::B7200,
-            B9600 => BaudRate::B9600,
-            #[cfg(any(target_os = "dragonfly",
-                      target_os = "freebsd",
-                      target_os = "macos",
-                      target_os = "netbsd",
-                      target_os = "openbsd"))]
-            B14400 => BaudRate::B14400,
-            B19200 => BaudRate::B19200,
-            #[cfg(any(target_os = "dragonfly",
-                      target_os = "freebsd",
-                      target_os = "macos",
-                      target_os = "netbsd",
-                      target_os = "openbsd"))]
-            B28800 => BaudRate::B28800,
-            B38400 => BaudRate::B38400,
-            B57600 => BaudRate::B57600,
-            #[cfg(any(target_os = "dragonfly",
-                      target_os = "freebsd",
-                      target_os = "macos",
-                      target_os = "netbsd",
-                      target_os = "openbsd"))]
-            B76800 => BaudRate::B76800,
-            B115200 => BaudRate::B115200,
-            B230400 => BaudRate::B230400,
-            #[cfg(any(target_os = "android",
-                      target_os = "freebsd",
-                      target_os = "linux",
-                      target_os = "netbsd"))]
-            B460800 => BaudRate::B460800,
-            #[cfg(any(target_os = "android", target_os = "linux"))]
-            B500000 => BaudRate::B500000,
-            #[cfg(any(target_os = "android", target_os = "linux"))]
-            B576000 => BaudRate::B576000,
-            #[cfg(any(target_os = "android",
-                      target_os = "freebsd",
-                      target_os = "linux",
-                      target_os = "netbsd"))]
-            B921600 => BaudRate::B921600,
-            #[cfg(any(target_os = "android", target_os = "linux"))]
-            B1000000 => BaudRate::B1000000,
-            #[cfg(any(target_os = "android", target_os = "linux"))]
-            B1152000 => BaudRate::B1152000,
-            #[cfg(any(target_os = "android", target_os = "linux"))]
-            B1500000 => BaudRate::B1500000,
-            #[cfg(any(target_os = "android", target_os = "linux"))]
-            B2000000 => BaudRate::B2000000,
-            #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
-            B2500000 => BaudRate::B2500000,
-            #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
-            B3000000 => BaudRate::B3000000,
-            #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
-            B3500000 => BaudRate::B3500000,
-            #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
-            B4000000 => BaudRate::B4000000,
-            b => unreachable!("Invalid baud constant: {}", b),
-        }
-    }
-}
-
-// TODO: Include `TryFrom<u32> for BaudRate` once that API stabilizes
 #[cfg(any(target_os = "freebsd",
           target_os = "dragonfly",
           target_os = "ios",
@@ -495,6 +361,7 @@ libc_enum! {
     ///
     /// Used as an argument to `tcsetattr()`
     #[repr(i32)]
+    #[non_exhaustive]
     pub enum SetArg {
         /// The change will occur immediately
         TCSANOW,
@@ -510,6 +377,7 @@ libc_enum! {
     ///
     /// Used as an argument to `tcflush()`.
     #[repr(i32)]
+    #[non_exhaustive]
     pub enum FlushArg {
         /// Flush data that was received but not read
         TCIFLUSH,
@@ -525,6 +393,7 @@ libc_enum! {
     ///
     /// Used as an argument to `tcflow()`.
     #[repr(i32)]
+    #[non_exhaustive]
     pub enum FlowArg {
         /// Suspend transmission
         TCOOFF,
@@ -541,41 +410,51 @@ libc_enum! {
 libc_enum! {
     /// Indices into the `termios.c_cc` array for special characters.
     #[repr(usize)]
+    #[non_exhaustive]
     pub enum SpecialCharacterIndices {
         VDISCARD,
         #[cfg(any(target_os = "dragonfly",
                 target_os = "freebsd",
+                target_os = "illumos",
                 target_os = "macos",
                 target_os = "netbsd",
-                target_os = "openbsd"))]
+                target_os = "openbsd",
+                target_os = "solaris"))]
         VDSUSP,
         VEOF,
         VEOL,
         VEOL2,
         VERASE,
-        #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+        #[cfg(any(target_os = "dragonfly",
+                  target_os = "freebsd",
+                  target_os = "illumos",
+                  target_os = "solaris"))]
         VERASE2,
         VINTR,
         VKILL,
         VLNEXT,
-        #[cfg(not(all(target_os = "linux", target_arch = "sparc64")))]
+        #[cfg(not(any(all(target_os = "linux", target_arch = "sparc64"),
+                target_os = "illumos", target_os = "solaris")))]
         VMIN,
         VQUIT,
         VREPRINT,
         VSTART,
         #[cfg(any(target_os = "dragonfly",
                 target_os = "freebsd",
+                target_os = "illumos",
                 target_os = "macos",
                 target_os = "netbsd",
-                target_os = "openbsd"))]
+                target_os = "openbsd",
+                target_os = "solaris"))]
         VSTATUS,
         VSTOP,
         VSUSP,
         #[cfg(target_os = "linux")]
         VSWTC,
-        #[cfg(target_os = "haiku")]
+        #[cfg(any(target_os = "haiku", target_os = "illumos", target_os = "solaris"))]
         VSWTCH,
-        #[cfg(not(all(target_os = "linux", target_arch = "sparc64")))]
+        #[cfg(not(any(all(target_os = "linux", target_arch = "sparc64"),
+                target_os = "illumos", target_os = "solaris")))]
         VTIME,
         VWERASE,
         #[cfg(target_os = "dragonfly")]
@@ -583,6 +462,13 @@ libc_enum! {
     }
 }
 
+#[cfg(any(all(target_os = "linux", target_arch = "sparc64"),
+        target_os = "illumos", target_os = "solaris"))]
+impl SpecialCharacterIndices {
+    pub const VMIN: SpecialCharacterIndices = SpecialCharacterIndices::VEOF;
+    pub const VTIME: SpecialCharacterIndices = SpecialCharacterIndices::VEOL;
+}
+
 pub use libc::NCCS;
 #[cfg(any(target_os = "dragonfly",
           target_os = "freebsd",
@@ -606,7 +492,9 @@ libc_bitflags! {
         ICRNL;
         IXON;
         IXOFF;
+        #[cfg(not(target_os = "redox"))]
         IXANY;
+        #[cfg(not(target_os = "redox"))]
         IMAXBEL;
         #[cfg(any(target_os = "android", target_os = "linux", target_os = "macos"))]
         IUTF8;
@@ -816,6 +704,7 @@ libc_bitflags! {
         PARODD;
         HUPCL;
         CLOCAL;
+        #[cfg(not(target_os = "redox"))]
         CRTSCTS;
         #[cfg(any(target_os = "android", target_os = "linux"))]
         CBAUD;
@@ -866,12 +755,15 @@ libc_bitflags! {
 libc_bitflags! {
     /// Flags for setting any local modes
     pub struct LocalFlags: tcflag_t {
+        #[cfg(not(target_os = "redox"))]
         ECHOKE;
         ECHOE;
         ECHOK;
         ECHO;
         ECHONL;
+        #[cfg(not(target_os = "redox"))]
         ECHOPRT;
+        #[cfg(not(target_os = "redox"))]
         ECHOCTL;
         ISIG;
         ICANON;
@@ -883,8 +775,10 @@ libc_bitflags! {
                   target_os = "openbsd"))]
         ALTWERASE;
         IEXTEN;
+        #[cfg(not(target_os = "redox"))]
         EXTPROC;
         TOSTOP;
+        #[cfg(not(target_os = "redox"))]
         FLUSHO;
         #[cfg(any(target_os = "freebsd",
                   target_os = "dragonfly",
@@ -893,6 +787,7 @@ libc_bitflags! {
                   target_os = "netbsd",
                   target_os = "openbsd"))]
         NOKERNINFO;
+        #[cfg(not(target_os = "redox"))]
         PENDIN;
         NOFLSH;
     }
@@ -906,7 +801,7 @@ cfg_if!{
                  target_os = "netbsd",
                  target_os = "openbsd"))] {
         /// Get input baud rate (see
-        /// [cfgetispeed(3p)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/cfgetispeed.html)).
+        /// [cfgetispeed(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/cfgetispeed.html)).
         ///
         /// `cfgetispeed()` extracts the input baud rate from the given `Termios` structure.
         pub fn cfgetispeed(termios: &Termios) -> u32 {
@@ -915,7 +810,7 @@ cfg_if!{
         }
 
         /// Get output baud rate (see
-        /// [cfgetospeed(3p)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/cfgetospeed.html)).
+        /// [cfgetospeed(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/cfgetospeed.html)).
         ///
         /// `cfgetospeed()` extracts the output baud rate from the given `Termios` structure.
         pub fn cfgetospeed(termios: &Termios) -> u32 {
@@ -924,7 +819,7 @@ cfg_if!{
         }
 
         /// Set input baud rate (see
-        /// [cfsetispeed(3p)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/cfsetispeed.html)).
+        /// [cfsetispeed(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/cfsetispeed.html)).
         ///
         /// `cfsetispeed()` sets the intput baud rate in the given `Termios` structure.
         pub fn cfsetispeed<T: Into<u32>>(termios: &mut Termios, baud: T) -> Result<()> {
@@ -935,7 +830,7 @@ cfg_if!{
         }
 
         /// Set output baud rate (see
-        /// [cfsetospeed(3p)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/cfsetospeed.html)).
+        /// [cfsetospeed(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/cfsetospeed.html)).
         ///
         /// `cfsetospeed()` sets the output baud rate in the given termios structure.
         pub fn cfsetospeed<T: Into<u32>>(termios: &mut Termios, baud: T) -> Result<()> {
@@ -957,26 +852,28 @@ cfg_if!{
             Errno::result(res).map(drop)
         }
     } else {
+        use std::convert::TryInto;
+
         /// Get input baud rate (see
-        /// [cfgetispeed(3p)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/cfgetispeed.html)).
+        /// [cfgetispeed(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/cfgetispeed.html)).
         ///
         /// `cfgetispeed()` extracts the input baud rate from the given `Termios` structure.
         pub fn cfgetispeed(termios: &Termios) -> BaudRate {
             let inner_termios = termios.get_libc_termios();
-            unsafe { libc::cfgetispeed(&*inner_termios) }.into()
+            unsafe { libc::cfgetispeed(&*inner_termios) }.try_into().unwrap()
         }
 
         /// Get output baud rate (see
-        /// [cfgetospeed(3p)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/cfgetospeed.html)).
+        /// [cfgetospeed(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/cfgetospeed.html)).
         ///
         /// `cfgetospeed()` extracts the output baud rate from the given `Termios` structure.
         pub fn cfgetospeed(termios: &Termios) -> BaudRate {
             let inner_termios = termios.get_libc_termios();
-            unsafe { libc::cfgetospeed(&*inner_termios) }.into()
+            unsafe { libc::cfgetospeed(&*inner_termios) }.try_into().unwrap()
         }
 
         /// Set input baud rate (see
-        /// [cfsetispeed(3p)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/cfsetispeed.html)).
+        /// [cfsetispeed(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/cfsetispeed.html)).
         ///
         /// `cfsetispeed()` sets the intput baud rate in the given `Termios` structure.
         pub fn cfsetispeed(termios: &mut Termios, baud: BaudRate) -> Result<()> {
@@ -987,7 +884,7 @@ cfg_if!{
         }
 
         /// Set output baud rate (see
-        /// [cfsetospeed(3p)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/cfsetospeed.html)).
+        /// [cfsetospeed(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/cfsetospeed.html)).
         ///
         /// `cfsetospeed()` sets the output baud rate in the given `Termios` structure.
         pub fn cfsetospeed(termios: &mut Termios, baud: BaudRate) -> Result<()> {
@@ -1012,7 +909,7 @@ cfg_if!{
 }
 
 /// Configures the port to something like the "raw" mode of the old Version 7 terminal driver (see
-/// [termios(3)](http://man7.org/linux/man-pages/man3/termios.3.html)).
+/// [termios(3)](https://man7.org/linux/man-pages/man3/termios.3.html)).
 ///
 /// `cfmakeraw()` configures the termios structure such that input is available character-by-
 /// character, echoing is disabled, and all special input and output processing is disabled. Note
@@ -1039,23 +936,23 @@ pub fn cfmakesane(termios: &mut Termios) {
 }
 
 /// Return the configuration of a port
-/// [tcgetattr(3p)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/tcgetattr.html)).
+/// [tcgetattr(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tcgetattr.html)).
 ///
 /// `tcgetattr()` returns a `Termios` structure with the current configuration for a port. Modifying
 /// this structure *will not* reconfigure the port, instead the modifications should be done to
 /// the `Termios` structure and then the port should be reconfigured using `tcsetattr()`.
 pub fn tcgetattr(fd: RawFd) -> Result<Termios> {
-    let mut termios: libc::termios = unsafe { mem::uninitialized() };
+    let mut termios = mem::MaybeUninit::uninit();
 
-    let res = unsafe { libc::tcgetattr(fd, &mut termios) };
+    let res = unsafe { libc::tcgetattr(fd, termios.as_mut_ptr()) };
 
     Errno::result(res)?;
 
-    Ok(termios.into())
+    unsafe { Ok(termios.assume_init().into()) }
 }
 
 /// Set the configuration for a terminal (see
-/// [tcsetattr(3p)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/tcsetattr.html)).
+/// [tcsetattr(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tcsetattr.html)).
 ///
 /// `tcsetattr()` reconfigures the given port based on a given `Termios` structure. This change
 /// takes affect at a time specified by `actions`. Note that this function may return success if
@@ -1066,13 +963,13 @@ pub fn tcsetattr(fd: RawFd, actions: SetArg, termios: &Termios) -> Result<()> {
 }
 
 /// Block until all output data is written (see
-/// [tcdrain(3p)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/tcdrain.html)).
+/// [tcdrain(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tcdrain.html)).
 pub fn tcdrain(fd: RawFd) -> Result<()> {
     Errno::result(unsafe { libc::tcdrain(fd) }).map(drop)
 }
 
 /// Suspend or resume the transmission or reception of data (see
-/// [tcflow(3p)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/tcflow.html)).
+/// [tcflow(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tcflow.html)).
 ///
 /// `tcflow()` suspends of resumes the transmission or reception of data for the given port
 /// depending on the value of `action`.
@@ -1081,7 +978,7 @@ pub fn tcflow(fd: RawFd, action: FlowArg) -> Result<()> {
 }
 
 /// Discard data in the output or input queue (see
-/// [tcflush(3p)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/tcflush.html)).
+/// [tcflush(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tcflush.html)).
 ///
 /// `tcflush()` will discard data for a terminal port in the input queue, output queue, or both
 /// depending on the value of `action`.
@@ -1090,7 +987,7 @@ pub fn tcflush(fd: RawFd, action: FlushArg) -> Result<()> {
 }
 
 /// Send a break for a specific duration (see
-/// [tcsendbreak(3p)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/tcsendbreak.html)).
+/// [tcsendbreak(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tcsendbreak.html)).
 ///
 /// When using asynchronous data transmission `tcsendbreak()` will transmit a continuous stream
 /// of zero-valued bits for an implementation-defined duration.
@@ -1099,9 +996,21 @@ pub fn tcsendbreak(fd: RawFd, duration: c_int) -> Result<()> {
 }
 
 /// Get the session controlled by the given terminal (see
-/// [tcgetsid(3)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/tcgetsid.html)).
+/// [tcgetsid(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tcgetsid.html)).
 pub fn tcgetsid(fd: RawFd) -> Result<Pid> {
     let res = unsafe { libc::tcgetsid(fd) };
 
     Errno::result(res).map(Pid::from_raw)
 }
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use std::convert::TryFrom;
+
+    #[test]
+    fn try_from() {
+        assert_eq!(Ok(BaudRate::B0), BaudRate::try_from(libc::B0));
+        assert!(BaudRate::try_from(999999999).is_err());
+    }
+}
diff --git a/third_party/rust/nix/src/sys/time.rs b/third_party/rust/nix/src/sys/time.rs
index 3ad57543b18a7..ac4247180ddbe 100644
--- a/third_party/rust/nix/src/sys/time.rs
+++ b/third_party/rust/nix/src/sys/time.rs
@@ -1,6 +1,8 @@
 use std::{cmp, fmt, ops};
+use std::time::Duration;
 use std::convert::From;
-use libc::{c_long, timespec, timeval};
+use libc::{timespec, timeval};
+#[cfg_attr(target_env = "musl", allow(deprecated))] // https://github.com/rust-lang/libc/issues/1848
 pub use libc::{time_t, suseconds_t};
 
 pub trait TimeValLike: Sized {
@@ -60,6 +62,30 @@ const TS_MAX_SECONDS: i64 = ::std::isize::MAX as i64;
 
 const TS_MIN_SECONDS: i64 = -TS_MAX_SECONDS;
 
+// x32 compatibility
+// See https://sourceware.org/bugzilla/show_bug.cgi?id=16437
+#[cfg(all(target_arch = "x86_64", target_pointer_width = "32"))]
+type timespec_tv_nsec_t = i64;
+#[cfg(not(all(target_arch = "x86_64", target_pointer_width = "32")))]
+type timespec_tv_nsec_t = libc::c_long;
+
+impl From<timespec> for TimeSpec {
+    fn from(ts: timespec) -> Self {
+        Self(ts)
+    }
+}
+
+impl From<Duration> for TimeSpec {
+    fn from(duration: Duration) -> Self {
+        Self::from_duration(duration)
+    }
+}
+
+impl From<TimeSpec> for Duration {
+    fn from(timespec: TimeSpec) -> Self {
+        Duration::new(timespec.0.tv_sec as u64, timespec.0.tv_nsec as u32)
+    }
+}
 
 impl AsRef<timespec> for TimeSpec {
     fn as_ref(&self) -> &timespec {
@@ -67,6 +93,12 @@ impl AsRef<timespec> for TimeSpec {
     }
 }
 
+impl AsMut<timespec> for TimeSpec {
+    fn as_mut(&mut self) -> &mut timespec {
+        &mut self.0
+    }
+}
+
 impl Ord for TimeSpec {
     // The implementation of cmp is simplified by assuming that the struct is
     // normalized.  That is, tv_nsec must always be within [0, 1_000_000_000)
@@ -90,6 +122,7 @@ impl TimeValLike for TimeSpec {
     fn seconds(seconds: i64) -> TimeSpec {
         assert!(seconds >= TS_MIN_SECONDS && seconds <= TS_MAX_SECONDS,
                 "TimeSpec out of bounds; seconds={}", seconds);
+        #[cfg_attr(target_env = "musl", allow(deprecated))] // https://github.com/rust-lang/libc/issues/1848
         TimeSpec(timespec {tv_sec: seconds as time_t, tv_nsec: 0 })
     }
 
@@ -116,8 +149,9 @@ impl TimeValLike for TimeSpec {
         let (secs, nanos) = div_mod_floor_64(nanoseconds, NANOS_PER_SEC);
         assert!(secs >= TS_MIN_SECONDS && secs <= TS_MAX_SECONDS,
                 "TimeSpec out of bounds");
+        #[cfg_attr(target_env = "musl", allow(deprecated))] // https://github.com/rust-lang/libc/issues/1848
         TimeSpec(timespec {tv_sec: secs as time_t,
-                           tv_nsec: nanos as c_long })
+                           tv_nsec: nanos as timespec_tv_nsec_t })
     }
 
     fn num_seconds(&self) -> i64 {
@@ -144,21 +178,34 @@ impl TimeValLike for TimeSpec {
 }
 
 impl TimeSpec {
-    fn nanos_mod_sec(&self) -> c_long {
+    fn nanos_mod_sec(&self) -> timespec_tv_nsec_t {
         if self.tv_sec() < 0 && self.tv_nsec() > 0 {
-            self.tv_nsec() - NANOS_PER_SEC as c_long
+            self.tv_nsec() - NANOS_PER_SEC as timespec_tv_nsec_t
         } else {
             self.tv_nsec()
         }
     }
 
-    pub fn tv_sec(&self) -> time_t {
+    #[cfg_attr(target_env = "musl", allow(deprecated))] // https://github.com/rust-lang/libc/issues/1848
+    pub const fn tv_sec(&self) -> time_t {
         self.0.tv_sec
     }
 
-    pub fn tv_nsec(&self) -> c_long {
+    pub const fn tv_nsec(&self) -> timespec_tv_nsec_t {
         self.0.tv_nsec
     }
+
+    pub const fn from_duration(duration: Duration) -> Self {
+        #[cfg_attr(target_env = "musl", allow(deprecated))] // https://github.com/rust-lang/libc/issues/1848
+        TimeSpec(timespec {
+            tv_sec: duration.as_secs() as time_t,
+            tv_nsec: duration.subsec_nanos() as timespec_tv_nsec_t
+        })
+    }
+
+    pub const fn from_timespec(timespec: timespec) -> Self {
+        Self(timespec)
+    }
 }
 
 impl ops::Neg for TimeSpec {
@@ -191,7 +238,7 @@ impl ops::Mul<i32> for TimeSpec {
     type Output = TimeSpec;
 
     fn mul(self, rhs: i32) -> TimeSpec {
-        let usec = self.num_nanoseconds().checked_mul(rhs as i64)
+        let usec = self.num_nanoseconds().checked_mul(i64::from(rhs))
             .expect("TimeSpec multiply out of bounds");
 
         TimeSpec::nanoseconds(usec)
@@ -202,7 +249,7 @@ impl ops::Div<i32> for TimeSpec {
     type Output = TimeSpec;
 
     fn div(self, rhs: i32) -> TimeSpec {
-        let usec = self.num_nanoseconds() / rhs as i64;
+        let usec = self.num_nanoseconds() / i64::from(rhs);
         TimeSpec::nanoseconds(usec)
     }
 }
@@ -239,7 +286,7 @@ impl fmt::Display for TimeSpec {
 
 
 
-#[repr(C)]
+#[repr(transparent)]
 #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
 pub struct TimeVal(timeval);
 
@@ -259,6 +306,12 @@ impl AsRef<timeval> for TimeVal {
     }
 }
 
+impl AsMut<timeval> for TimeVal {
+    fn as_mut(&mut self) -> &mut timeval {
+        &mut self.0
+    }
+}
+
 impl Ord for TimeVal {
     // The implementation of cmp is simplified by assuming that the struct is
     // normalized.  That is, tv_usec must always be within [0, 1_000_000)
@@ -282,6 +335,7 @@ impl TimeValLike for TimeVal {
     fn seconds(seconds: i64) -> TimeVal {
         assert!(seconds >= TV_MIN_SECONDS && seconds <= TV_MAX_SECONDS,
                 "TimeVal out of bounds; seconds={}", seconds);
+        #[cfg_attr(target_env = "musl", allow(deprecated))] // https://github.com/rust-lang/libc/issues/1848
         TimeVal(timeval {tv_sec: seconds as time_t, tv_usec: 0 })
     }
 
@@ -299,6 +353,7 @@ impl TimeValLike for TimeVal {
         let (secs, micros) = div_mod_floor_64(microseconds, MICROS_PER_SEC);
         assert!(secs >= TV_MIN_SECONDS && secs <= TV_MAX_SECONDS,
                 "TimeVal out of bounds");
+        #[cfg_attr(target_env = "musl", allow(deprecated))] // https://github.com/rust-lang/libc/issues/1848
         TimeVal(timeval {tv_sec: secs as time_t,
                            tv_usec: micros as suseconds_t })
     }
@@ -311,6 +366,7 @@ impl TimeValLike for TimeVal {
         let (secs, micros) = div_mod_floor_64(microseconds, MICROS_PER_SEC);
         assert!(secs >= TV_MIN_SECONDS && secs <= TV_MAX_SECONDS,
                 "TimeVal out of bounds");
+        #[cfg_attr(target_env = "musl", allow(deprecated))] // https://github.com/rust-lang/libc/issues/1848
         TimeVal(timeval {tv_sec: secs as time_t,
                            tv_usec: micros as suseconds_t })
     }
@@ -347,11 +403,12 @@ impl TimeVal {
         }
     }
 
-    pub fn tv_sec(&self) -> time_t {
+    #[cfg_attr(target_env = "musl", allow(deprecated))] // https://github.com/rust-lang/libc/issues/1848
+    pub const fn tv_sec(&self) -> time_t {
         self.0.tv_sec
     }
 
-    pub fn tv_usec(&self) -> suseconds_t {
+    pub const fn tv_usec(&self) -> suseconds_t {
         self.0.tv_usec
     }
 }
@@ -386,7 +443,7 @@ impl ops::Mul<i32> for TimeVal {
     type Output = TimeVal;
 
     fn mul(self, rhs: i32) -> TimeVal {
-        let usec = self.num_microseconds().checked_mul(rhs as i64)
+        let usec = self.num_microseconds().checked_mul(i64::from(rhs))
             .expect("TimeVal multiply out of bounds");
 
         TimeVal::microseconds(usec)
@@ -397,7 +454,7 @@ impl ops::Div<i32> for TimeVal {
     type Output = TimeVal;
 
     fn div(self, rhs: i32) -> TimeVal {
-        let usec = self.num_microseconds() / rhs as i64;
+        let usec = self.num_microseconds() / i64::from(rhs);
         TimeVal::microseconds(usec)
     }
 }
@@ -467,6 +524,7 @@ fn div_rem_64(this: i64, other: i64) -> (i64, i64) {
 #[cfg(test)]
 mod test {
     use super::{TimeSpec, TimeVal, TimeValLike};
+    use std::time::Duration;
 
     #[test]
     pub fn test_timespec() {
@@ -477,6 +535,15 @@ mod test {
                    TimeSpec::seconds(182));
     }
 
+    #[test]
+    pub fn test_timespec_from() {
+        let duration = Duration::new(123, 123_456_789);
+        let timespec = TimeSpec::nanoseconds(123_123_456_789);
+
+        assert_eq!(TimeSpec::from(duration), timespec);
+        assert_eq!(Duration::from(timespec), duration);
+    }
+
     #[test]
     pub fn test_timespec_neg() {
         let a = TimeSpec::seconds(1) + TimeSpec::nanoseconds(123);
diff --git a/third_party/rust/nix/src/sys/timerfd.rs b/third_party/rust/nix/src/sys/timerfd.rs
new file mode 100644
index 0000000000000..705a3c4d651c7
--- /dev/null
+++ b/third_party/rust/nix/src/sys/timerfd.rs
@@ -0,0 +1,281 @@
+//! Timer API via file descriptors.
+//!
+//! Timer FD is a Linux-only API to create timers and get expiration
+//! notifications through file descriptors.
+//!
+//! For more documentation, please read [timerfd_create(2)](https://man7.org/linux/man-pages/man2/timerfd_create.2.html).
+//!
+//! # Examples
+//!
+//! Create a new one-shot timer that expires after 1 second.
+//! ```
+//! # use std::os::unix::io::AsRawFd;
+//! # use nix::sys::timerfd::{TimerFd, ClockId, TimerFlags, TimerSetTimeFlags,
+//! #    Expiration};
+//! # use nix::sys::time::{TimeSpec, TimeValLike};
+//! # use nix::unistd::read;
+//! #
+//! // We create a new monotonic timer.
+//! let timer = TimerFd::new(ClockId::CLOCK_MONOTONIC, TimerFlags::empty())
+//!     .unwrap();
+//!
+//! // We set a new one-shot timer in 1 seconds.
+//! timer.set(
+//!     Expiration::OneShot(TimeSpec::seconds(1)),
+//!     TimerSetTimeFlags::empty()
+//! ).unwrap();
+//!
+//! // We wait for the timer to expire.
+//! timer.wait().unwrap();
+//! ```
+use crate::sys::time::TimeSpec;
+use crate::unistd::read;
+use crate::{errno::Errno, Result};
+use bitflags::bitflags;
+use libc::c_int;
+use std::os::unix::io::{AsRawFd, FromRawFd, RawFd};
+
+/// A timerfd instance. This is also a file descriptor, you can feed it to
+/// other interfaces consuming file descriptors, epoll for example.
+#[derive(Debug)]
+pub struct TimerFd {
+    fd: RawFd,
+}
+
+impl AsRawFd for TimerFd {
+    fn as_raw_fd(&self) -> RawFd {
+        self.fd
+    }
+}
+
+impl FromRawFd for TimerFd {
+    unsafe fn from_raw_fd(fd: RawFd) -> Self {
+        TimerFd { fd }
+    }
+}
+
+libc_enum! {
+    /// The type of the clock used to mark the progress of the timer. For more
+    /// details on each kind of clock, please refer to [timerfd_create(2)](https://man7.org/linux/man-pages/man2/timerfd_create.2.html).
+    #[repr(i32)]
+    #[non_exhaustive]
+    pub enum ClockId {
+        CLOCK_REALTIME,
+        CLOCK_MONOTONIC,
+        CLOCK_BOOTTIME,
+        CLOCK_REALTIME_ALARM,
+        CLOCK_BOOTTIME_ALARM,
+    }
+}
+
+libc_bitflags! {
+    /// Additional flags to change the behaviour of the file descriptor at the
+    /// time of creation.
+    pub struct TimerFlags: c_int {
+        TFD_NONBLOCK;
+        TFD_CLOEXEC;
+    }
+}
+
+bitflags! {
+    /// Flags that are used for arming the timer.
+    pub struct TimerSetTimeFlags: libc::c_int {
+        const TFD_TIMER_ABSTIME = libc::TFD_TIMER_ABSTIME;
+    }
+}
+
+#[derive(Debug, Clone, Copy)]
+struct TimerSpec(libc::itimerspec);
+
+impl TimerSpec {
+    pub const fn none() -> Self {
+        Self(libc::itimerspec {
+            it_interval: libc::timespec {
+                tv_sec: 0,
+                tv_nsec: 0,
+            },
+            it_value: libc::timespec {
+                tv_sec: 0,
+                tv_nsec: 0,
+            },
+        })
+    }
+}
+
+impl AsRef<libc::itimerspec> for TimerSpec {
+    fn as_ref(&self) -> &libc::itimerspec {
+        &self.0
+    }
+}
+
+impl From<Expiration> for TimerSpec {
+    fn from(expiration: Expiration) -> TimerSpec {
+        match expiration {
+            Expiration::OneShot(t) => TimerSpec(libc::itimerspec {
+                it_interval: libc::timespec {
+                    tv_sec: 0,
+                    tv_nsec: 0,
+                },
+                it_value: *t.as_ref(),
+            }),
+            Expiration::IntervalDelayed(start, interval) => TimerSpec(libc::itimerspec {
+                it_interval: *interval.as_ref(),
+                it_value: *start.as_ref(),
+            }),
+            Expiration::Interval(t) => TimerSpec(libc::itimerspec {
+                it_interval: *t.as_ref(),
+                it_value: *t.as_ref(),
+            }),
+        }
+    }
+}
+
+impl From<TimerSpec> for Expiration {
+    fn from(timerspec: TimerSpec) -> Expiration {
+        match timerspec {
+            TimerSpec(libc::itimerspec {
+                it_interval:
+                    libc::timespec {
+                        tv_sec: 0,
+                        tv_nsec: 0,
+                    },
+                it_value: ts,
+            }) => Expiration::OneShot(ts.into()),
+            TimerSpec(libc::itimerspec {
+                it_interval: int_ts,
+                it_value: val_ts,
+            }) => {
+                if (int_ts.tv_sec == val_ts.tv_sec) && (int_ts.tv_nsec == val_ts.tv_nsec) {
+                    Expiration::Interval(int_ts.into())
+                } else {
+                    Expiration::IntervalDelayed(val_ts.into(), int_ts.into())
+                }
+            }
+        }
+    }
+}
+
+/// An enumeration allowing the definition of the expiration time of an alarm,
+/// recurring or not.
+#[derive(Debug, Clone, Copy, PartialEq)]
+pub enum Expiration {
+    OneShot(TimeSpec),
+    IntervalDelayed(TimeSpec, TimeSpec),
+    Interval(TimeSpec),
+}
+
+impl TimerFd {
+    /// Creates a new timer based on the clock defined by `clockid`. The
+    /// underlying fd can be assigned specific flags with `flags` (CLOEXEC,
+    /// NONBLOCK). The underlying fd will be closed on drop.
+    pub fn new(clockid: ClockId, flags: TimerFlags) -> Result<Self> {
+        Errno::result(unsafe { libc::timerfd_create(clockid as i32, flags.bits()) })
+            .map(|fd| Self { fd })
+    }
+
+    /// Sets a new alarm on the timer.
+    ///
+    /// # Types of alarm
+    ///
+    /// There are 3 types of alarms you can set:
+    ///
+    ///   - one shot: the alarm will trigger once after the specified amount of
+    /// time.
+    ///     Example: I want an alarm to go off in 60s and then disables itself.
+    ///
+    ///   - interval: the alarm will trigger every specified interval of time.
+    ///     Example: I want an alarm to go off every 60s. The alarm will first
+    ///     go off 60s after I set it and every 60s after that. The alarm will
+    ///     not disable itself.
+    ///
+    ///   - interval delayed: the alarm will trigger after a certain amount of
+    ///     time and then trigger at a specified interval.
+    ///     Example: I want an alarm to go off every 60s but only start in 1h.
+    ///     The alarm will first trigger 1h after I set it and then every 60s
+    ///     after that. The alarm will not disable itself.
+    ///
+    /// # Relative vs absolute alarm
+    ///
+    /// If you do not set any `TimerSetTimeFlags`, then the `TimeSpec` you pass
+    /// to the `Expiration` you want is relative. If however you want an alarm
+    /// to go off at a certain point in time, you can set `TFD_TIMER_ABSTIME`.
+    /// Then the one shot TimeSpec and the delay TimeSpec of the delayed
+    /// interval are going to be interpreted as absolute.
+    ///
+    /// # Disabling alarms
+    ///
+    /// Note: Only one alarm can be set for any given timer. Setting a new alarm
+    /// actually removes the previous one.
+    ///
+    /// Note: Setting a one shot alarm with a 0s TimeSpec disables the alarm
+    /// altogether.
+    pub fn set(&self, expiration: Expiration, flags: TimerSetTimeFlags) -> Result<()> {
+        let timerspec: TimerSpec = expiration.into();
+        Errno::result(unsafe {
+            libc::timerfd_settime(
+                self.fd,
+                flags.bits(),
+                timerspec.as_ref(),
+                std::ptr::null_mut(),
+            )
+        })
+        .map(drop)
+    }
+
+    /// Get the parameters for the alarm currently set, if any.
+    pub fn get(&self) -> Result<Option<Expiration>> {
+        let mut timerspec = TimerSpec::none();
+        let timerspec_ptr: *mut libc::itimerspec = &mut timerspec.0;
+
+        Errno::result(unsafe { libc::timerfd_gettime(self.fd, timerspec_ptr) }).map(|_| {
+            if timerspec.0.it_interval.tv_sec == 0
+                && timerspec.0.it_interval.tv_nsec == 0
+                && timerspec.0.it_value.tv_sec == 0
+                && timerspec.0.it_value.tv_nsec == 0
+            {
+                None
+            } else {
+                Some(timerspec.into())
+            }
+        })
+    }
+
+    /// Remove the alarm if any is set.
+    pub fn unset(&self) -> Result<()> {
+        Errno::result(unsafe {
+            libc::timerfd_settime(
+                self.fd,
+                TimerSetTimeFlags::empty().bits(),
+                TimerSpec::none().as_ref(),
+                std::ptr::null_mut(),
+            )
+        })
+        .map(drop)
+    }
+
+    /// Wait for the configured alarm to expire.
+    ///
+    /// Note: If the alarm is unset, then you will wait forever.
+    pub fn wait(&self) -> Result<()> {
+        while let Err(e) = read(self.fd, &mut [0u8; 8]) {
+            if e != Errno::EINTR {
+                return Err(e)
+            }
+        }
+
+        Ok(())
+    }
+}
+
+impl Drop for TimerFd {
+    fn drop(&mut self) {
+        if !std::thread::panicking() {
+            let result = Errno::result(unsafe {
+                libc::close(self.fd)
+            });
+            if let Err(Errno::EBADF) = result {
+                panic!("close of TimerFd encountered EBADF");
+            }
+        }
+    }
+}
diff --git a/third_party/rust/nix/src/sys/uio.rs b/third_party/rust/nix/src/sys/uio.rs
index d089084eed711..3abcde24fe8e0 100644
--- a/third_party/rust/nix/src/sys/uio.rs
+++ b/third_party/rust/nix/src/sys/uio.rs
@@ -1,18 +1,23 @@
-// Silence invalid warnings due to rust-lang/rust#16719
-#![allow(improper_ctypes)]
+//! Vectored I/O
 
-use Result;
-use errno::Errno;
+use crate::Result;
+use crate::errno::Errno;
 use libc::{self, c_int, c_void, size_t, off_t};
 use std::marker::PhantomData;
 use std::os::unix::io::RawFd;
 
+/// Low-level vectored write to a raw file descriptor
+///
+/// See also [writev(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/writev.html)
 pub fn writev(fd: RawFd, iov: &[IoVec<&[u8]>]) -> Result<usize> {
     let res = unsafe { libc::writev(fd, iov.as_ptr() as *const libc::iovec, iov.len() as c_int) };
 
     Errno::result(res).map(|r| r as usize)
 }
 
+/// Low-level vectored read from a raw file descriptor
+///
+/// See also [readv(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/readv.html)
 pub fn readv(fd: RawFd, iov: &mut [IoVec<&mut [u8]>]) -> Result<usize> {
     let res = unsafe { libc::readv(fd, iov.as_ptr() as *const libc::iovec, iov.len() as c_int) };
 
@@ -25,11 +30,7 @@ pub fn readv(fd: RawFd, iov: &mut [IoVec<&mut [u8]>]) -> Result<usize> {
 /// or an error occurs. The file offset is not changed.
 ///
 /// See also: [`writev`](fn.writev.html) and [`pwrite`](fn.pwrite.html)
-#[cfg(any(target_os = "dragonfly",
-          target_os = "freebsd",
-          target_os = "linux",
-          target_os = "netbsd",
-          target_os = "openbsd"))]
+#[cfg(not(target_os = "redox"))]
 pub fn pwritev(fd: RawFd, iov: &[IoVec<&[u8]>],
                offset: off_t) -> Result<usize> {
     let res = unsafe {
@@ -46,11 +47,7 @@ pub fn pwritev(fd: RawFd, iov: &[IoVec<&[u8]>],
 /// changed.
 ///
 /// See also: [`readv`](fn.readv.html) and [`pread`](fn.pread.html)
-#[cfg(any(target_os = "dragonfly",
-          target_os = "freebsd",
-          target_os = "linux",
-          target_os = "netbsd",
-          target_os = "openbsd"))]
+#[cfg(not(target_os = "redox"))]
 pub fn preadv(fd: RawFd, iov: &[IoVec<&mut [u8]>],
               offset: off_t) -> Result<usize> {
     let res = unsafe {
@@ -60,6 +57,10 @@ pub fn preadv(fd: RawFd, iov: &[IoVec<&mut [u8]>],
     Errno::result(res).map(|r| r as usize)
 }
 
+/// Low-level write to a file, with specified offset.
+///
+/// See also [pwrite(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pwrite.html)
+// TODO: move to unistd
 pub fn pwrite(fd: RawFd, buf: &[u8], offset: off_t) -> Result<usize> {
     let res = unsafe {
         libc::pwrite(fd, buf.as_ptr() as *const c_void, buf.len() as size_t,
@@ -69,6 +70,10 @@ pub fn pwrite(fd: RawFd, buf: &[u8], offset: off_t) -> Result<usize> {
     Errno::result(res).map(|r| r as usize)
 }
 
+/// Low-level write to a file, with specified offset.
+///
+/// See also [pread(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pread.html)
+// TODO: move to unistd
 pub fn pread(fd: RawFd, buf: &mut [u8], offset: off_t) -> Result<usize>{
     let res = unsafe {
         libc::pread(fd, buf.as_mut_ptr() as *mut c_void, buf.len() as size_t,
@@ -112,12 +117,16 @@ pub struct RemoteIoVec {
 ///
 /// This function is only available on Linux.
 ///
-/// [`process_vm_writev`(2)]: http://man7.org/linux/man-pages/man2/process_vm_writev.2.html
+/// [`process_vm_writev`(2)]: https://man7.org/linux/man-pages/man2/process_vm_writev.2.html
 /// [ptrace]: ../ptrace/index.html
 /// [`IoVec`]: struct.IoVec.html
 /// [`RemoteIoVec`]: struct.RemoteIoVec.html
 #[cfg(target_os = "linux")]
-pub fn process_vm_writev(pid: ::unistd::Pid, local_iov: &[IoVec<&[u8]>], remote_iov: &[RemoteIoVec]) -> Result<usize> {
+pub fn process_vm_writev(
+    pid: crate::unistd::Pid,
+    local_iov: &[IoVec<&[u8]>],
+    remote_iov: &[RemoteIoVec]) -> Result<usize>
+{
     let res = unsafe {
         libc::process_vm_writev(pid.into(),
                                 local_iov.as_ptr() as *const libc::iovec, local_iov.len() as libc::c_ulong,
@@ -143,12 +152,16 @@ pub fn process_vm_writev(pid: ::unistd::Pid, local_iov: &[IoVec<&[u8]>], remote_
 ///
 /// This function is only available on Linux.
 ///
-/// [`process_vm_readv`(2)]: http://man7.org/linux/man-pages/man2/process_vm_readv.2.html
+/// [`process_vm_readv`(2)]: https://man7.org/linux/man-pages/man2/process_vm_readv.2.html
 /// [`ptrace`]: ../ptrace/index.html
 /// [`IoVec`]: struct.IoVec.html
 /// [`RemoteIoVec`]: struct.RemoteIoVec.html
 #[cfg(any(target_os = "linux"))]
-pub fn process_vm_readv(pid: ::unistd::Pid, local_iov: &[IoVec<&mut [u8]>], remote_iov: &[RemoteIoVec]) -> Result<usize> {
+pub fn process_vm_readv(
+    pid: crate::unistd::Pid,
+    local_iov: &[IoVec<&mut [u8]>],
+    remote_iov: &[RemoteIoVec]) -> Result<usize>
+{
     let res = unsafe {
         libc::process_vm_readv(pid.into(),
                                local_iov.as_ptr() as *const libc::iovec, local_iov.len() as libc::c_ulong,
@@ -158,11 +171,17 @@ pub fn process_vm_readv(pid: ::unistd::Pid, local_iov: &[IoVec<&mut [u8]>], remo
     Errno::result(res).map(|r| r as usize)
 }
 
-#[repr(C)]
+/// A vector of buffers.
+///
+/// Vectored I/O methods like [`writev`] and [`readv`] use this structure for
+/// both reading and writing.  Each `IoVec` specifies the base address and
+/// length of an area in memory.
+#[repr(transparent)]
 #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
-pub struct IoVec<T>(libc::iovec, PhantomData<T>);
+pub struct IoVec<T>(pub(crate) libc::iovec, PhantomData<T>);
 
 impl<T> IoVec<T> {
+    /// View the `IoVec` as a Rust slice.
     #[inline]
     pub fn as_slice(&self) -> &[u8] {
         use std::slice;
@@ -176,6 +195,15 @@ impl<T> IoVec<T> {
 }
 
 impl<'a> IoVec<&'a [u8]> {
+    #[cfg(target_os = "freebsd")]
+    pub(crate) fn from_raw_parts(base: *mut c_void, len: usize) -> Self {
+        IoVec(libc::iovec {
+            iov_base: base,
+            iov_len: len
+        }, PhantomData)
+    }
+
+    /// Create an `IoVec` from a Rust slice.
     pub fn from_slice(buf: &'a [u8]) -> IoVec<&'a [u8]> {
         IoVec(libc::iovec {
             iov_base: buf.as_ptr() as *mut c_void,
@@ -185,6 +213,7 @@ impl<'a> IoVec<&'a [u8]> {
 }
 
 impl<'a> IoVec<&'a mut [u8]> {
+    /// Create an `IoVec` from a mutable Rust slice.
     pub fn from_mut_slice(buf: &'a mut [u8]) -> IoVec<&'a mut [u8]> {
         IoVec(libc::iovec {
             iov_base: buf.as_ptr() as *mut c_void,
diff --git a/third_party/rust/nix/src/sys/utsname.rs b/third_party/rust/nix/src/sys/utsname.rs
index ab09c7d23232a..98edee0428fdd 100644
--- a/third_party/rust/nix/src/sys/utsname.rs
+++ b/third_party/rust/nix/src/sys/utsname.rs
@@ -1,39 +1,47 @@
+//! Get system identification
 use std::mem;
 use libc::{self, c_char};
 use std::ffi::CStr;
 use std::str::from_utf8_unchecked;
 
-#[repr(C)]
+/// Describes the running system.  Return type of [`uname`].
 #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+#[repr(transparent)]
 pub struct UtsName(libc::utsname);
 
 impl UtsName {
+    /// Name of the operating system implementation
     pub fn sysname(&self) -> &str {
         to_str(&(&self.0.sysname as *const c_char ) as *const *const c_char)
     }
 
+    /// Network name of this machine.
     pub fn nodename(&self) -> &str {
         to_str(&(&self.0.nodename as *const c_char ) as *const *const c_char)
     }
 
+    /// Release level of the operating system.
     pub fn release(&self) -> &str {
         to_str(&(&self.0.release as *const c_char ) as *const *const c_char)
     }
 
+    /// Version level of the operating system.
     pub fn version(&self) -> &str {
         to_str(&(&self.0.version as *const c_char ) as *const *const c_char)
     }
 
+    /// Machine hardware platform.
     pub fn machine(&self) -> &str {
         to_str(&(&self.0.machine as *const c_char ) as *const *const c_char)
     }
 }
 
+/// Get system identification
 pub fn uname() -> UtsName {
     unsafe {
-        let mut ret: UtsName = mem::uninitialized();
-        libc::uname(&mut ret.0);
-        ret
+        let mut ret = mem::MaybeUninit::uninit();
+        libc::uname(ret.as_mut_ptr());
+        UtsName(ret.assume_init())
     }
 }
 
diff --git a/third_party/rust/nix/src/sys/wait.rs b/third_party/rust/nix/src/sys/wait.rs
index c54f7ec579667..ee49e37decfa8 100644
--- a/third_party/rust/nix/src/sys/wait.rs
+++ b/third_party/rust/nix/src/sys/wait.rs
@@ -1,28 +1,44 @@
+//! Wait for a process to change status
+use crate::errno::Errno;
+use crate::sys::signal::Signal;
+use crate::unistd::Pid;
+use crate::Result;
+use cfg_if::cfg_if;
 use libc::{self, c_int};
-use Result;
-use errno::Errno;
-use unistd::Pid;
-
-use sys::signal::Signal;
+use std::convert::TryFrom;
 
 libc_bitflags!(
+    /// Controls the behavior of [`waitpid`].
     pub struct WaitPidFlag: c_int {
+        /// Do not block when there are no processes wishing to report status.
         WNOHANG;
+        /// Report the status of selected processes which are stopped due to a
+        /// [`SIGTTIN`](crate::sys::signal::Signal::SIGTTIN),
+        /// [`SIGTTOU`](crate::sys::signal::Signal::SIGTTOU),
+        /// [`SIGTSTP`](crate::sys::signal::Signal::SIGTSTP), or
+        /// [`SIGSTOP`](crate::sys::signal::Signal::SIGSTOP) signal.
         WUNTRACED;
+        /// Report the status of selected processes which have terminated.
         #[cfg(any(target_os = "android",
                   target_os = "freebsd",
                   target_os = "haiku",
                   target_os = "ios",
                   target_os = "linux",
+                  target_os = "redox",
                   target_os = "macos",
                   target_os = "netbsd"))]
         WEXITED;
+        /// Report the status of selected processes that have continued from a
+        /// job control stop by receiving a
+        /// [`SIGCONT`](crate::sys::signal::Signal::SIGCONT) signal.
         WCONTINUED;
+        /// An alias for WUNTRACED.
         #[cfg(any(target_os = "android",
                   target_os = "freebsd",
                   target_os = "haiku",
                   target_os = "ios",
                   target_os = "linux",
+                  target_os = "redox",
                   target_os = "macos",
                   target_os = "netbsd"))]
         WSTOPPED;
@@ -32,16 +48,18 @@ libc_bitflags!(
                   target_os = "haiku",
                   target_os = "ios",
                   target_os = "linux",
+                  target_os = "redox",
                   target_os = "macos",
                   target_os = "netbsd"))]
         WNOWAIT;
         /// Don't wait on children of other threads in this group
-        #[cfg(any(target_os = "android", target_os = "linux"))]
+        #[cfg(any(target_os = "android", target_os = "linux", target_os = "redox"))]
         __WNOTHREAD;
         /// Wait on all children, regardless of type
-        #[cfg(any(target_os = "android", target_os = "linux"))]
+        #[cfg(any(target_os = "android", target_os = "linux", target_os = "redox"))]
         __WALL;
-        #[cfg(any(target_os = "android", target_os = "linux"))]
+        /// Wait for "clone" children only.
+        #[cfg(any(target_os = "android", target_os = "linux", target_os = "redox"))]
         __WCLONE;
     }
 );
@@ -77,14 +95,14 @@ pub enum WaitStatus {
     /// field is the `PTRACE_EVENT_*` value of the event.
     ///
     /// [`nix::sys::ptrace`]: ../ptrace/index.html
-    /// [`ptrace`(2)]: http://man7.org/linux/man-pages/man2/ptrace.2.html
+    /// [`ptrace`(2)]: https://man7.org/linux/man-pages/man2/ptrace.2.html
     #[cfg(any(target_os = "linux", target_os = "android"))]
     PtraceEvent(Pid, Signal, c_int),
     /// The traced process was stopped by execution of a system call,
     /// and `PTRACE_O_TRACESYSGOOD` is in effect. See [`ptrace`(2)] for
     /// more information.
     ///
-    /// [`ptrace`(2)]: http://man7.org/linux/man-pages/man2/ptrace.2.html
+    /// [`ptrace`(2)]: https://man7.org/linux/man-pages/man2/ptrace.2.html
     #[cfg(any(target_os = "linux", target_os = "android"))]
     PtraceSyscall(Pid),
     /// The process was previously stopped but has resumed execution
@@ -104,8 +122,7 @@ impl WaitStatus {
     pub fn pid(&self) -> Option<Pid> {
         use self::WaitStatus::*;
         match *self {
-            Exited(p, _)  | Signaled(p, _, _) |
-                Stopped(p, _) | Continued(p) => Some(p),
+            Exited(p, _) | Signaled(p, _, _) | Stopped(p, _) | Continued(p) => Some(p),
             StillAlive => None,
             #[cfg(any(target_os = "android", target_os = "linux"))]
             PtraceEvent(p, _, _) | PtraceSyscall(p) => Some(p),
@@ -114,31 +131,31 @@ impl WaitStatus {
 }
 
 fn exited(status: i32) -> bool {
-    unsafe { libc::WIFEXITED(status) }
+    libc::WIFEXITED(status)
 }
 
 fn exit_status(status: i32) -> i32 {
-    unsafe { libc::WEXITSTATUS(status) }
+    libc::WEXITSTATUS(status)
 }
 
 fn signaled(status: i32) -> bool {
-    unsafe { libc::WIFSIGNALED(status) }
+    libc::WIFSIGNALED(status)
 }
 
 fn term_signal(status: i32) -> Result<Signal> {
-    Signal::from_c_int(unsafe { libc::WTERMSIG(status) })
+    Signal::try_from(libc::WTERMSIG(status))
 }
 
 fn dumped_core(status: i32) -> bool {
-    unsafe { libc::WCOREDUMP(status) }
+    libc::WCOREDUMP(status)
 }
 
 fn stopped(status: i32) -> bool {
-    unsafe { libc::WIFSTOPPED(status) }
+    libc::WIFSTOPPED(status)
 }
 
 fn stop_signal(status: i32) -> Result<Signal> {
-    Signal::from_c_int(unsafe { libc::WSTOPSIG(status) })
+    Signal::try_from(libc::WSTOPSIG(status))
 }
 
 #[cfg(any(target_os = "android", target_os = "linux"))]
@@ -147,7 +164,7 @@ fn syscall_stop(status: i32) -> bool {
     // of delivering SIGTRAP | 0x80 as the signal number for syscall
     // stops. This allows easily distinguishing syscall stops from
     // genuine SIGTRAP signals.
-    unsafe { libc::WSTOPSIG(status) == libc::SIGTRAP | 0x80 }
+    libc::WSTOPSIG(status) == libc::SIGTRAP | 0x80
 }
 
 #[cfg(any(target_os = "android", target_os = "linux"))]
@@ -156,7 +173,7 @@ fn stop_additional(status: i32) -> c_int {
 }
 
 fn continued(status: i32) -> bool {
-    unsafe { libc::WIFCONTINUED(status) }
+    libc::WIFCONTINUED(status)
 }
 
 impl WaitStatus {
@@ -210,6 +227,9 @@ impl WaitStatus {
     }
 }
 
+/// Wait for a process to change status
+///
+/// See also [waitpid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/waitpid.html)
 pub fn waitpid<P: Into<Option<Pid>>>(pid: P, options: Option<WaitPidFlag>) -> Result<WaitStatus> {
     use self::WaitStatus::*;
 
@@ -222,7 +242,7 @@ pub fn waitpid<P: Into<Option<Pid>>>(pid: P, options: Option<WaitPidFlag>) -> Re
 
     let res = unsafe {
         libc::waitpid(
-            pid.into().unwrap_or(Pid::from_raw(-1)).into(),
+            pid.into().unwrap_or_else(|| Pid::from_raw(-1)).into(),
             &mut status as *mut c_int,
             option_bits,
         )
@@ -234,6 +254,9 @@ pub fn waitpid<P: Into<Option<Pid>>>(pid: P, options: Option<WaitPidFlag>) -> Re
     }
 }
 
+/// Wait for any child process to change status or a signal is received.
+///
+/// See also [wait(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html)
 pub fn wait() -> Result<WaitStatus> {
     waitpid(None, None)
 }
diff --git a/third_party/rust/nix/src/time.rs b/third_party/rust/nix/src/time.rs
new file mode 100644
index 0000000000000..6275b59c74874
--- /dev/null
+++ b/third_party/rust/nix/src/time.rs
@@ -0,0 +1,260 @@
+use crate::sys::time::TimeSpec;
+#[cfg(any(
+    target_os = "freebsd",
+    target_os = "dragonfly",
+    target_os = "linux",
+    target_os = "android",
+    target_os = "emscripten",
+))]
+use crate::unistd::Pid;
+use crate::{Errno, Result};
+use libc::{self, clockid_t};
+use std::mem::MaybeUninit;
+
+/// Clock identifier
+///
+/// Newtype pattern around `clockid_t` (which is just alias). It pervents bugs caused by
+/// accidentally passing wrong value.
+#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
+pub struct ClockId(clockid_t);
+
+impl ClockId {
+    /// Creates `ClockId` from raw `clockid_t`
+    pub const fn from_raw(clk_id: clockid_t) -> Self {
+        ClockId(clk_id)
+    }
+
+    /// Returns `ClockId` of a `pid` CPU-time clock
+    #[cfg(any(
+        target_os = "freebsd",
+        target_os = "dragonfly",
+        target_os = "linux",
+        target_os = "android",
+        target_os = "emscripten",
+    ))]
+    pub fn pid_cpu_clock_id(pid: Pid) -> Result<Self> {
+        clock_getcpuclockid(pid)
+    }
+
+    /// Returns resolution of the clock id
+    #[cfg(not(target_os = "redox"))]
+    pub fn res(self) -> Result<TimeSpec> {
+        clock_getres(self)
+    }
+
+    /// Returns the current time on the clock id
+    pub fn now(self) -> Result<TimeSpec> {
+        clock_gettime(self)
+    }
+
+    /// Sets time to `timespec` on the clock id
+    #[cfg(not(any(
+        target_os = "macos",
+        target_os = "ios",
+        all(
+            not(any(target_env = "uclibc", target_env = "newlibc")),
+            any(target_os = "redox", target_os = "hermit",),
+        ),
+    )))]
+    pub fn set_time(self, timespec: TimeSpec) -> Result<()> {
+        clock_settime(self, timespec)
+    }
+
+    /// Gets the raw `clockid_t` wrapped by `self`
+    pub const fn as_raw(self) -> clockid_t {
+        self.0
+    }
+
+    #[cfg(any(
+        target_os = "fuchsia",
+        all(
+            not(any(target_env = "uclibc", target_env = "newlib")),
+            any(target_os = "linux", target_os = "android", target_os = "emscripten"),
+        )
+    ))]
+    pub const CLOCK_BOOTTIME: ClockId = ClockId(libc::CLOCK_BOOTTIME);
+    #[cfg(any(
+        target_os = "fuchsia",
+        all(
+            not(any(target_env = "uclibc", target_env = "newlib")),
+            any(target_os = "linux", target_os = "android", target_os = "emscripten")
+        )
+    ))]
+    pub const CLOCK_BOOTTIME_ALARM: ClockId = ClockId(libc::CLOCK_BOOTTIME_ALARM);
+    pub const CLOCK_MONOTONIC: ClockId = ClockId(libc::CLOCK_MONOTONIC);
+    #[cfg(any(
+        target_os = "fuchsia",
+        all(
+            not(any(target_env = "uclibc", target_env = "newlib")),
+            any(target_os = "linux", target_os = "android", target_os = "emscripten")
+        )
+    ))]
+    pub const CLOCK_MONOTONIC_COARSE: ClockId = ClockId(libc::CLOCK_MONOTONIC_COARSE);
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    pub const CLOCK_MONOTONIC_FAST: ClockId = ClockId(libc::CLOCK_MONOTONIC_FAST);
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    pub const CLOCK_MONOTONIC_PRECISE: ClockId = ClockId(libc::CLOCK_MONOTONIC_PRECISE);
+    #[cfg(any(
+        target_os = "fuchsia",
+        all(
+            not(any(target_env = "uclibc", target_env = "newlib")),
+            any(target_os = "linux", target_os = "android", target_os = "emscripten")
+        )
+    ))]
+    pub const CLOCK_MONOTONIC_RAW: ClockId = ClockId(libc::CLOCK_MONOTONIC_RAW);
+    #[cfg(any(
+        target_os = "fuchsia",
+        target_env = "uclibc",
+        target_os = "macos",
+        target_os = "ios",
+        target_os = "freebsd",
+        target_os = "dragonfly",
+        all(
+            not(target_env = "newlib"),
+            any(target_os = "linux", target_os = "android", target_os = "emscripten")
+        )
+    ))]
+    pub const CLOCK_PROCESS_CPUTIME_ID: ClockId = ClockId(libc::CLOCK_PROCESS_CPUTIME_ID);
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    pub const CLOCK_PROF: ClockId = ClockId(libc::CLOCK_PROF);
+    pub const CLOCK_REALTIME: ClockId = ClockId(libc::CLOCK_REALTIME);
+    #[cfg(any(
+        target_os = "fuchsia",
+        all(
+            not(any(target_env = "uclibc", target_env = "newlib")),
+            any(target_os = "linux", target_os = "android", target_os = "emscripten")
+        )
+    ))]
+    pub const CLOCK_REALTIME_ALARM: ClockId = ClockId(libc::CLOCK_REALTIME_ALARM);
+    #[cfg(any(
+        target_os = "fuchsia",
+        all(
+            not(any(target_env = "uclibc", target_env = "newlib")),
+            any(target_os = "linux", target_os = "android", target_os = "emscripten")
+        )
+    ))]
+    pub const CLOCK_REALTIME_COARSE: ClockId = ClockId(libc::CLOCK_REALTIME_COARSE);
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    pub const CLOCK_REALTIME_FAST: ClockId = ClockId(libc::CLOCK_REALTIME_FAST);
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    pub const CLOCK_REALTIME_PRECISE: ClockId = ClockId(libc::CLOCK_REALTIME_PRECISE);
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    pub const CLOCK_SECOND: ClockId = ClockId(libc::CLOCK_SECOND);
+    #[cfg(any(
+        target_os = "fuchsia",
+        all(
+            not(any(target_env = "uclibc", target_env = "newlib")),
+            any(
+                target_os = "emscripten",
+                all(target_os = "linux", target_env = "musl")
+            )
+        )
+    ))]
+    pub const CLOCK_SGI_CYCLE: ClockId = ClockId(libc::CLOCK_SGI_CYCLE);
+    #[cfg(any(
+        target_os = "fuchsia",
+        all(
+            not(any(target_env = "uclibc", target_env = "newlib")),
+            any(
+                target_os = "emscripten",
+                all(target_os = "linux", target_env = "musl")
+            )
+        )
+    ))]
+    pub const CLOCK_TAI: ClockId = ClockId(libc::CLOCK_TAI);
+    #[cfg(any(
+        target_env = "uclibc",
+        target_os = "fuchsia",
+        target_os = "ios",
+        target_os = "macos",
+        target_os = "freebsd",
+        target_os = "dragonfly",
+        all(
+            not(target_env = "newlib"),
+            any(target_os = "linux", target_os = "android", target_os = "emscripten",),
+        ),
+    ))]
+    pub const CLOCK_THREAD_CPUTIME_ID: ClockId = ClockId(libc::CLOCK_THREAD_CPUTIME_ID);
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    pub const CLOCK_UPTIME: ClockId = ClockId(libc::CLOCK_UPTIME);
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    pub const CLOCK_UPTIME_FAST: ClockId = ClockId(libc::CLOCK_UPTIME_FAST);
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    pub const CLOCK_UPTIME_PRECISE: ClockId = ClockId(libc::CLOCK_UPTIME_PRECISE);
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    pub const CLOCK_VIRTUAL: ClockId = ClockId(libc::CLOCK_VIRTUAL);
+}
+
+impl From<ClockId> for clockid_t {
+    fn from(clock_id: ClockId) -> Self {
+        clock_id.as_raw()
+    }
+}
+
+impl From<clockid_t> for ClockId {
+    fn from(clk_id: clockid_t) -> Self {
+        ClockId::from_raw(clk_id)
+    }
+}
+
+impl std::fmt::Display for ClockId {
+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
+        std::fmt::Display::fmt(&self.0, f)
+    }
+}
+
+/// Get the resolution of the specified clock, (see
+/// [clock_getres(2)](https://pubs.opengroup.org/onlinepubs/7908799/xsh/clock_getres.html)).
+#[cfg(not(target_os = "redox"))]
+pub fn clock_getres(clock_id: ClockId) -> Result<TimeSpec> {
+    let mut c_time: MaybeUninit<libc::timespec> = MaybeUninit::uninit();
+    let ret = unsafe { libc::clock_getres(clock_id.as_raw(), c_time.as_mut_ptr()) };
+    Errno::result(ret)?;
+    let res = unsafe { c_time.assume_init() };
+    Ok(TimeSpec::from(res))
+}
+
+/// Get the time of the specified clock, (see
+/// [clock_gettime(2)](https://pubs.opengroup.org/onlinepubs/7908799/xsh/clock_gettime.html)).
+pub fn clock_gettime(clock_id: ClockId) -> Result<TimeSpec> {
+    let mut c_time: MaybeUninit<libc::timespec> = MaybeUninit::uninit();
+    let ret = unsafe { libc::clock_gettime(clock_id.as_raw(), c_time.as_mut_ptr()) };
+    Errno::result(ret)?;
+    let res = unsafe { c_time.assume_init() };
+    Ok(TimeSpec::from(res))
+}
+
+/// Set the time of the specified clock, (see
+/// [clock_settime(2)](https://pubs.opengroup.org/onlinepubs/7908799/xsh/clock_settime.html)).
+#[cfg(not(any(
+    target_os = "macos",
+    target_os = "ios",
+    all(
+        not(any(target_env = "uclibc", target_env = "newlibc")),
+        any(target_os = "redox", target_os = "hermit",),
+    ),
+)))]
+pub fn clock_settime(clock_id: ClockId, timespec: TimeSpec) -> Result<()> {
+    let ret = unsafe { libc::clock_settime(clock_id.as_raw(), timespec.as_ref()) };
+    Errno::result(ret).map(drop)
+}
+
+/// Get the clock id of the specified process id, (see
+/// [clock_getcpuclockid(3)](https://pubs.opengroup.org/onlinepubs/009695399/functions/clock_getcpuclockid.html)).
+#[cfg(any(
+    target_os = "freebsd",
+    target_os = "dragonfly",
+    target_os = "linux",
+    target_os = "android",
+    target_os = "emscripten",
+))]
+pub fn clock_getcpuclockid(pid: Pid) -> Result<ClockId> {
+    let mut clk_id: MaybeUninit<libc::clockid_t> = MaybeUninit::uninit();
+    let ret = unsafe { libc::clock_getcpuclockid(pid.into(), clk_id.as_mut_ptr()) };
+    if ret == 0 {
+        let res = unsafe { clk_id.assume_init() };
+        Ok(ClockId::from(res))
+    } else {
+        Err(Errno::from_i32(ret))
+    }
+}
diff --git a/third_party/rust/nix/src/ucontext.rs b/third_party/rust/nix/src/ucontext.rs
index 5e10e7d1f8934..f2338bd426ac2 100644
--- a/third_party/rust/nix/src/ucontext.rs
+++ b/third_party/rust/nix/src/ucontext.rs
@@ -1,10 +1,10 @@
-use libc;
 #[cfg(not(target_env = "musl"))]
-use Result;
+use crate::Result;
+#[cfg(not(target_env = "musl"))]
+use crate::errno::Errno;
 #[cfg(not(target_env = "musl"))]
-use errno::Errno;
 use std::mem;
-use sys::signal::SigSet;
+use crate::sys::signal::SigSet;
 
 #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
 pub struct UContext {
@@ -14,11 +14,11 @@ pub struct UContext {
 impl UContext {
     #[cfg(not(target_env = "musl"))]
     pub fn get() -> Result<UContext> {
-        let mut context: libc::ucontext_t = unsafe { mem::uninitialized() };
-        let res = unsafe {
-            libc::getcontext(&mut context as *mut libc::ucontext_t)
-        };
-        Errno::result(res).map(|_| UContext { context: context })
+        let mut context = mem::MaybeUninit::<libc::ucontext_t>::uninit();
+        let res = unsafe { libc::getcontext(context.as_mut_ptr()) };
+        Errno::result(res).map(|_| unsafe {
+            UContext { context: context.assume_init()}
+        })
     }
 
     #[cfg(not(target_env = "musl"))]
@@ -30,10 +30,14 @@ impl UContext {
     }
 
     pub fn sigmask_mut(&mut self) -> &mut SigSet {
-        unsafe { mem::transmute(&mut self.context.uc_sigmask) }
+        unsafe {
+            &mut *(&mut self.context.uc_sigmask as *mut libc::sigset_t as *mut SigSet)
+        }
     }
 
     pub fn sigmask(&self) -> &SigSet {
-        unsafe { mem::transmute(&self.context.uc_sigmask) }
+        unsafe {
+            &*(&self.context.uc_sigmask as *const libc::sigset_t as *const SigSet)
+        }
     }
 }
diff --git a/third_party/rust/nix/src/unistd.rs b/third_party/rust/nix/src/unistd.rs
index f422f09198655..2c89d77240e26 100644
--- a/third_party/rust/nix/src/unistd.rs
+++ b/third_party/rust/nix/src/unistd.rs
@@ -1,18 +1,26 @@
 //! Safe wrappers around functions found in libc "unistd.h" header
 
-use errno::{self, Errno};
-use {Error, Result, NixPath};
-use fcntl::{AtFlags, at_rawfd, fcntl, FdFlag, OFlag};
-use fcntl::FcntlArg::F_SETFD;
+#[cfg(not(target_os = "redox"))]
+use cfg_if::cfg_if;
+use crate::errno::{self, Errno};
+use crate::{Error, Result, NixPath};
+#[cfg(not(target_os = "redox"))]
+use crate::fcntl::{AtFlags, at_rawfd};
+use crate::fcntl::{FdFlag, OFlag, fcntl};
+use crate::fcntl::FcntlArg::F_SETFD;
 use libc::{self, c_char, c_void, c_int, c_long, c_uint, size_t, pid_t, off_t,
-           uid_t, gid_t, mode_t};
+           uid_t, gid_t, mode_t, PATH_MAX};
 use std::{fmt, mem, ptr};
-use std::ffi::{CString, CStr, OsString, OsStr};
-use std::os::unix::ffi::{OsStringExt, OsStrExt};
+use std::convert::Infallible;
+use std::ffi::{CStr, OsString};
+#[cfg(not(target_os = "redox"))]
+use std::ffi::{CString, OsStr};
+use std::os::unix::ffi::OsStringExt;
+#[cfg(not(target_os = "redox"))]
+use std::os::unix::ffi::OsStrExt;
 use std::os::unix::io::RawFd;
 use std::path::PathBuf;
-use void::Void;
-use sys::stat::Mode;
+use crate::sys::stat::Mode;
 
 #[cfg(any(target_os = "android", target_os = "linux"))]
 pub use self::pivot_root::*;
@@ -21,6 +29,9 @@ pub use self::pivot_root::*;
           target_os = "linux", target_os = "openbsd"))]
 pub use self::setres::*;
 
+#[cfg(any(target_os = "android", target_os = "linux"))]
+pub use self::getres::*;
+
 /// User identifier
 ///
 /// Newtype pattern around `uid_t` (which is just alias). It prevents bugs caused by accidentally
@@ -30,7 +41,7 @@ pub struct Uid(uid_t);
 
 impl Uid {
     /// Creates `Uid` from raw `uid_t`.
-    pub fn from_raw(uid: uid_t) -> Self {
+    pub const fn from_raw(uid: uid_t) -> Self {
         Uid(uid)
     }
 
@@ -45,12 +56,12 @@ impl Uid {
     }
 
     /// Returns true if the `Uid` represents privileged user - root. (If it equals zero.)
-    pub fn is_root(&self) -> bool {
-        *self == ROOT
+    pub const fn is_root(self) -> bool {
+        self.0 == ROOT.0
     }
 
     /// Get the raw `uid_t` wrapped by `self`.
-    pub fn as_raw(&self) -> uid_t {
+    pub const fn as_raw(self) -> uid_t {
         self.0
     }
 }
@@ -79,7 +90,7 @@ pub struct Gid(gid_t);
 
 impl Gid {
     /// Creates `Gid` from raw `gid_t`.
-    pub fn from_raw(gid: gid_t) -> Self {
+    pub const fn from_raw(gid: gid_t) -> Self {
         Gid(gid)
     }
 
@@ -88,13 +99,13 @@ impl Gid {
         getgid()
     }
 
-    /// Returns effective Gid of calling process. This is practically a more Rusty alias for `getgid`.
+    /// Returns effective Gid of calling process. This is practically a more Rusty alias for `getegid`.
     pub fn effective() -> Self {
         getegid()
     }
 
     /// Get the raw `gid_t` wrapped by `self`.
-    pub fn as_raw(&self) -> gid_t {
+    pub const fn as_raw(self) -> gid_t {
         self.0
     }
 }
@@ -115,12 +126,12 @@ impl fmt::Display for Gid {
 ///
 /// Newtype pattern around `pid_t` (which is just alias). It prevents bugs caused by accidentally
 /// passing wrong value.
-#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
+#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
 pub struct Pid(pid_t);
 
 impl Pid {
     /// Creates `Pid` from raw `pid_t`.
-    pub fn from_raw(pid: pid_t) -> Self {
+    pub const fn from_raw(pid: pid_t) -> Self {
         Pid(pid)
     }
 
@@ -135,7 +146,7 @@ impl Pid {
     }
 
     /// Get the raw `pid_t` wrapped by `self`.
-    pub fn as_raw(&self) -> pid_t {
+    pub const fn as_raw(self) -> pid_t {
         self.0
     }
 }
@@ -168,35 +179,37 @@ impl ForkResult {
 
     /// Return `true` if this is the child process of the `fork()`
     #[inline]
-    pub fn is_child(&self) -> bool {
-        match *self {
-            ForkResult::Child => true,
-            _ => false
-        }
+    pub fn is_child(self) -> bool {
+        matches!(self, ForkResult::Child)
     }
 
     /// Returns `true` if this is the parent process of the `fork()`
     #[inline]
-    pub fn is_parent(&self) -> bool {
+    pub fn is_parent(self) -> bool {
         !self.is_child()
     }
 }
 
 /// Create a new child process duplicating the parent process ([see
-/// fork(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html)).
+/// fork(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html)).
 ///
 /// After calling the fork system call (successfully) two processes will
 /// be created that are identical with the exception of their pid and the
 /// return value of this function.  As an example:
 ///
-/// ```no_run
-/// use nix::unistd::{fork, ForkResult};
+/// ```
+/// use nix::{sys::wait::waitpid,unistd::{fork, ForkResult, write}};
 ///
-/// match fork() {
+/// match unsafe{fork()} {
 ///    Ok(ForkResult::Parent { child, .. }) => {
 ///        println!("Continuing execution in parent process, new child has pid: {}", child);
+///        waitpid(child, None).unwrap();
+///    }
+///    Ok(ForkResult::Child) => {
+///        // Unsafe to use `println!` (or `unwrap`) here. See Safety.
+///        write(libc::STDOUT_FILENO, "I'm a new child process\n".as_bytes()).ok();
+///        unsafe { libc::_exit(0) };
 ///    }
-///    Ok(ForkResult::Child) => println!("I'm a new child process"),
 ///    Err(_) => println!("Fork failed"),
 /// }
 /// ```
@@ -220,11 +233,11 @@ impl ForkResult {
 /// Those functions are only a small subset of your operating system's API, so
 /// special care must be taken to only invoke code you can control and audit.
 ///
-/// [async-signal-safe]: http://man7.org/linux/man-pages/man7/signal-safety.7.html
+/// [async-signal-safe]: https://man7.org/linux/man-pages/man7/signal-safety.7.html
 #[inline]
-pub fn fork() -> Result<ForkResult> {
+pub unsafe fn fork() -> Result<ForkResult> {
     use self::ForkResult::*;
-    let res = unsafe { libc::fork() };
+    let res = libc::fork();
 
     Errno::result(res).map(|res| match res {
         0 => Child,
@@ -233,7 +246,7 @@ pub fn fork() -> Result<ForkResult> {
 }
 
 /// Get the pid of this process (see
-/// [getpid(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/getpid.html)).
+/// [getpid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpid.html)).
 ///
 /// Since you are running code, there is always a pid to return, so there
 /// is no error case that needs to be handled.
@@ -243,7 +256,7 @@ pub fn getpid() -> Pid {
 }
 
 /// Get the pid of this processes' parent (see
-/// [getpid(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/getppid.html)).
+/// [getpid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getppid.html)).
 ///
 /// There is always a parent pid to return, so there is no error case that needs
 /// to be handled.
@@ -253,7 +266,7 @@ pub fn getppid() -> Pid {
 }
 
 /// Set a process group ID (see
-/// [setpgid(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/setpgid.html)).
+/// [setpgid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/setpgid.html)).
 ///
 /// Set the process group id (PGID) of a particular process.  If a pid of zero
 /// is specified, then the pid of the calling process is used.  Process groups
@@ -273,18 +286,19 @@ pub fn getpgid(pid: Option<Pid>) -> Result<Pid> {
 }
 
 /// Create new session and set process group id (see
-/// [setsid(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/setsid.html)).
+/// [setsid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/setsid.html)).
 #[inline]
 pub fn setsid() -> Result<Pid> {
     Errno::result(unsafe { libc::setsid() }).map(Pid)
 }
 
 /// Get the process group ID of a session leader
-/// [getsid(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/getsid.html).
+/// [getsid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsid.html).
 ///
 /// Obtain the process group ID of the process that is the session leader of the process specified
 /// by pid. If pid is zero, it specifies the calling process.
 #[inline]
+#[cfg(not(target_os = "redox"))]
 pub fn getsid(pid: Option<Pid>) -> Result<Pid> {
     let res = unsafe { libc::getsid(pid.unwrap_or(Pid(0)).into()) };
     Errno::result(res).map(Pid)
@@ -292,7 +306,7 @@ pub fn getsid(pid: Option<Pid>) -> Result<Pid> {
 
 
 /// Get the terminal foreground process group (see
-/// [tcgetpgrp(3)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/tcgetpgrp.html)).
+/// [tcgetpgrp(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tcgetpgrp.html)).
 ///
 /// Get the group process id (GPID) of the foreground process group on the
 /// terminal associated to file descriptor (FD).
@@ -302,7 +316,7 @@ pub fn tcgetpgrp(fd: c_int) -> Result<Pid> {
     Errno::result(res).map(Pid)
 }
 /// Set the terminal foreground process group (see
-/// [tcgetpgrp(3)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/tcsetpgrp.html)).
+/// [tcgetpgrp(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tcsetpgrp.html)).
 ///
 /// Get the group process id (PGID) to the foreground process group on the
 /// terminal associated to file descriptor (FD).
@@ -314,7 +328,7 @@ pub fn tcsetpgrp(fd: c_int, pgrp: Pid) -> Result<()> {
 
 
 /// Get the group id of the calling process (see
-///[getpgrp(3)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/getpgrp.html)).
+///[getpgrp(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpgrp.html)).
 ///
 /// Get the process group id (PGID) of the calling process.
 /// According to the man page it is always successful.
@@ -324,7 +338,7 @@ pub fn getpgrp() -> Pid {
 }
 
 /// Get the caller's thread ID (see
-/// [gettid(2)](http://man7.org/linux/man-pages/man2/gettid.2.html).
+/// [gettid(2)](https://man7.org/linux/man-pages/man2/gettid.2.html).
 ///
 /// This function is only available on Linux based systems.  In a single
 /// threaded process, the main thread will have the same ID as the process.  In
@@ -340,7 +354,7 @@ pub fn gettid() -> Pid {
 }
 
 /// Create a copy of the specified file descriptor (see
-/// [dup(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/dup.html)).
+/// [dup(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/dup.html)).
 ///
 /// The new file descriptor will be have a new index but refer to the same
 /// resource as the old file descriptor and the old and new file descriptors may
@@ -357,7 +371,7 @@ pub fn dup(oldfd: RawFd) -> Result<RawFd> {
 }
 
 /// Create a copy of the specified file descriptor using the specified fd (see
-/// [dup(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/dup.html)).
+/// [dup(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/dup.html)).
 ///
 /// This function behaves similar to `dup()` except that it will try to use the
 /// specified fd instead of allocating a new one.  See the man pages for more
@@ -370,7 +384,7 @@ pub fn dup2(oldfd: RawFd, newfd: RawFd) -> Result<RawFd> {
 }
 
 /// Create a new copy of the specified file descriptor using the specified fd
-/// and flags (see [dup(2)](http://man7.org/linux/man-pages/man2/dup.2.html)).
+/// and flags (see [dup(2)](https://man7.org/linux/man-pages/man2/dup.2.html)).
 ///
 /// This function behaves similar to `dup2()` but allows for flags to be
 /// specified.
@@ -381,7 +395,7 @@ pub fn dup3(oldfd: RawFd, newfd: RawFd, flags: OFlag) -> Result<RawFd> {
 #[inline]
 fn dup3_polyfill(oldfd: RawFd, newfd: RawFd, flags: OFlag) -> Result<RawFd> {
     if oldfd == newfd {
-        return Err(Error::Sys(Errno::EINVAL));
+        return Err(Errno::EINVAL);
     }
 
     let fd = dup2(oldfd, newfd)?;
@@ -397,7 +411,7 @@ fn dup3_polyfill(oldfd: RawFd, newfd: RawFd, flags: OFlag) -> Result<RawFd> {
 }
 
 /// Change the current working directory of the calling process (see
-/// [chdir(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/chdir.html)).
+/// [chdir(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/chdir.html)).
 ///
 /// This function may fail in a number of different scenarios.  See the man
 /// pages for additional details on possible failure cases.
@@ -412,18 +426,19 @@ pub fn chdir<P: ?Sized + NixPath>(path: &P) -> Result<()> {
 
 /// Change the current working directory of the process to the one
 /// given as an open file descriptor (see
-/// [fchdir(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fchdir.html)).
+/// [fchdir(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fchdir.html)).
 ///
 /// This function may fail in a number of different scenarios.  See the man
 /// pages for additional details on possible failure cases.
 #[inline]
+#[cfg(not(target_os = "fuchsia"))]
 pub fn fchdir(dirfd: RawFd) -> Result<()> {
     let res = unsafe { libc::fchdir(dirfd) };
 
     Errno::result(res).map(drop)
 }
 
-/// Creates new directory `path` with access rights `mode`.  (see [mkdir(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdir.html))
+/// Creates new directory `path` with access rights `mode`.  (see [mkdir(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdir.html))
 ///
 /// # Errors
 ///
@@ -436,22 +451,17 @@ pub fn fchdir(dirfd: RawFd) -> Result<()> {
 /// # Example
 ///
 /// ```rust
-/// extern crate tempfile;
-/// extern crate nix;
-///
 /// use nix::unistd;
 /// use nix::sys::stat;
 /// use tempfile::tempdir;
 ///
-/// fn main() {
-///     let tmp_dir1 = tempdir().unwrap();
-///     let tmp_dir2 = tmp_dir1.path().join("new_dir");
+/// let tmp_dir1 = tempdir().unwrap();
+/// let tmp_dir2 = tmp_dir1.path().join("new_dir");
 ///
-///     // create new directory and give read, write and execute rights to the owner
-///     match unistd::mkdir(&tmp_dir2, stat::Mode::S_IRWXU) {
-///        Ok(_) => println!("created {:?}", tmp_dir2),
-///        Err(err) => println!("Error creating directory: {}", err),
-///     }
+/// // create new directory and give read, write and execute rights to the owner
+/// match unistd::mkdir(&tmp_dir2, stat::Mode::S_IRWXU) {
+///    Ok(_) => println!("created {:?}", tmp_dir2),
+///    Err(err) => println!("Error creating directory: {}", err),
 /// }
 /// ```
 #[inline]
@@ -474,30 +484,26 @@ pub fn mkdir<P: ?Sized + NixPath>(path: &P, mode: Mode) -> Result<()> {
 /// - the path name is too long (longer than `PATH_MAX`, usually 4096 on linux, 1024 on OS X)
 ///
 /// For a full list consult
-/// [posix specification](http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkfifo.html)
+/// [posix specification](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkfifo.html)
 ///
 /// # Example
 ///
 /// ```rust
-/// extern crate tempfile;
-/// extern crate nix;
-///
 /// use nix::unistd;
 /// use nix::sys::stat;
 /// use tempfile::tempdir;
 ///
-/// fn main() {
-///     let tmp_dir = tempdir().unwrap();
-///     let fifo_path = tmp_dir.path().join("foo.pipe");
+/// let tmp_dir = tempdir().unwrap();
+/// let fifo_path = tmp_dir.path().join("foo.pipe");
 ///
-///     // create new fifo and give read, write and execute rights to the owner
-///     match unistd::mkfifo(&fifo_path, stat::Mode::S_IRWXU) {
-///        Ok(_) => println!("created {:?}", fifo_path),
-///        Err(err) => println!("Error creating fifo: {}", err),
-///     }
+/// // create new fifo and give read, write and execute rights to the owner
+/// match unistd::mkfifo(&fifo_path, stat::Mode::S_IRWXU) {
+///    Ok(_) => println!("created {:?}", fifo_path),
+///    Err(err) => println!("Error creating fifo: {}", err),
 /// }
 /// ```
 #[inline]
+#[cfg(not(target_os = "redox"))] // RedoxFS does not support fifo yet
 pub fn mkfifo<P: ?Sized + NixPath>(path: &P, mode: Mode) -> Result<()> {
     let res = path.with_nix_path(|cstr| {
         unsafe { libc::mkfifo(cstr.as_ptr(), mode.bits() as mode_t) }
@@ -506,6 +512,28 @@ pub fn mkfifo<P: ?Sized + NixPath>(path: &P, mode: Mode) -> Result<()> {
     Errno::result(res).map(drop)
 }
 
+/// Creates new fifo special file (named pipe) with path `path` and access rights `mode`.
+///
+/// If `dirfd` has a value, then `path` is relative to directory associated with the file descriptor.
+///
+/// If `dirfd` is `None`, then `path` is relative to the current working directory.
+///
+/// # References
+///
+/// [mkfifoat(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkfifoat.html).
+// mkfifoat is not implemented in OSX or android
+#[inline]
+#[cfg(not(any(
+    target_os = "macos", target_os = "ios",
+    target_os = "android", target_os = "redox")))]
+pub fn mkfifoat<P: ?Sized + NixPath>(dirfd: Option<RawFd>, path: &P, mode: Mode) -> Result<()> {
+    let res = path.with_nix_path(|cstr| unsafe {
+        libc::mkfifoat(at_rawfd(dirfd), cstr.as_ptr(), mode.bits() as mode_t)
+    })?;
+
+    Errno::result(res).map(drop)
+}
+
 /// Creates a symbolic link at `path2` which points to `path1`.
 ///
 /// If `dirfd` has a value, then `path2` is relative to directory associated
@@ -514,7 +542,8 @@ pub fn mkfifo<P: ?Sized + NixPath>(path: &P, mode: Mode) -> Result<()> {
 /// If `dirfd` is `None`, then `path2` is relative to the current working
 /// directory. This is identical to `libc::symlink(path1, path2)`.
 ///
-/// See also [symlinkat(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/symlinkat.html).
+/// See also [symlinkat(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/symlinkat.html).
+#[cfg(not(target_os = "redox"))]
 pub fn symlinkat<P1: ?Sized + NixPath, P2: ?Sized + NixPath>(
     path1: &P1,
     dirfd: Option<RawFd>,
@@ -534,6 +563,21 @@ pub fn symlinkat<P1: ?Sized + NixPath, P2: ?Sized + NixPath>(
     Errno::result(res).map(drop)
 }
 
+// Double the buffer capacity up to limit. In case it already has
+// reached the limit, return Errno::ERANGE.
+fn reserve_double_buffer_size<T>(buf: &mut Vec<T>, limit: usize) -> Result<()> {
+    use std::cmp::min;
+
+    if buf.capacity() >= limit {
+        return Err(Errno::ERANGE)
+    }
+
+    let capacity = min(buf.capacity() * 2, limit);
+    buf.reserve(capacity);
+
+    Ok(())
+}
+
 /// Returns the current directory as a `PathBuf`
 ///
 /// Err is returned if the current user doesn't have the permission to read or search a component
@@ -542,15 +586,11 @@ pub fn symlinkat<P1: ?Sized + NixPath, P2: ?Sized + NixPath>(
 /// # Example
 ///
 /// ```rust
-/// extern crate nix;
-///
 /// use nix::unistd;
 ///
-/// fn main() {
-///     // assume that we are allowed to get current directory
-///     let dir = unistd::getcwd().unwrap();
-///     println!("The current directory is {:?}", dir);
-/// }
+/// // assume that we are allowed to get current directory
+/// let dir = unistd::getcwd().unwrap();
+/// println!("The current directory is {:?}", dir);
 /// ```
 #[inline]
 pub fn getcwd() -> Result<PathBuf> {
@@ -572,32 +612,33 @@ pub fn getcwd() -> Result<PathBuf> {
                 let error = Errno::last();
                 // ERANGE means buffer was too small to store directory name
                 if error != Errno::ERANGE {
-                    return Err(Error::Sys(error));
+                    return Err(error);
                 }
-            }
+           }
 
-            // Trigger the internal buffer resizing logic of `Vec` by requiring
-            // more space than the current capacity.
-            let cap = buf.capacity();
-            buf.set_len(cap);
-            buf.reserve(1);
+            // Trigger the internal buffer resizing logic.
+            reserve_double_buffer_size(&mut buf, PATH_MAX as usize)?;
         }
     }
 }
 
 /// Computes the raw UID and GID values to pass to a `*chown` call.
+// The cast is not unnecessary on all platforms.
+#[allow(clippy::unnecessary_cast)]
 fn chown_raw_ids(owner: Option<Uid>, group: Option<Gid>) -> (libc::uid_t, libc::gid_t) {
     // According to the POSIX specification, -1 is used to indicate that owner and group
     // are not to be changed.  Since uid_t and gid_t are unsigned types, we have to wrap
     // around to get -1.
-    let uid = owner.map(Into::into).unwrap_or((0 as uid_t).wrapping_sub(1));
-    let gid = group.map(Into::into).unwrap_or((0 as gid_t).wrapping_sub(1));
+    let uid = owner.map(Into::into)
+        .unwrap_or_else(|| (0 as uid_t).wrapping_sub(1));
+    let gid = group.map(Into::into)
+        .unwrap_or_else(|| (0 as gid_t).wrapping_sub(1));
     (uid, gid)
 }
 
 /// Change the ownership of the file at `path` to be owned by the specified
 /// `owner` (user) and `group` (see
-/// [chown(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/chown.html)).
+/// [chown(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/chown.html)).
 ///
 /// The owner/group for the provided path name will not be modified if `None` is
 /// provided for that argument.  Ownership change will be attempted for the path
@@ -612,6 +653,20 @@ pub fn chown<P: ?Sized + NixPath>(path: &P, owner: Option<Uid>, group: Option<Gi
     Errno::result(res).map(drop)
 }
 
+/// Change the ownership of the file referred to by the open file descriptor `fd` to be owned by
+/// the specified `owner` (user) and `group` (see
+/// [fchown(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fchown.html)).
+///
+/// The owner/group for the provided file will not be modified if `None` is
+/// provided for that argument.  Ownership change will be attempted for the path
+/// only if `Some` owner/group is provided.
+#[inline]
+pub fn fchown(fd: RawFd, owner: Option<Uid>, group: Option<Gid>) -> Result<()> {
+    let (uid, gid) = chown_raw_ids(owner, group);
+    let res = unsafe { libc::fchown(fd, uid, gid) };
+    Errno::result(res).map(drop)
+}
+
 /// Flags for `fchownat` function.
 #[derive(Clone, Copy, Debug)]
 pub enum FchownatFlags {
@@ -639,7 +694,8 @@ pub enum FchownatFlags {
 ///
 /// # References
 ///
-/// [fchownat(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fchownat.html).
+/// [fchownat(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fchownat.html).
+#[cfg(not(target_os = "redox"))]
 pub fn fchownat<P: ?Sized + NixPath>(
     dirfd: Option<RawFd>,
     path: &P,
@@ -661,32 +717,31 @@ pub fn fchownat<P: ?Sized + NixPath>(
     Errno::result(res).map(drop)
 }
 
-fn to_exec_array(args: &[CString]) -> Vec<*const c_char> {
-    let mut args_p: Vec<*const c_char> = args.iter().map(|s| s.as_ptr()).collect();
-    args_p.push(ptr::null());
-    args_p
+fn to_exec_array<S: AsRef<CStr>>(args: &[S]) -> Vec<*const c_char> {
+    use std::iter::once;
+    args.iter().map(|s| s.as_ref().as_ptr()).chain(once(ptr::null())).collect()
 }
 
 /// Replace the current process image with a new one (see
-/// [exec(3)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html)).
+/// [exec(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html)).
 ///
 /// See the `::nix::unistd::execve` system call for additional details.  `execv`
 /// performs the same action but does not allow for customization of the
 /// environment for the new process.
 #[inline]
-pub fn execv(path: &CString, argv: &[CString]) -> Result<Void> {
+pub fn execv<S: AsRef<CStr>>(path: &CStr, argv: &[S]) -> Result<Infallible> {
     let args_p = to_exec_array(argv);
 
     unsafe {
         libc::execv(path.as_ptr(), args_p.as_ptr())
     };
 
-    Err(Error::Sys(Errno::last()))
+    Err(Errno::last())
 }
 
 
 /// Replace the current process image with a new one (see
-/// [execve(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html)).
+/// [execve(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html)).
 ///
 /// The execve system call allows for another process to be "called" which will
 /// replace the current process image.  That is, this process becomes the new
@@ -698,7 +753,7 @@ pub fn execv(path: &CString, argv: &[CString]) -> Result<Void> {
 /// in the `args` list is an argument to the new process. Each element in the
 /// `env` list should be a string in the form "key=value".
 #[inline]
-pub fn execve(path: &CString, args: &[CString], env: &[CString]) -> Result<Void> {
+pub fn execve<SA: AsRef<CStr>, SE: AsRef<CStr>>(path: &CStr, args: &[SA], env: &[SE]) -> Result<Infallible> {
     let args_p = to_exec_array(args);
     let env_p = to_exec_array(env);
 
@@ -706,12 +761,12 @@ pub fn execve(path: &CString, args: &[CString], env: &[CString]) -> Result<Void>
         libc::execve(path.as_ptr(), args_p.as_ptr(), env_p.as_ptr())
     };
 
-    Err(Error::Sys(Errno::last()))
+    Err(Errno::last())
 }
 
 /// Replace the current process image with a new one and replicate shell `PATH`
 /// searching behavior (see
-/// [exec(3)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html)).
+/// [exec(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html)).
 ///
 /// See `::nix::unistd::execve` for additional details.  `execvp` behaves the
 /// same as execv except that it will examine the `PATH` environment variables
@@ -719,19 +774,19 @@ pub fn execve(path: &CString, args: &[CString], env: &[CString]) -> Result<Void>
 /// would not work if "bash" was specified for the path argument, but `execvp`
 /// would assuming that a bash executable was on the system `PATH`.
 #[inline]
-pub fn execvp(filename: &CString, args: &[CString]) -> Result<Void> {
+pub fn execvp<S: AsRef<CStr>>(filename: &CStr, args: &[S]) -> Result<Infallible> {
     let args_p = to_exec_array(args);
 
     unsafe {
         libc::execvp(filename.as_ptr(), args_p.as_ptr())
     };
 
-    Err(Error::Sys(Errno::last()))
+    Err(Errno::last())
 }
 
 /// Replace the current process image with a new one and replicate shell `PATH`
 /// searching behavior (see
-/// [`execvpe(3)`](http://man7.org/linux/man-pages/man3/exec.3.html)).
+/// [`execvpe(3)`](https://man7.org/linux/man-pages/man3/exec.3.html)).
 ///
 /// This functions like a combination of `execvp(2)` and `execve(2)` to pass an
 /// environment and have a search path. See these two for additional
@@ -739,7 +794,7 @@ pub fn execvp(filename: &CString, args: &[CString]) -> Result<Void> {
 #[cfg(any(target_os = "haiku",
           target_os = "linux",
           target_os = "openbsd"))]
-pub fn execvpe(filename: &CString, args: &[CString], env: &[CString]) -> Result<Void> {
+pub fn execvpe<SA: AsRef<CStr>, SE: AsRef<CStr>>(filename: &CStr, args: &[SA], env: &[SE]) -> Result<Infallible> {
     let args_p = to_exec_array(args);
     let env_p = to_exec_array(env);
 
@@ -747,11 +802,11 @@ pub fn execvpe(filename: &CString, args: &[CString], env: &[CString]) -> Result<
         libc::execvpe(filename.as_ptr(), args_p.as_ptr(), env_p.as_ptr())
     };
 
-    Err(Error::Sys(Errno::last()))
+    Err(Errno::last())
 }
 
 /// Replace the current process image with a new one (see
-/// [fexecve(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fexecve.html)).
+/// [fexecve(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fexecve.html)).
 ///
 /// The `fexecve` function allows for another process to be "called" which will
 /// replace the current process image.  That is, this process becomes the new
@@ -767,7 +822,7 @@ pub fn execvpe(filename: &CString, args: &[CString], env: &[CString]) -> Result<
           target_os = "linux",
           target_os = "freebsd"))]
 #[inline]
-pub fn fexecve(fd: RawFd, args: &[CString], env: &[CString]) -> Result<Void> {
+pub fn fexecve<SA: AsRef<CStr> ,SE: AsRef<CStr>>(fd: RawFd, args: &[SA], env: &[SE]) -> Result<Infallible> {
     let args_p = to_exec_array(args);
     let env_p = to_exec_array(env);
 
@@ -775,11 +830,11 @@ pub fn fexecve(fd: RawFd, args: &[CString], env: &[CString]) -> Result<Void> {
         libc::fexecve(fd, args_p.as_ptr(), env_p.as_ptr())
     };
 
-    Err(Error::Sys(Errno::last()))
+    Err(Errno::last())
 }
 
 /// Execute program relative to a directory file descriptor (see
-/// [execveat(2)](http://man7.org/linux/man-pages/man2/execveat.2.html)).
+/// [execveat(2)](https://man7.org/linux/man-pages/man2/execveat.2.html)).
 ///
 /// The `execveat` function allows for another process to be "called" which will
 /// replace the current process image.  That is, this process becomes the new
@@ -790,8 +845,8 @@ pub fn fexecve(fd: RawFd, args: &[CString], env: &[CString]) -> Result<Void> {
 /// is referenced as a file descriptor to the base directory plus a path.
 #[cfg(any(target_os = "android", target_os = "linux"))]
 #[inline]
-pub fn execveat(dirfd: RawFd, pathname: &CString, args: &[CString],
-                env: &[CString], flags: super::fcntl::AtFlags) -> Result<Void> {
+pub fn execveat<SA: AsRef<CStr>,SE: AsRef<CStr>>(dirfd: RawFd, pathname: &CStr, args: &[SA],
+                env: &[SE], flags: super::fcntl::AtFlags) -> Result<Infallible> {
     let args_p = to_exec_array(args);
     let env_p = to_exec_array(env);
 
@@ -800,11 +855,11 @@ pub fn execveat(dirfd: RawFd, pathname: &CString, args: &[CString],
                       args_p.as_ptr(), env_p.as_ptr(), flags);
     };
 
-    Err(Error::Sys(Errno::last()))
+    Err(Errno::last())
 }
 
 /// Daemonize this process by detaching from the controlling terminal (see
-/// [daemon(3)](http://man7.org/linux/man-pages/man3/daemon.3.html)).
+/// [daemon(3)](https://man7.org/linux/man-pages/man3/daemon.3.html)).
 ///
 /// When a process is launched it is typically associated with a parent and it,
 /// in turn, by its controlling terminal/process.  In order for a process to run
@@ -828,30 +883,36 @@ pub fn execveat(dirfd: RawFd, pathname: &CString, args: &[CString],
 ///   descriptors will remain identical after daemonizing.
 /// * `noclose = false`: The process' stdin, stdout, and stderr will point to
 ///   `/dev/null` after daemonizing.
-#[cfg_attr(any(target_os = "macos", target_os = "ios"), deprecated(
-    since="0.14.0",
-    note="Deprecated in MacOSX 10.5"
-))]
-#[cfg_attr(any(target_os = "macos", target_os = "ios"), allow(deprecated))]
+#[cfg(any(target_os = "android",
+          target_os = "dragonfly",
+          target_os = "freebsd",
+          target_os = "illumos",
+          target_os = "linux",
+          target_os = "netbsd",
+          target_os = "openbsd",
+          target_os = "solaris"))]
 pub fn daemon(nochdir: bool, noclose: bool) -> Result<()> {
     let res = unsafe { libc::daemon(nochdir as c_int, noclose as c_int) };
     Errno::result(res).map(drop)
 }
 
 /// Set the system host name (see
-/// [sethostname(2)](http://man7.org/linux/man-pages/man2/gethostname.2.html)).
+/// [sethostname(2)](https://man7.org/linux/man-pages/man2/gethostname.2.html)).
 ///
 /// Given a name, attempt to update the system host name to the given string.
 /// On some systems, the host name is limited to as few as 64 bytes.  An error
 /// will be return if the name is not valid or the current process does not have
 /// permissions to update the host name.
+#[cfg(not(target_os = "redox"))]
 pub fn sethostname<S: AsRef<OsStr>>(name: S) -> Result<()> {
     // Handle some differences in type of the len arg across platforms.
     cfg_if! {
         if #[cfg(any(target_os = "dragonfly",
                      target_os = "freebsd",
+                     target_os = "illumos",
                      target_os = "ios",
-                     target_os = "macos", ))] {
+                     target_os = "macos",
+                     target_os = "solaris", ))] {
             type sethostname_len_t = c_int;
         } else {
             type sethostname_len_t = size_t;
@@ -866,7 +927,7 @@ pub fn sethostname<S: AsRef<OsStr>>(name: S) -> Result<()> {
 
 /// Get the host name and store it in the provided buffer, returning a pointer
 /// the `CStr` in that buffer on success (see
-/// [gethostname(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/gethostname.html)).
+/// [gethostname(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/gethostname.html)).
 ///
 /// This function call attempts to get the host name for the running system and
 /// store it in a provided buffer.  The buffer will be populated with bytes up
@@ -901,34 +962,24 @@ pub fn gethostname(buffer: &mut [u8]) -> Result<&CStr> {
 /// `std::fs::File`.  Explicitly closing them with this method too can result in
 /// a double-close condition, which can cause confusing `EBADF` errors in
 /// seemingly unrelated code.  Caveat programmer.  See also
-/// [close(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/close.html).
+/// [close(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/close.html).
 ///
 /// # Examples
 ///
 /// ```no_run
-/// extern crate tempfile;
-/// extern crate nix;
-///
 /// use std::os::unix::io::AsRawFd;
 /// use nix::unistd::close;
 ///
-/// fn main() {
-///     let f = tempfile::tempfile().unwrap();
-///     close(f.as_raw_fd()).unwrap();   // Bad!  f will also close on drop!
-/// }
+/// let f = tempfile::tempfile().unwrap();
+/// close(f.as_raw_fd()).unwrap();   // Bad!  f will also close on drop!
 /// ```
 ///
 /// ```rust
-/// extern crate tempfile;
-/// extern crate nix;
-///
 /// use std::os::unix::io::IntoRawFd;
 /// use nix::unistd::close;
 ///
-/// fn main() {
-///     let f = tempfile::tempfile().unwrap();
-///     close(f.into_raw_fd()).unwrap(); // Good.  into_raw_fd consumes f
-/// }
+/// let f = tempfile::tempfile().unwrap();
+/// close(f.into_raw_fd()).unwrap(); // Good.  into_raw_fd consumes f
 /// ```
 pub fn close(fd: RawFd) -> Result<()> {
     let res = unsafe { libc::close(fd) };
@@ -937,7 +988,7 @@ pub fn close(fd: RawFd) -> Result<()> {
 
 /// Read from a raw file descriptor.
 ///
-/// See also [read(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/read.html)
+/// See also [read(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/read.html)
 pub fn read(fd: RawFd, buf: &mut [u8]) -> Result<usize> {
     let res = unsafe { libc::read(fd, buf.as_mut_ptr() as *mut c_void, buf.len() as size_t) };
 
@@ -946,7 +997,7 @@ pub fn read(fd: RawFd, buf: &mut [u8]) -> Result<usize> {
 
 /// Write to a raw file descriptor.
 ///
-/// See also [write(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html)
+/// See also [write(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html)
 pub fn write(fd: RawFd, buf: &[u8]) -> Result<usize> {
     let res = unsafe { libc::write(fd, buf.as_ptr() as *const c_void, buf.len() as size_t) };
 
@@ -969,26 +1020,28 @@ pub enum Whence {
     /// Specify an offset relative to the next location in the file greater than or
     /// equal to offset that contains some data. If offset points to
     /// some data, then the file offset is set to offset.
-    #[cfg(any(target_os = "dragonfly", target_os = "freebsd",
-          all(target_os = "linux", not(any(target_env = "musl",
-                                           target_arch = "mips",
-                                           target_arch = "mips64")))))]
+    #[cfg(any(target_os = "dragonfly",
+              target_os = "freebsd",
+              target_os = "illumos",
+              target_os = "linux",
+              target_os = "solaris"))]
     SeekData = libc::SEEK_DATA,
     /// Specify an offset relative to the next hole in the file greater than
     /// or equal to offset. If offset points into the middle of a hole, then
     /// the file offset should be set to offset. If there is no hole past offset,
     /// then the file offset should be adjusted to the end of the file (i.e., there
     /// is an implicit hole at the end of any file).
-    #[cfg(any(target_os = "dragonfly", target_os = "freebsd",
-          all(target_os = "linux", not(any(target_env = "musl",
-                                           target_arch = "mips",
-                                           target_arch = "mips64")))))]
+    #[cfg(any(target_os = "dragonfly",
+              target_os = "freebsd",
+              target_os = "illumos",
+              target_os = "linux",
+              target_os = "solaris"))]
     SeekHole = libc::SEEK_HOLE
 }
 
 /// Move the read/write file offset.
 ///
-/// See also [lseek(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/lseek.html)
+/// See also [lseek(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/lseek.html)
 pub fn lseek(fd: RawFd, offset: off_t, whence: Whence) -> Result<off_t> {
     let res = unsafe { libc::lseek(fd, offset, whence as i32) };
 
@@ -1004,16 +1057,16 @@ pub fn lseek64(fd: RawFd, offset: libc::off64_t, whence: Whence) -> Result<libc:
 
 /// Create an interprocess channel.
 ///
-/// See also [pipe(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/pipe.html)
-pub fn pipe() -> Result<(RawFd, RawFd)> {
+/// See also [pipe(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pipe.html)
+pub fn pipe() -> std::result::Result<(RawFd, RawFd), Error> {
     unsafe {
-        let mut fds: [c_int; 2] = mem::uninitialized();
+        let mut fds = mem::MaybeUninit::<[c_int; 2]>::uninit();
 
-        let res = libc::pipe(fds.as_mut_ptr());
+        let res = libc::pipe(fds.as_mut_ptr() as *mut c_int);
 
-        Errno::result(res)?;
+        Error::result(res)?;
 
-        Ok((fds[0], fds[1]))
+        Ok((fds.assume_init()[0], fds.assume_init()[1]))
     }
 }
 
@@ -1022,83 +1075,39 @@ pub fn pipe() -> Result<(RawFd, RawFd)> {
 /// The following flags are supported, and will be set atomically as the pipe is
 /// created:
 ///
-/// `O_CLOEXEC`:    Set the close-on-exec flag for the new file descriptors.
-/// `O_NONBLOCK`:   Set the non-blocking flag for the ends of the pipe.
+/// - `O_CLOEXEC`:    Set the close-on-exec flag for the new file descriptors.
+#[cfg_attr(target_os = "linux", doc = "- `O_DIRECT`: Create a pipe that performs I/O in \"packet\" mode.")]
+#[cfg_attr(target_os = "netbsd", doc = "- `O_NOSIGPIPE`: Return `EPIPE` instead of raising `SIGPIPE`.")]
+/// - `O_NONBLOCK`:   Set the non-blocking flag for the ends of the pipe.
 ///
-/// See also [pipe(2)](http://man7.org/linux/man-pages/man2/pipe.2.html)
+/// See also [pipe(2)](https://man7.org/linux/man-pages/man2/pipe.2.html)
 #[cfg(any(target_os = "android",
           target_os = "dragonfly",
           target_os = "emscripten",
           target_os = "freebsd",
+          target_os = "illumos",
           target_os = "linux",
+          target_os = "redox",
           target_os = "netbsd",
-          target_os = "openbsd"))]
+          target_os = "openbsd",
+          target_os = "solaris"))]
 pub fn pipe2(flags: OFlag) -> Result<(RawFd, RawFd)> {
-    let mut fds: [c_int; 2] = unsafe { mem::uninitialized() };
-
-    let res = unsafe { libc::pipe2(fds.as_mut_ptr(), flags.bits()) };
-
-    Errno::result(res)?;
+    let mut fds = mem::MaybeUninit::<[c_int; 2]>::uninit();
 
-    Ok((fds[0], fds[1]))
-}
-
-/// Like `pipe`, but allows setting certain file descriptor flags.
-///
-/// The following flags are supported, and will be set after the pipe is
-/// created:
-///
-/// `O_CLOEXEC`:    Set the close-on-exec flag for the new file descriptors.
-/// `O_NONBLOCK`:   Set the non-blocking flag for the ends of the pipe.
-#[cfg(any(target_os = "ios", target_os = "macos"))]
-#[deprecated(
-    since="0.10.0",
-    note="pipe2(2) is not actually atomic on these platforms.  Use pipe(2) and fcntl(2) instead"
-)]
-pub fn pipe2(flags: OFlag) -> Result<(RawFd, RawFd)> {
-    let mut fds: [c_int; 2] = unsafe { mem::uninitialized() };
-
-    let res = unsafe { libc::pipe(fds.as_mut_ptr()) };
+    let res = unsafe {
+        libc::pipe2(fds.as_mut_ptr() as *mut c_int, flags.bits())
+    };
 
     Errno::result(res)?;
 
-    pipe2_setflags(fds[0], fds[1], flags)?;
-
-    Ok((fds[0], fds[1]))
-}
-
-#[cfg(any(target_os = "ios", target_os = "macos"))]
-fn pipe2_setflags(fd1: RawFd, fd2: RawFd, flags: OFlag) -> Result<()> {
-    use fcntl::FcntlArg::F_SETFL;
-
-    let mut res = Ok(0);
-
-    if flags.contains(OFlag::O_CLOEXEC) {
-        res = res
-            .and_then(|_| fcntl(fd1, F_SETFD(FdFlag::FD_CLOEXEC)))
-            .and_then(|_| fcntl(fd2, F_SETFD(FdFlag::FD_CLOEXEC)));
-    }
-
-    if flags.contains(OFlag::O_NONBLOCK) {
-        res = res
-            .and_then(|_| fcntl(fd1, F_SETFL(OFlag::O_NONBLOCK)))
-            .and_then(|_| fcntl(fd2, F_SETFL(OFlag::O_NONBLOCK)));
-    }
-
-    match res {
-        Ok(_) => Ok(()),
-        Err(e) => {
-            let _ = close(fd1);
-            let _ = close(fd2);
-            Err(e)
-        }
-    }
+    unsafe { Ok((fds.assume_init()[0], fds.assume_init()[1])) }
 }
 
 /// Truncate a file to a specified length
 ///
 /// See also
-/// [truncate(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/truncate.html)
+/// [truncate(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/truncate.html)
+#[cfg(not(any(target_os = "redox", target_os = "fuchsia")))]
 pub fn truncate<P: ?Sized + NixPath>(path: &P, len: off_t) -> Result<()> {
     let res = path.with_nix_path(|cstr| {
         unsafe {
@@ -1112,7 +1121,7 @@ pub fn truncate<P: ?Sized + NixPath>(path: &P, len: off_t) -> Result<()> {
 /// Truncate a file to a specified length
 ///
 /// See also
-/// [ftruncate(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/ftruncate.html)
+/// [ftruncate(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/ftruncate.html)
 pub fn ftruncate(fd: RawFd, len: off_t) -> Result<()> {
     Errno::result(unsafe { libc::ftruncate(fd, len) }).map(drop)
 }
@@ -1126,15 +1135,68 @@ pub fn isatty(fd: RawFd) -> Result<bool> {
         } else {
             match Errno::last() {
                 Errno::ENOTTY => Ok(false),
-                err => Err(Error::Sys(err)),
+                err => Err(err),
             }
-        }
+       }
     }
 }
 
+/// Flags for `linkat` function.
+#[derive(Clone, Copy, Debug)]
+pub enum LinkatFlags {
+    SymlinkFollow,
+    NoSymlinkFollow,
+}
+
+/// Link one file to another file
+///
+/// Creates a new link (directory entry) at `newpath` for the existing file at `oldpath`. In the
+/// case of a relative `oldpath`, the path is interpreted relative to the directory associated
+/// with file descriptor `olddirfd` instead of the current working directory and similiarly for
+/// `newpath` and file descriptor `newdirfd`. In case `flag` is LinkatFlags::SymlinkFollow and
+/// `oldpath` names a symoblic link, a new link for the target of the symbolic link is created.
+/// If either `olddirfd` or `newdirfd` is `None`, `AT_FDCWD` is used respectively where `oldpath`
+/// and/or `newpath` is then interpreted relative to the current working directory of the calling
+/// process. If either `oldpath` or `newpath` is absolute, then `dirfd` is ignored.
+///
+/// # References
+/// See also [linkat(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/linkat.html)
+#[cfg(not(target_os = "redox"))] // RedoxFS does not support symlinks yet
+pub fn linkat<P: ?Sized + NixPath>(
+    olddirfd: Option<RawFd>,
+    oldpath: &P,
+    newdirfd: Option<RawFd>,
+    newpath: &P,
+    flag: LinkatFlags,
+) -> Result<()> {
+
+    let atflag =
+        match flag {
+            LinkatFlags::SymlinkFollow => AtFlags::AT_SYMLINK_FOLLOW,
+            LinkatFlags::NoSymlinkFollow => AtFlags::empty(),
+        };
+
+    let res =
+        oldpath.with_nix_path(|oldcstr| {
+            newpath.with_nix_path(|newcstr| {
+            unsafe {
+                libc::linkat(
+                    at_rawfd(olddirfd),
+                    oldcstr.as_ptr(),
+                    at_rawfd(newdirfd),
+                    newcstr.as_ptr(),
+                    atflag.bits() as libc::c_int
+                    )
+                }
+            })
+        })??;
+    Errno::result(res).map(drop)
+}
+
+
 /// Remove a directory entry
 ///
-/// See also [unlink(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/unlink.html)
+/// See also [unlink(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/unlink.html)
 pub fn unlink<P: ?Sized + NixPath>(path: &P) -> Result<()> {
     let res = path.with_nix_path(|cstr| {
         unsafe {
@@ -1160,7 +1222,8 @@ pub enum UnlinkatFlags {
 /// is performed.
 ///
 /// # References
-/// See also [unlinkat(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/unlinkat.html)
+/// See also [unlinkat(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/unlinkat.html)
+#[cfg(not(target_os = "redox"))]
 pub fn unlinkat<P: ?Sized + NixPath>(
     dirfd: Option<RawFd>,
     path: &P,
@@ -1181,6 +1244,7 @@ pub fn unlinkat<P: ?Sized + NixPath>(
 
 
 #[inline]
+#[cfg(not(target_os = "fuchsia"))]
 pub fn chroot<P: ?Sized + NixPath>(path: &P) -> Result<()> {
     let res = path.with_nix_path(|cstr| {
         unsafe { libc::chroot(cstr.as_ptr()) }
@@ -1191,7 +1255,7 @@ pub fn chroot<P: ?Sized + NixPath>(path: &P) -> Result<()> {
 
 /// Commit filesystem caches to disk
 ///
-/// See also [sync(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/sync.html)
+/// See also [sync(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/sync.html)
 #[cfg(any(
     target_os = "dragonfly",
     target_os = "freebsd",
@@ -1199,13 +1263,13 @@ pub fn chroot<P: ?Sized + NixPath>(path: &P) -> Result<()> {
     target_os = "netbsd",
     target_os = "openbsd"
 ))]
-pub fn sync() -> () {
+pub fn sync() {
     unsafe { libc::sync() };
 }
 
 /// Synchronize changes to a file
 ///
-/// See also [fsync(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fsync.html)
+/// See also [fsync(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fsync.html)
 #[inline]
 pub fn fsync(fd: RawFd) -> Result<()> {
     let res = unsafe { libc::fsync(fd) };
@@ -1216,12 +1280,14 @@ pub fn fsync(fd: RawFd) -> Result<()> {
 /// Synchronize the data of a file
 ///
 /// See also
-/// [fdatasync(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/fdatasync.html)
+/// [fdatasync(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fdatasync.html)
 // `fdatasync(2) is in POSIX, but in libc it is only defined in `libc::notbsd`.
 // TODO: exclude only Apple systems after https://github.com/rust-lang/libc/pull/211
 #[cfg(any(target_os = "linux",
           target_os = "android",
-          target_os = "emscripten"))]
+          target_os = "emscripten",
+          target_os = "illumos",
+          target_os = "solaris"))]
 #[inline]
 pub fn fdatasync(fd: RawFd) -> Result<()> {
     let res = unsafe { libc::fdatasync(fd) };
@@ -1231,7 +1297,7 @@ pub fn fdatasync(fd: RawFd) -> Result<()> {
 
 /// Get a real user ID
 ///
-/// See also [getuid(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/getuid.html)
+/// See also [getuid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getuid.html)
 // POSIX requires that getuid is always successful, so no need to check return
 // value or errno.
 #[inline]
@@ -1241,7 +1307,7 @@ pub fn getuid() -> Uid {
 
 /// Get the effective user ID
 ///
-/// See also [geteuid(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/geteuid.html)
+/// See also [geteuid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/geteuid.html)
 // POSIX requires that geteuid is always successful, so no need to check return
 // value or errno.
 #[inline]
@@ -1251,7 +1317,7 @@ pub fn geteuid() -> Uid {
 
 /// Get the real group ID
 ///
-/// See also [getgid(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/getgid.html)
+/// See also [getgid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getgid.html)
 // POSIX requires that getgid is always successful, so no need to check return
 // value or errno.
 #[inline]
@@ -1261,7 +1327,7 @@ pub fn getgid() -> Gid {
 
 /// Get the effective group ID
 ///
-/// See also [getegid(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/getegid.html)
+/// See also [getegid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getegid.html)
 // POSIX requires that getegid is always successful, so no need to check return
 // value or errno.
 #[inline]
@@ -1271,7 +1337,7 @@ pub fn getegid() -> Gid {
 
 /// Set the effective user ID
 ///
-/// See also [seteuid(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/seteuid.html)
+/// See also [seteuid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/seteuid.html)
 #[inline]
 pub fn seteuid(euid: Uid) -> Result<()> {
     let res = unsafe { libc::seteuid(euid.into()) };
@@ -1281,7 +1347,7 @@ pub fn seteuid(euid: Uid) -> Result<()> {
 
 /// Set the effective group ID
 ///
-/// See also [setegid(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/setegid.html)
+/// See also [setegid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/setegid.html)
 #[inline]
 pub fn setegid(egid: Gid) -> Result<()> {
     let res = unsafe { libc::setegid(egid.into()) };
@@ -1291,7 +1357,7 @@ pub fn setegid(egid: Gid) -> Result<()> {
 
 /// Set the user ID
 ///
-/// See also [setuid(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/setuid.html)
+/// See also [setuid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/setuid.html)
 #[inline]
 pub fn setuid(uid: Uid) -> Result<()> {
     let res = unsafe { libc::setuid(uid.into()) };
@@ -1301,7 +1367,7 @@ pub fn setuid(uid: Uid) -> Result<()> {
 
 /// Set the group ID
 ///
-/// See also [setgid(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/setgid.html)
+/// See also [setgid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/setgid.html)
 #[inline]
 pub fn setgid(gid: Gid) -> Result<()> {
     let res = unsafe { libc::setgid(gid.into()) };
@@ -1309,42 +1375,78 @@ pub fn setgid(gid: Gid) -> Result<()> {
     Errno::result(res).map(drop)
 }
 
+/// Set the user identity used for filesystem checks per-thread.
+/// On both success and failure, this call returns the previous filesystem user
+/// ID of the caller.
+///
+/// See also [setfsuid(2)](https://man7.org/linux/man-pages/man2/setfsuid.2.html)
+#[cfg(any(target_os = "linux", target_os = "android"))]
+pub fn setfsuid(uid: Uid) -> Uid {
+    let prev_fsuid = unsafe { libc::setfsuid(uid.into()) };
+    Uid::from_raw(prev_fsuid as uid_t)
+}
+
+/// Set the group identity used for filesystem checks per-thread.
+/// On both success and failure, this call returns the previous filesystem group
+/// ID of the caller.
+///
+/// See also [setfsgid(2)](https://man7.org/linux/man-pages/man2/setfsgid.2.html)
+#[cfg(any(target_os = "linux", target_os = "android"))]
+pub fn setfsgid(gid: Gid) -> Gid {
+    let prev_fsgid = unsafe { libc::setfsgid(gid.into()) };
+    Gid::from_raw(prev_fsgid as gid_t)
+}
+
 /// Get the list of supplementary group IDs of the calling process.
 ///
-/// [Further reading](http://pubs.opengroup.org/onlinepubs/009695399/functions/getgroups.html)
+/// [Further reading](https://pubs.opengroup.org/onlinepubs/009695399/functions/getgroups.html)
 ///
 /// **Note:** This function is not available for Apple platforms. On those
 /// platforms, checking group membership should be achieved via communication
 /// with the `opendirectoryd` service.
 #[cfg(not(any(target_os = "ios", target_os = "macos")))]
 pub fn getgroups() -> Result<Vec<Gid>> {
-    // First get the number of groups so we can size our Vec
-    let ret = unsafe { libc::getgroups(0, ptr::null_mut()) };
+    // First get the maximum number of groups. The value returned
+    // shall always be greater than or equal to one and less than or
+    // equal to the value of {NGROUPS_MAX} + 1.
+    let ngroups_max = match sysconf(SysconfVar::NGROUPS_MAX) {
+        Ok(Some(n)) => (n + 1) as usize,
+        Ok(None) | Err(_) => <usize>::max_value(),
+    };
+
+    // Next, get the number of groups so we can size our Vec
+    let ngroups = unsafe { libc::getgroups(0, ptr::null_mut()) };
+
+    // If there are no supplementary groups, return early.
+    // This prevents a potential buffer over-read if the number of groups
+    // increases from zero before the next call. It would return the total
+    // number of groups beyond the capacity of the buffer.
+    if ngroups == 0 {
+        return Ok(Vec::new());
+    }
 
     // Now actually get the groups. We try multiple times in case the number of
     // groups has changed since the first call to getgroups() and the buffer is
     // now too small.
-    let mut groups = Vec::<Gid>::with_capacity(Errno::result(ret)? as usize);
+    let mut groups = Vec::<Gid>::with_capacity(Errno::result(ngroups)? as usize);
     loop {
         // FIXME: On the platforms we currently support, the `Gid` struct has
         // the same representation in memory as a bare `gid_t`. This is not
         // necessarily the case on all Rust platforms, though. See RFC 1785.
-        let ret = unsafe {
+        let ngroups = unsafe {
             libc::getgroups(groups.capacity() as c_int, groups.as_mut_ptr() as *mut gid_t)
         };
 
-        match Errno::result(ret) {
+        match Errno::result(ngroups) {
             Ok(s) => {
                 unsafe { groups.set_len(s as usize) };
                 return Ok(groups);
             },
-            Err(Error::Sys(Errno::EINVAL)) => {
-                // EINVAL indicates that the buffer size was too small. Trigger
-                // the internal buffer resizing logic of `Vec` by requiring
-                // more space than the current capacity.
-                let cap = groups.capacity();
-                unsafe { groups.set_len(cap) };
-                groups.reserve(1);
+            Err(Errno::EINVAL) => {
+                // EINVAL indicates that the buffer size was too
+                // small, resize it up to ngroups_max as limit.
+                reserve_double_buffer_size(&mut groups, ngroups_max)
+                    .or(Err(Errno::EINVAL))?;
             },
             Err(e) => return Err(e)
         }
@@ -1353,7 +1455,7 @@ pub fn getgroups() -> Result<Vec<Gid>> {
 
 /// Set the list of supplementary group IDs for the calling process.
 ///
-/// [Further reading](http://man7.org/linux/man-pages/man2/getgroups.2.html)
+/// [Further reading](https://man7.org/linux/man-pages/man2/getgroups.2.html)
 ///
 /// **Note:** This function is not available for Apple platforms. On those
 /// platforms, group membership management should be achieved via communication
@@ -1380,18 +1482,18 @@ pub fn getgroups() -> Result<Vec<Gid>> {
 /// #     Ok(())
 /// # }
 /// #
-/// # fn main() {
-/// #     try_main().unwrap();
-/// # }
+/// # try_main().unwrap();
 /// ```
-#[cfg(not(any(target_os = "ios", target_os = "macos")))]
+#[cfg(not(any(target_os = "ios", target_os = "macos", target_os = "redox")))]
 pub fn setgroups(groups: &[Gid]) -> Result<()> {
     cfg_if! {
         if #[cfg(any(target_os = "dragonfly",
                      target_os = "freebsd",
+                     target_os = "illumos",
                      target_os = "ios",
                      target_os = "macos",
                      target_os = "netbsd",
+                     target_os = "illumos",
                      target_os = "openbsd"))] {
             type setgroups_ngroups_t = c_int;
         } else {
@@ -1413,7 +1515,7 @@ pub fn setgroups(groups: &[Gid]) -> Result<()> {
 /// Gets the group IDs of all groups that `user` is a member of. The additional
 /// group `group` is also added to the list.
 ///
-/// [Further reading](http://man7.org/linux/man-pages/man3/getgrouplist.3.html)
+/// [Further reading](https://man7.org/linux/man-pages/man3/getgrouplist.3.html)
 ///
 /// **Note:** This function is not available for Apple platforms. On those
 /// platforms, checking group membership should be achieved via communication
@@ -1428,15 +1530,17 @@ pub fn setgroups(groups: &[Gid]) -> Result<()> {
 /// and `setgroups()`. Additionally, while some implementations will return a
 /// partial list of groups when `NGROUPS_MAX` is exceeded, this implementation
 /// will only ever return the complete list or else an error.
-#[cfg(not(any(target_os = "ios", target_os = "macos")))]
+#[cfg(not(any(target_os = "illumos",
+              target_os = "ios",
+              target_os = "macos",
+              target_os = "redox")))]
 pub fn getgrouplist(user: &CStr, group: Gid) -> Result<Vec<Gid>> {
     let ngroups_max = match sysconf(SysconfVar::NGROUPS_MAX) {
         Ok(Some(n)) => n as c_int,
         Ok(None) | Err(_) => <c_int>::max_value(),
     };
     use std::cmp::min;
-    let mut ngroups = min(ngroups_max, 8);
-    let mut groups = Vec::<Gid>::with_capacity(ngroups as usize);
+    let mut groups = Vec::<Gid>::with_capacity(min(ngroups_max, 8) as usize);
     cfg_if! {
         if #[cfg(any(target_os = "ios", target_os = "macos"))] {
             type getgrouplist_group_t = c_int;
@@ -1446,6 +1550,7 @@ pub fn getgrouplist(user: &CStr, group: Gid) -> Result<Vec<Gid>> {
     }
     let gid: gid_t = group.into();
     loop {
+        let mut ngroups = groups.capacity() as i32;
         let ret = unsafe {
             libc::getgrouplist(user.as_ptr(),
                                gid as getgrouplist_group_t,
@@ -1462,19 +1567,8 @@ pub fn getgrouplist(user: &CStr, group: Gid) -> Result<Vec<Gid>> {
             // BSD systems will still fill the groups buffer with as many
             // groups as possible, but Linux manpages do not mention this
             // behavior.
-
-            let cap = groups.capacity();
-            if cap >= ngroups_max as usize {
-                // We already have the largest capacity we can, give up
-                return Err(Error::invalid_argument());
-            }
-
-            // Reserve space for at least ngroups
-            groups.reserve(ngroups as usize);
-
-            // Even if the buffer gets resized to bigger than ngroups_max,
-            // don't ever ask for more than ngroups_max groups
-            ngroups = min(ngroups_max, groups.capacity() as c_int);
+            reserve_double_buffer_size(&mut groups, ngroups_max as usize)
+                .map_err(|_| Errno::EINVAL)?;
         }
     }
 }
@@ -1485,7 +1579,7 @@ pub fn getgrouplist(user: &CStr, group: Gid) -> Result<Vec<Gid>> {
 /// that `user` is a member of. The additional group `group` is also added to
 /// the list.
 ///
-/// [Further reading](http://man7.org/linux/man-pages/man3/initgroups.3.html)
+/// [Further reading](https://man7.org/linux/man-pages/man3/initgroups.3.html)
 ///
 /// **Note:** This function is not available for Apple platforms. On those
 /// platforms, group membership management should be achieved via communication
@@ -1515,11 +1609,9 @@ pub fn getgrouplist(user: &CStr, group: Gid) -> Result<Vec<Gid>> {
 /// #     Ok(())
 /// # }
 /// #
-/// # fn main() {
-/// #     try_main().unwrap();
-/// # }
+/// # try_main().unwrap();
 /// ```
-#[cfg(not(any(target_os = "ios", target_os = "macos")))]
+#[cfg(not(any(target_os = "ios", target_os = "macos", target_os = "redox")))]
 pub fn initgroups(user: &CStr, group: Gid) -> Result<()> {
     cfg_if! {
         if #[cfg(any(target_os = "ios", target_os = "macos"))] {
@@ -1536,8 +1628,9 @@ pub fn initgroups(user: &CStr, group: Gid) -> Result<()> {
 
 /// Suspend the thread until a signal is received.
 ///
-/// See also [pause(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/pause.html).
+/// See also [pause(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pause.html).
 #[inline]
+#[cfg(not(target_os = "redox"))]
 pub fn pause() {
     unsafe { libc::pause() };
 }
@@ -1568,7 +1661,8 @@ pub mod alarm {
     //!
     //! Scheduling an alarm and waiting for the signal:
     //!
-    //! ```
+#![cfg_attr(target_os = "redox", doc = " ```rust,ignore")]
+#![cfg_attr(not(target_os = "redox"), doc = " ```rust")]
     //! use std::time::{Duration, Instant};
     //!
     //! use nix::unistd::{alarm, pause};
@@ -1577,23 +1671,31 @@ pub mod alarm {
     //! // We need to setup an empty signal handler to catch the alarm signal,
     //! // otherwise the program will be terminated once the signal is delivered.
     //! extern fn signal_handler(_: nix::libc::c_int) { }
-    //! unsafe { sigaction(Signal::SIGALRM, &SigAction::new(SigHandler::Handler(signal_handler), SaFlags::empty(), SigSet::empty())); }
+    //! let sa = SigAction::new(
+    //!     SigHandler::Handler(signal_handler),
+    //!     SaFlags::SA_RESTART,
+    //!     SigSet::empty()
+    //! );
+    //! unsafe {
+    //!     sigaction(Signal::SIGALRM, &sa);
+    //! }
+    //!
+    //! let start = Instant::now();
     //!
     //! // Set an alarm for 1 second from now.
     //! alarm::set(1);
     //!
-    //! let start = Instant::now();
     //! // Pause the process until the alarm signal is received.
-    //! pause();
+    //! let mut sigset = SigSet::empty();
+    //! sigset.add(Signal::SIGALRM);
+    //! sigset.wait();
     //!
     //! assert!(start.elapsed() >= Duration::from_secs(1));
     //! ```
     //!
     //! # References
     //!
-    //! See also [alarm(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/alarm.html).
-
-    use libc;
+    //! See also [alarm(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/alarm.html).
 
     /// Schedule an alarm signal.
     ///
@@ -1623,17 +1725,17 @@ pub mod alarm {
 
 /// Suspend execution for an interval of time
 ///
-/// See also [sleep(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/sleep.html#tag_03_705_05)
+/// See also [sleep(2)](https://pubs.opengroup.org/onlinepubs/009695399/functions/sleep.html#tag_03_705_05)
 // Per POSIX, does not fail
 #[inline]
 pub fn sleep(seconds: c_uint) -> c_uint {
     unsafe { libc::sleep(seconds) }
 }
 
+#[cfg(not(target_os = "redox"))]
 pub mod acct {
-    use libc;
-    use {Result, NixPath};
-    use errno::Errno;
+    use crate::{Result, NixPath};
+    use crate::errno::Errno;
     use std::ptr;
 
     /// Enable process accounting
@@ -1663,7 +1765,7 @@ pub mod acct {
 /// Err is returned either if no temporary filename could be created or the template doesn't
 /// end with XXXXXX
 ///
-/// See also [mkstemp(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkstemp.html)
+/// See also [mkstemp(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkstemp.html)
 ///
 /// # Example
 ///
@@ -1694,7 +1796,7 @@ pub fn mkstemp<P: ?Sized + NixPath>(template: &P) -> Result<(RawFd, PathBuf)> {
 /// Variable names for `pathconf`
 ///
 /// Nix uses the same naming convention for these variables as the
-/// [getconf(1)](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/getconf.html) utility.
+/// [getconf(1)](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/getconf.html) utility.
 /// That is, `PathconfVar` variables have the same name as the abstract
 /// variables  shown in the `pathconf(2)` man page.  Usually, it's the same as
 /// the C variable name without the leading `_PC_`.
@@ -1704,14 +1806,15 @@ pub fn mkstemp<P: ?Sized + NixPath>(template: &P) -> Result<(RawFd, PathBuf)> {
 ///
 /// # References
 ///
-/// - [pathconf(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/pathconf.html)
-/// - [limits.h](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/limits.h.html)
-/// - [unistd.h](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/unistd.h.html)
+/// - [pathconf(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pathconf.html)
+/// - [limits.h](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/limits.h.html)
+/// - [unistd.h](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/unistd.h.html)
 #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
 #[repr(i32)]
+#[non_exhaustive]
 pub enum PathconfVar {
     #[cfg(any(target_os = "dragonfly", target_os = "freebsd", target_os = "linux",
-              target_os = "netbsd", target_os = "openbsd"))]
+              target_os = "netbsd", target_os = "openbsd", target_os = "redox"))]
     /// Minimum number of bits needed to represent, as a signed integer value,
     /// the maximum size of a regular file allowed in the specified directory.
     FILESIZEBITS = libc::_PC_FILESIZEBITS,
@@ -1734,12 +1837,13 @@ pub enum PathconfVar {
     /// Maximum number of bytes that is guaranteed to be atomic when writing to
     /// a pipe.
     PIPE_BUF = libc::_PC_PIPE_BUF,
-    #[cfg(any(target_os = "android", target_os = "dragonfly", target_os = "linux",
-              target_os = "netbsd", target_os = "openbsd"))]
+    #[cfg(any(target_os = "android", target_os = "dragonfly", target_os = "illumos",
+              target_os = "linux", target_os = "netbsd", target_os = "openbsd",
+              target_os = "redox", target_os = "solaris"))]
     /// Symbolic links can be created.
     POSIX2_SYMLINKS = libc::_PC_2_SYMLINKS,
     #[cfg(any(target_os = "android", target_os = "dragonfly", target_os = "freebsd",
-              target_os = "linux", target_os = "openbsd"))]
+              target_os = "linux", target_os = "openbsd", target_os = "redox"))]
     /// Minimum number of bytes of storage actually allocated for any portion of
     /// a file.
     POSIX_ALLOC_SIZE_MIN = libc::_PC_ALLOC_SIZE_MIN,
@@ -1749,19 +1853,20 @@ pub enum PathconfVar {
     /// `POSIX_REC_MIN_XFER_SIZE` and `POSIX_REC_MAX_XFER_SIZE` values.
     POSIX_REC_INCR_XFER_SIZE = libc::_PC_REC_INCR_XFER_SIZE,
     #[cfg(any(target_os = "android", target_os = "dragonfly", target_os = "freebsd",
-              target_os = "linux", target_os = "openbsd"))]
+              target_os = "linux", target_os = "openbsd", target_os = "redox"))]
     /// Maximum recommended file transfer size.
     POSIX_REC_MAX_XFER_SIZE = libc::_PC_REC_MAX_XFER_SIZE,
     #[cfg(any(target_os = "android", target_os = "dragonfly", target_os = "freebsd",
-              target_os = "linux", target_os = "openbsd"))]
+              target_os = "linux", target_os = "openbsd", target_os = "redox"))]
     /// Minimum recommended file transfer size.
     POSIX_REC_MIN_XFER_SIZE = libc::_PC_REC_MIN_XFER_SIZE,
     #[cfg(any(target_os = "android", target_os = "dragonfly", target_os = "freebsd",
-              target_os = "linux", target_os = "openbsd"))]
+              target_os = "linux", target_os = "openbsd", target_os = "redox"))]
     ///  Recommended file transfer buffer alignment.
     POSIX_REC_XFER_ALIGN = libc::_PC_REC_XFER_ALIGN,
     #[cfg(any(target_os = "android", target_os = "dragonfly", target_os = "freebsd",
-              target_os = "linux", target_os = "netbsd", target_os = "openbsd"))]
+              target_os = "illumos", target_os = "linux", target_os = "netbsd",
+              target_os = "openbsd", target_os = "redox", target_os = "solaris"))]
     /// Maximum number of bytes in a symbolic link.
     SYMLINK_MAX = libc::_PC_SYMLINK_MAX,
     /// The use of `chown` and `fchown` is restricted to a process with
@@ -1775,17 +1880,20 @@ pub enum PathconfVar {
     /// disable terminal special character handling.
     _POSIX_VDISABLE = libc::_PC_VDISABLE,
     #[cfg(any(target_os = "android", target_os = "dragonfly", target_os = "freebsd",
-              target_os = "linux", target_os = "openbsd"))]
+              target_os = "illumos", target_os = "linux", target_os = "openbsd",
+              target_os = "redox", target_os = "solaris"))]
     /// Asynchronous input or output operations may be performed for the
     /// associated file.
     _POSIX_ASYNC_IO = libc::_PC_ASYNC_IO,
     #[cfg(any(target_os = "android", target_os = "dragonfly", target_os = "freebsd",
-              target_os = "linux", target_os = "openbsd"))]
+              target_os = "illumos", target_os = "linux", target_os = "openbsd",
+              target_os = "redox", target_os = "solaris"))]
     /// Prioritized input or output operations may be performed for the
     /// associated file.
     _POSIX_PRIO_IO = libc::_PC_PRIO_IO,
     #[cfg(any(target_os = "android", target_os = "dragonfly", target_os = "freebsd",
-              target_os = "linux", target_os = "netbsd", target_os = "openbsd"))]
+              target_os = "illumos", target_os = "linux", target_os = "netbsd",
+              target_os = "openbsd", target_os = "redox", target_os = "solaris"))]
     /// Synchronized input or output operations may be performed for the
     /// associated file.
     _POSIX_SYNC_IO = libc::_PC_SYNC_IO,
@@ -1795,7 +1903,7 @@ pub enum PathconfVar {
 }
 
 /// Like `pathconf`, but works with file descriptors instead of paths (see
-/// [fpathconf(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/pathconf.html))
+/// [fpathconf(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pathconf.html))
 ///
 /// # Parameters
 ///
@@ -1819,7 +1927,7 @@ pub fn fpathconf(fd: RawFd, var: PathconfVar) -> Result<Option<c_long>> {
         if errno::errno() == 0 {
             Ok(None)
         } else {
-            Err(Error::Sys(Errno::last()))
+            Err(Errno::last())
         }
     } else {
         Ok(Some(raw))
@@ -1827,12 +1935,12 @@ pub fn fpathconf(fd: RawFd, var: PathconfVar) -> Result<Option<c_long>> {
 }
 
 /// Get path-dependent configurable system variables (see
-/// [pathconf(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/pathconf.html))
+/// [pathconf(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pathconf.html))
 ///
 /// Returns the value of a path-dependent configurable system variable.  Most
 /// supported variables also have associated compile-time constants, but POSIX
 /// allows their values to change at runtime.  There are generally two types of
-/// `pathconf` variables: options and limits.  See [pathconf(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/pathconf.html) for more details.
+/// `pathconf` variables: options and limits.  See [pathconf(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pathconf.html) for more details.
 ///
 /// # Parameters
 ///
@@ -1858,7 +1966,7 @@ pub fn pathconf<P: ?Sized + NixPath>(path: &P, var: PathconfVar) -> Result<Optio
         if errno::errno() == 0 {
             Ok(None)
         } else {
-            Err(Error::Sys(Errno::last()))
+            Err(Errno::last())
         }
     } else {
         Ok(Some(raw))
@@ -1868,7 +1976,7 @@ pub fn pathconf<P: ?Sized + NixPath>(path: &P, var: PathconfVar) -> Result<Optio
 /// Variable names for `sysconf`
 ///
 /// Nix uses the same naming convention for these variables as the
-/// [getconf(1)](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/getconf.html) utility.
+/// [getconf(1)](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/getconf.html) utility.
 /// That is, `SysconfVar` variables have the same name as the abstract variables
 /// shown in the `sysconf(3)` man page.  Usually, it's the same as the C
 /// variable name without the leading `_SC_`.
@@ -1878,17 +1986,20 @@ pub fn pathconf<P: ?Sized + NixPath>(path: &P, var: PathconfVar) -> Result<Optio
 ///
 /// # References
 ///
-/// - [sysconf(3)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/sysconf.html)
-/// - [unistd.h](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/unistd.h.html)
-/// - [limits.h](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/limits.h.html)
+/// - [sysconf(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/sysconf.html)
+/// - [unistd.h](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/unistd.h.html)
+/// - [limits.h](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/limits.h.html)
 #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
 #[repr(i32)]
+#[non_exhaustive]
 pub enum SysconfVar {
     /// Maximum number of I/O operations in a single list I/O call supported by
     /// the implementation.
+    #[cfg(not(target_os = "redox"))]
     AIO_LISTIO_MAX = libc::_SC_AIO_LISTIO_MAX,
     /// Maximum number of outstanding asynchronous I/O operations supported by
     /// the implementation.
+    #[cfg(not(target_os = "redox"))]
     AIO_MAX = libc::_SC_AIO_MAX,
     #[cfg(any(target_os="android", target_os="dragonfly", target_os="freebsd",
               target_os = "ios", target_os="linux", target_os = "macos",
@@ -1899,51 +2010,66 @@ pub enum SysconfVar {
     /// Maximum length of argument to the exec functions including environment data.
     ARG_MAX = libc::_SC_ARG_MAX,
     /// Maximum number of functions that may be registered with `atexit`.
+    #[cfg(not(target_os = "redox"))]
     ATEXIT_MAX = libc::_SC_ATEXIT_MAX,
     /// Maximum obase values allowed by the bc utility.
+    #[cfg(not(target_os = "redox"))]
     BC_BASE_MAX = libc::_SC_BC_BASE_MAX,
     /// Maximum number of elements permitted in an array by the bc utility.
+    #[cfg(not(target_os = "redox"))]
     BC_DIM_MAX = libc::_SC_BC_DIM_MAX,
     /// Maximum scale value allowed by the bc utility.
+    #[cfg(not(target_os = "redox"))]
     BC_SCALE_MAX = libc::_SC_BC_SCALE_MAX,
     /// Maximum length of a string constant accepted by the bc utility.
+    #[cfg(not(target_os = "redox"))]
     BC_STRING_MAX = libc::_SC_BC_STRING_MAX,
     /// Maximum number of simultaneous processes per real user ID.
     CHILD_MAX = libc::_SC_CHILD_MAX,
-    // _SC_CLK_TCK is obsolete
+    // The number of clock ticks per second.
+    CLK_TCK = libc::_SC_CLK_TCK,
     /// Maximum number of weights that can be assigned to an entry of the
     /// LC_COLLATE order keyword in the locale definition file
+    #[cfg(not(target_os = "redox"))]
     COLL_WEIGHTS_MAX = libc::_SC_COLL_WEIGHTS_MAX,
     /// Maximum number of timer expiration overruns.
+    #[cfg(not(target_os = "redox"))]
     DELAYTIMER_MAX = libc::_SC_DELAYTIMER_MAX,
     /// Maximum number of expressions that can be nested within parentheses by
     /// the expr utility.
+    #[cfg(not(target_os = "redox"))]
     EXPR_NEST_MAX = libc::_SC_EXPR_NEST_MAX,
-    #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "ios",
-              target_os="linux", target_os = "macos", target_os="netbsd",
-              target_os="openbsd"))]
+    #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "illumos",
+              target_os = "ios", target_os="linux", target_os = "macos",
+              target_os="netbsd", target_os="openbsd", target_os = "solaris"))]
     /// Maximum length of a host name (not including the terminating null) as
     /// returned from the `gethostname` function
     HOST_NAME_MAX = libc::_SC_HOST_NAME_MAX,
     /// Maximum number of iovec structures that one process has available for
     /// use with `readv` or `writev`.
+    #[cfg(not(target_os = "redox"))]
     IOV_MAX = libc::_SC_IOV_MAX,
     /// Unless otherwise noted, the maximum length, in bytes, of a utility's
     /// input line (either standard input or another file), when the utility is
     /// described as processing text files. The length includes room for the
     /// trailing <newline>.
+    #[cfg(not(target_os = "redox"))]
     LINE_MAX = libc::_SC_LINE_MAX,
     /// Maximum length of a login name.
     LOGIN_NAME_MAX = libc::_SC_LOGIN_NAME_MAX,
     /// Maximum number of simultaneous supplementary group IDs per process.
     NGROUPS_MAX = libc::_SC_NGROUPS_MAX,
     /// Initial size of `getgrgid_r` and `getgrnam_r` data buffers
+    #[cfg(not(target_os = "redox"))]
     GETGR_R_SIZE_MAX = libc::_SC_GETGR_R_SIZE_MAX,
     /// Initial size of `getpwuid_r` and `getpwnam_r` data buffers
+    #[cfg(not(target_os = "redox"))]
     GETPW_R_SIZE_MAX = libc::_SC_GETPW_R_SIZE_MAX,
     /// The maximum number of open message queue descriptors a process may hold.
+    #[cfg(not(target_os = "redox"))]
     MQ_OPEN_MAX = libc::_SC_MQ_OPEN_MAX,
     /// The maximum number of message priorities supported by the implementation.
+    #[cfg(not(target_os = "redox"))]
     MQ_PRIO_MAX = libc::_SC_MQ_PRIO_MAX,
     /// A value one greater than the maximum value that the system may assign to
     /// a newly-created file descriptor.
@@ -1952,57 +2078,69 @@ pub enum SysconfVar {
               target_os="linux", target_os = "macos", target_os="openbsd"))]
     /// The implementation supports the Advisory Information option.
     _POSIX_ADVISORY_INFO = libc::_SC_ADVISORY_INFO,
-    #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "ios",
-              target_os="linux", target_os = "macos", target_os="netbsd",
-              target_os="openbsd"))]
+    #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "illumos",
+              target_os = "ios", target_os="linux", target_os = "macos",
+              target_os="netbsd", target_os="openbsd", target_os = "solaris"))]
     /// The implementation supports barriers.
     _POSIX_BARRIERS = libc::_SC_BARRIERS,
     /// The implementation supports asynchronous input and output.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_ASYNCHRONOUS_IO = libc::_SC_ASYNCHRONOUS_IO,
-    #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "ios",
-              target_os="linux", target_os = "macos", target_os="netbsd",
-              target_os="openbsd"))]
+    #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "illumos",
+              target_os = "ios", target_os="linux", target_os = "macos",
+              target_os="netbsd", target_os="openbsd", target_os = "solaris"))]
     /// The implementation supports clock selection.
     _POSIX_CLOCK_SELECTION = libc::_SC_CLOCK_SELECTION,
-    #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "ios",
-              target_os="linux", target_os = "macos", target_os="netbsd",
-              target_os="openbsd"))]
+    #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "illumos",
+              target_os = "ios", target_os="linux", target_os = "macos",
+              target_os="netbsd", target_os="openbsd", target_os = "solaris"))]
     /// The implementation supports the Process CPU-Time Clocks option.
     _POSIX_CPUTIME = libc::_SC_CPUTIME,
     /// The implementation supports the File Synchronization option.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_FSYNC = libc::_SC_FSYNC,
-    #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "ios",
-              target_os="linux", target_os = "macos", target_os="openbsd"))]
+    #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "illumos",
+              target_os = "ios", target_os="linux", target_os = "macos",
+              target_os="openbsd", target_os = "solaris"))]
     /// The implementation supports the IPv6 option.
     _POSIX_IPV6 = libc::_SC_IPV6,
     /// The implementation supports job control.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_JOB_CONTROL = libc::_SC_JOB_CONTROL,
     /// The implementation supports memory mapped Files.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_MAPPED_FILES = libc::_SC_MAPPED_FILES,
     /// The implementation supports the Process Memory Locking option.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_MEMLOCK = libc::_SC_MEMLOCK,
     /// The implementation supports the Range Memory Locking option.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_MEMLOCK_RANGE = libc::_SC_MEMLOCK_RANGE,
     /// The implementation supports memory protection.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_MEMORY_PROTECTION = libc::_SC_MEMORY_PROTECTION,
     /// The implementation supports the Message Passing option.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_MESSAGE_PASSING = libc::_SC_MESSAGE_PASSING,
     /// The implementation supports the Monotonic Clock option.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_MONOTONIC_CLOCK = libc::_SC_MONOTONIC_CLOCK,
     #[cfg(any(target_os="android", target_os="dragonfly", target_os="freebsd",
-              target_os = "ios", target_os="linux", target_os = "macos",
-              target_os="openbsd"))]
+              target_os = "illumos", target_os = "ios", target_os="linux",
+              target_os = "macos", target_os="openbsd", target_os = "solaris"))]
     /// The implementation supports the Prioritized Input and Output option.
     _POSIX_PRIORITIZED_IO = libc::_SC_PRIORITIZED_IO,
     /// The implementation supports the Process Scheduling option.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_PRIORITY_SCHEDULING = libc::_SC_PRIORITY_SCHEDULING,
-    #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "ios",
-              target_os="linux", target_os = "macos", target_os="openbsd"))]
+    #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "illumos",
+              target_os = "ios", target_os="linux", target_os = "macos",
+              target_os="openbsd", target_os = "solaris"))]
     /// The implementation supports the Raw Sockets option.
     _POSIX_RAW_SOCKETS = libc::_SC_RAW_SOCKETS,
-    #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "ios",
-              target_os="linux", target_os = "macos", target_os="netbsd",
-              target_os="openbsd"))]
+    #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "illumos",
+              target_os = "ios", target_os="linux", target_os = "macos",
+              target_os="netbsd", target_os="openbsd", target_os = "solaris"))]
     /// The implementation supports read-write locks.
     _POSIX_READER_WRITER_LOCKS = libc::_SC_READER_WRITER_LOCKS,
     #[cfg(any(target_os = "android", target_os="dragonfly", target_os="freebsd",
@@ -2010,16 +2148,19 @@ pub enum SysconfVar {
               target_os = "openbsd"))]
     /// The implementation supports realtime signals.
     _POSIX_REALTIME_SIGNALS = libc::_SC_REALTIME_SIGNALS,
-    #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "ios",
-              target_os="linux", target_os = "macos", target_os="netbsd",
-              target_os="openbsd"))]
+    #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "illumos",
+              target_os = "ios", target_os="linux", target_os = "macos",
+              target_os="netbsd", target_os="openbsd", target_os = "solaris"))]
     /// The implementation supports the Regular Expression Handling option.
     _POSIX_REGEXP = libc::_SC_REGEXP,
     /// Each process has a saved set-user-ID and a saved set-group-ID.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_SAVED_IDS = libc::_SC_SAVED_IDS,
     /// The implementation supports semaphores.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_SEMAPHORES = libc::_SC_SEMAPHORES,
     /// The implementation supports the Shared Memory Objects option.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_SHARED_MEMORY_OBJECTS = libc::_SC_SHARED_MEMORY_OBJECTS,
     #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "ios",
               target_os="linux", target_os = "macos", target_os="netbsd",
@@ -2044,10 +2185,13 @@ pub enum SysconfVar {
               target_os="openbsd"))]
     _POSIX_SS_REPL_MAX = libc::_SC_SS_REPL_MAX,
     /// The implementation supports the Synchronized Input and Output option.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_SYNCHRONIZED_IO = libc::_SC_SYNCHRONIZED_IO,
     /// The implementation supports the Thread Stack Address Attribute option.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_THREAD_ATTR_STACKADDR = libc::_SC_THREAD_ATTR_STACKADDR,
     /// The implementation supports the Thread Stack Size Attribute option.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_THREAD_ATTR_STACKSIZE = libc::_SC_THREAD_ATTR_STACKSIZE,
     #[cfg(any(target_os = "ios", target_os="linux", target_os = "macos",
               target_os="netbsd", target_os="openbsd"))]
@@ -2055,10 +2199,13 @@ pub enum SysconfVar {
     _POSIX_THREAD_CPUTIME = libc::_SC_THREAD_CPUTIME,
     /// The implementation supports the Non-Robust Mutex Priority Inheritance
     /// option.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_THREAD_PRIO_INHERIT = libc::_SC_THREAD_PRIO_INHERIT,
     /// The implementation supports the Non-Robust Mutex Priority Protection option.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_THREAD_PRIO_PROTECT = libc::_SC_THREAD_PRIO_PROTECT,
     /// The implementation supports the Thread Execution Scheduling option.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_THREAD_PRIORITY_SCHEDULING = libc::_SC_THREAD_PRIORITY_SCHEDULING,
     #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "ios",
               target_os="linux", target_os = "macos", target_os="netbsd",
@@ -2073,18 +2220,21 @@ pub enum SysconfVar {
     /// The implementation supports the Robust Mutex Priority Protection option.
     _POSIX_THREAD_ROBUST_PRIO_PROTECT = libc::_SC_THREAD_ROBUST_PRIO_PROTECT,
     /// The implementation supports thread-safe functions.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_THREAD_SAFE_FUNCTIONS = libc::_SC_THREAD_SAFE_FUNCTIONS,
     #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "ios",
               target_os="linux", target_os = "macos", target_os="openbsd"))]
     /// The implementation supports the Thread Sporadic Server option.
     _POSIX_THREAD_SPORADIC_SERVER = libc::_SC_THREAD_SPORADIC_SERVER,
     /// The implementation supports threads.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_THREADS = libc::_SC_THREADS,
     #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "ios",
               target_os="linux", target_os = "macos", target_os="openbsd"))]
     /// The implementation supports timeouts.
     _POSIX_TIMEOUTS = libc::_SC_TIMEOUTS,
     /// The implementation supports timers.
+    #[cfg(not(target_os = "redox"))]
     _POSIX_TIMERS = libc::_SC_TIMERS,
     #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "ios",
               target_os="linux", target_os = "macos", target_os="openbsd"))]
@@ -2149,17 +2299,23 @@ pub enum SysconfVar {
     /// using at least 64 bits.
     _POSIX_V6_LPBIG_OFFBIG = libc::_SC_V6_LPBIG_OFFBIG,
     /// The implementation supports the C-Language Binding option.
+    #[cfg(not(target_os = "redox"))]
     _POSIX2_C_BIND = libc::_SC_2_C_BIND,
     /// The implementation supports the C-Language Development Utilities option.
+    #[cfg(not(target_os = "redox"))]
     _POSIX2_C_DEV = libc::_SC_2_C_DEV,
     /// The implementation supports the Terminal Characteristics option.
+    #[cfg(not(target_os = "redox"))]
     _POSIX2_CHAR_TERM = libc::_SC_2_CHAR_TERM,
     /// The implementation supports the FORTRAN Development Utilities option.
+    #[cfg(not(target_os = "redox"))]
     _POSIX2_FORT_DEV = libc::_SC_2_FORT_DEV,
     /// The implementation supports the FORTRAN Runtime Utilities option.
+    #[cfg(not(target_os = "redox"))]
     _POSIX2_FORT_RUN = libc::_SC_2_FORT_RUN,
     /// The implementation supports the creation of locales by the localedef
     /// utility.
+    #[cfg(not(target_os = "redox"))]
     _POSIX2_LOCALEDEF = libc::_SC_2_LOCALEDEF,
     #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "ios",
               target_os="linux", target_os = "macos", target_os="netbsd",
@@ -2193,26 +2349,34 @@ pub enum SysconfVar {
     /// The implementation supports the Track Batch Job Request option.
     _POSIX2_PBS_TRACK = libc::_SC_2_PBS_TRACK,
     /// The implementation supports the Software Development Utilities option.
+    #[cfg(not(target_os = "redox"))]
     _POSIX2_SW_DEV = libc::_SC_2_SW_DEV,
     /// The implementation supports the User Portability Utilities option.
+    #[cfg(not(target_os = "redox"))]
     _POSIX2_UPE = libc::_SC_2_UPE,
     /// Integer value indicating version of the Shell and Utilities volume of
     /// POSIX.1 to which the implementation conforms.
+    #[cfg(not(target_os = "redox"))]
     _POSIX2_VERSION = libc::_SC_2_VERSION,
     /// The size of a system page in bytes.
     ///
     /// POSIX also defines an alias named `PAGESIZE`, but Rust does not allow two
     /// enum constants to have the same value, so nix omits `PAGESIZE`.
     PAGE_SIZE = libc::_SC_PAGE_SIZE,
+    #[cfg(not(target_os = "redox"))]
     PTHREAD_DESTRUCTOR_ITERATIONS = libc::_SC_THREAD_DESTRUCTOR_ITERATIONS,
+    #[cfg(not(target_os = "redox"))]
     PTHREAD_KEYS_MAX = libc::_SC_THREAD_KEYS_MAX,
+    #[cfg(not(target_os = "redox"))]
     PTHREAD_STACK_MIN = libc::_SC_THREAD_STACK_MIN,
+    #[cfg(not(target_os = "redox"))]
     PTHREAD_THREADS_MAX = libc::_SC_THREAD_THREADS_MAX,
     RE_DUP_MAX = libc::_SC_RE_DUP_MAX,
     #[cfg(any(target_os="android", target_os="dragonfly", target_os="freebsd",
               target_os = "ios", target_os="linux", target_os = "macos",
               target_os="openbsd"))]
     RTSIG_MAX = libc::_SC_RTSIG_MAX,
+    #[cfg(not(target_os = "redox"))]
     SEM_NSEMS_MAX = libc::_SC_SEM_NSEMS_MAX,
     #[cfg(any(target_os="android", target_os="dragonfly", target_os="freebsd",
               target_os = "ios", target_os="linux", target_os = "macos",
@@ -2227,6 +2391,7 @@ pub enum SysconfVar {
               target_os="linux", target_os = "macos", target_os="netbsd",
               target_os="openbsd"))]
     SYMLOOP_MAX = libc::_SC_SYMLOOP_MAX,
+    #[cfg(not(target_os = "redox"))]
     TIMER_MAX = libc::_SC_TIMER_MAX,
     TTY_NAME_MAX = libc::_SC_TTY_NAME_MAX,
     TZNAME_MAX = libc::_SC_TZNAME_MAX,
@@ -2257,6 +2422,7 @@ pub enum SysconfVar {
     _XOPEN_REALTIME_THREADS = libc::_SC_XOPEN_REALTIME_THREADS,
     /// The implementation supports the Issue 4, Version 2 Shared Memory Option
     /// Group.
+    #[cfg(not(target_os = "redox"))]
     _XOPEN_SHM = libc::_SC_XOPEN_SHM,
     #[cfg(any(target_os="dragonfly", target_os="freebsd", target_os = "ios",
               target_os="linux", target_os = "macos", target_os="openbsd"))]
@@ -2276,7 +2442,7 @@ pub enum SysconfVar {
 }
 
 /// Get configurable system variables (see
-/// [sysconf(3)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/sysconf.html))
+/// [sysconf(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/sysconf.html))
 ///
 /// Returns the value of a configurable system variable.  Most supported
 /// variables also have associated compile-time constants, but POSIX
@@ -2300,7 +2466,7 @@ pub fn sysconf(var: SysconfVar) -> Result<Option<c_long>> {
         if errno::errno() == 0 {
             Ok(None)
         } else {
-            Err(Error::Sys(Errno::last()))
+            Err(Errno::last())
         }
     } else {
         Ok(Some(raw))
@@ -2309,9 +2475,8 @@ pub fn sysconf(var: SysconfVar) -> Result<Option<c_long>> {
 
 #[cfg(any(target_os = "android", target_os = "linux"))]
 mod pivot_root {
-    use libc;
-    use {Result, NixPath};
-    use errno::Errno;
+    use crate::{Result, NixPath};
+    use crate::errno::Errno;
 
     pub fn pivot_root<P1: ?Sized + NixPath, P2: ?Sized + NixPath>(
             new_root: &P1, put_old: &P2) -> Result<()> {
@@ -2330,13 +2495,12 @@ mod pivot_root {
 #[cfg(any(target_os = "android", target_os = "freebsd",
           target_os = "linux", target_os = "openbsd"))]
 mod setres {
-    use libc;
-    use Result;
-    use errno::Errno;
+    use crate::Result;
+    use crate::errno::Errno;
     use super::{Uid, Gid};
 
     /// Sets the real, effective, and saved uid.
-    /// ([see setresuid(2)](http://man7.org/linux/man-pages/man2/setresuid.2.html))
+    /// ([see setresuid(2)](https://man7.org/linux/man-pages/man2/setresuid.2.html))
     ///
     /// * `ruid`: real user id
     /// * `euid`: effective user id
@@ -2352,7 +2516,7 @@ mod setres {
     }
 
     /// Sets the real, effective, and saved gid.
-    /// ([see setresuid(2)](http://man7.org/linux/man-pages/man2/setresuid.2.html))
+    /// ([see setresuid(2)](https://man7.org/linux/man-pages/man2/setresuid.2.html))
     ///
     /// * `rgid`: real group id
     /// * `egid`: effective group id
@@ -2368,6 +2532,67 @@ mod setres {
     }
 }
 
+#[cfg(any(target_os = "android", target_os = "linux"))]
+mod getres {
+    use crate::Result;
+    use crate::errno::Errno;
+    use super::{Uid, Gid};
+
+    /// Real, effective and saved user IDs.
+    #[derive(Debug, Copy, Clone, Eq, PartialEq)]
+    pub struct ResUid {
+        pub real: Uid,
+        pub effective: Uid,
+        pub saved: Uid
+    }
+
+    /// Real, effective and saved group IDs.
+    #[derive(Debug, Copy, Clone, Eq, PartialEq)]
+    pub struct ResGid {
+        pub real: Gid,
+        pub effective: Gid,
+        pub saved: Gid
+    }
+
+    /// Gets the real, effective, and saved user IDs.
+    ///
+    /// ([see getresuid(2)](http://man7.org/linux/man-pages/man2/getresuid.2.html))
+    ///
+    /// #Returns
+    ///
+    /// - `Ok((Uid, Uid, Uid))`: tuple of real, effective and saved uids on success.
+    /// - `Err(x)`: libc error code on failure.
+    ///
+    #[inline]
+    pub fn getresuid() -> Result<ResUid> {
+        let mut ruid = libc::uid_t::max_value();
+        let mut euid = libc::uid_t::max_value();
+        let mut suid = libc::uid_t::max_value();
+        let res = unsafe { libc::getresuid(&mut ruid, &mut euid, &mut suid) };
+
+        Errno::result(res).map(|_| ResUid{ real: Uid(ruid), effective: Uid(euid), saved: Uid(suid) })
+    }
+
+    /// Gets the real, effective, and saved group IDs.
+    ///
+    /// ([see getresgid(2)](http://man7.org/linux/man-pages/man2/getresgid.2.html))
+    ///
+    /// #Returns
+    ///
+    /// - `Ok((Gid, Gid, Gid))`: tuple of real, effective and saved gids on success.
+    /// - `Err(x)`: libc error code on failure.
+    ///
+    #[inline]
+    pub fn getresgid() -> Result<ResGid> {
+        let mut rgid = libc::gid_t::max_value();
+        let mut egid = libc::gid_t::max_value();
+        let mut sgid = libc::gid_t::max_value();
+        let res = unsafe { libc::getresgid(&mut rgid, &mut egid, &mut sgid) };
+
+        Errno::result(res).map(|_| ResGid { real: Gid(rgid), effective: Gid(egid), saved: Gid(sgid) } )
+    }
+}
+
 libc_bitflags!{
     /// Options for access()
     pub struct AccessFlags : c_int {
@@ -2383,7 +2608,7 @@ libc_bitflags!{
 }
 
 /// Checks the file named by `path` for accessibility according to the flags given by `amode`
-/// See [access(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/access.html)
+/// See [access(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/access.html)
 pub fn access<P: ?Sized + NixPath>(path: &P, amode: AccessFlags) -> Result<()> {
     let res = path.with_nix_path(|cstr| {
         unsafe {
@@ -2392,3 +2617,378 @@ pub fn access<P: ?Sized + NixPath>(path: &P, amode: AccessFlags) -> Result<()> {
     })?;
     Errno::result(res).map(drop)
 }
+
+/// Representation of a User, based on `libc::passwd`
+///
+/// The reason some fields in this struct are `String` and others are `CString` is because some
+/// fields are based on the user's locale, which could be non-UTF8, while other fields are
+/// guaranteed to conform to [`NAME_REGEX`](https://serverfault.com/a/73101/407341), which only
+/// contains ASCII.
+#[cfg(not(target_os = "redox"))] // RedoxFS does not support passwd
+#[derive(Debug, Clone, PartialEq)]
+pub struct User {
+    /// Username
+    pub name: String,
+    /// User password (probably encrypted)
+    pub passwd: CString,
+    /// User ID
+    pub uid: Uid,
+    /// Group ID
+    pub gid: Gid,
+    /// User information
+    #[cfg(not(all(target_os = "android", target_pointer_width = "32")))]
+    pub gecos: CString,
+    /// Home directory
+    pub dir: PathBuf,
+    /// Path to shell
+    pub shell: PathBuf,
+    /// Login class
+    #[cfg(not(any(target_os = "android",
+                  target_os = "fuchsia",
+                  target_os = "illumos",
+                  target_os = "linux",
+                  target_os = "solaris")))]
+    pub class: CString,
+    /// Last password change
+    #[cfg(not(any(target_os = "android",
+                  target_os = "fuchsia",
+                  target_os = "illumos",
+                  target_os = "linux",
+                  target_os = "solaris")))]
+    pub change: libc::time_t,
+    /// Expiration time of account
+    #[cfg(not(any(target_os = "android",
+                  target_os = "fuchsia",
+                  target_os = "illumos",
+                  target_os = "linux",
+                  target_os = "solaris")))]
+    pub expire: libc::time_t
+}
+
+#[cfg(not(target_os = "redox"))] // RedoxFS does not support passwd
+impl From<&libc::passwd> for User {
+    fn from(pw: &libc::passwd) -> User {
+        unsafe {
+            User {
+                name: CStr::from_ptr((*pw).pw_name).to_string_lossy().into_owned(),
+                passwd: CString::new(CStr::from_ptr((*pw).pw_passwd).to_bytes()).unwrap(),
+                #[cfg(not(all(target_os = "android", target_pointer_width = "32")))]
+                gecos: CString::new(CStr::from_ptr((*pw).pw_gecos).to_bytes()).unwrap(),
+                dir: PathBuf::from(OsStr::from_bytes(CStr::from_ptr((*pw).pw_dir).to_bytes())),
+                shell: PathBuf::from(OsStr::from_bytes(CStr::from_ptr((*pw).pw_shell).to_bytes())),
+                uid: Uid::from_raw((*pw).pw_uid),
+                gid: Gid::from_raw((*pw).pw_gid),
+                #[cfg(not(any(target_os = "android",
+                              target_os = "fuchsia",
+                              target_os = "illumos",
+                              target_os = "linux",
+                              target_os = "solaris")))]
+                class: CString::new(CStr::from_ptr((*pw).pw_class).to_bytes()).unwrap(),
+                #[cfg(not(any(target_os = "android",
+                              target_os = "fuchsia",
+                              target_os = "illumos",
+                              target_os = "linux",
+                              target_os = "solaris")))]
+                change: (*pw).pw_change,
+                #[cfg(not(any(target_os = "android",
+                              target_os = "fuchsia",
+                              target_os = "illumos",
+                              target_os = "linux",
+                              target_os = "solaris")))]
+                expire: (*pw).pw_expire
+            }
+        }
+    }
+}
+
+#[cfg(not(target_os = "redox"))] // RedoxFS does not support passwd
+impl From<User> for libc::passwd {
+    fn from(u: User) -> Self {
+        let name = match CString::new(u.name) {
+            Ok(n) => n.into_raw(),
+            Err(_) => CString::new("").unwrap().into_raw(),
+        };
+        let dir = match u.dir.into_os_string().into_string() {
+            Ok(s) => CString::new(s.as_str()).unwrap().into_raw(),
+            Err(_) => CString::new("").unwrap().into_raw(),
+        };
+        let shell = match u.shell.into_os_string().into_string() {
+            Ok(s) => CString::new(s.as_str()).unwrap().into_raw(),
+            Err(_) => CString::new("").unwrap().into_raw(),
+        };
+        Self {
+            pw_name: name,
+            pw_passwd: u.passwd.into_raw(),
+            #[cfg(not(all(target_os = "android", target_pointer_width = "32")))]
+            pw_gecos: u.gecos.into_raw(),
+            pw_dir: dir,
+            pw_shell: shell,
+            pw_uid: u.uid.0,
+            pw_gid: u.gid.0,
+            #[cfg(not(any(target_os = "android",
+                          target_os = "fuchsia",
+                          target_os = "illumos",
+                          target_os = "linux",
+                          target_os = "solaris")))]
+            pw_class: u.class.into_raw(),
+            #[cfg(not(any(target_os = "android",
+                          target_os = "fuchsia",
+                          target_os = "illumos",
+                          target_os = "linux",
+                          target_os = "solaris")))]
+            pw_change: u.change,
+            #[cfg(not(any(target_os = "android",
+                          target_os = "fuchsia",
+                          target_os = "illumos",
+                          target_os = "linux",
+                          target_os = "solaris")))]
+            pw_expire: u.expire,
+            #[cfg(target_os = "illumos")]
+            pw_age: CString::new("").unwrap().into_raw(),
+            #[cfg(target_os = "illumos")]
+            pw_comment: CString::new("").unwrap().into_raw(),
+            #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+            pw_fields: 0,
+        }
+    }
+}
+
+#[cfg(not(target_os = "redox"))] // RedoxFS does not support passwd
+impl User {
+    fn from_anything<F>(f: F) -> Result<Option<Self>>
+    where
+        F: Fn(*mut libc::passwd,
+              *mut libc::c_char,
+              libc::size_t,
+              *mut *mut libc::passwd) -> libc::c_int
+    {
+        let buflimit = 1048576;
+        let bufsize = match sysconf(SysconfVar::GETPW_R_SIZE_MAX) {
+            Ok(Some(n)) => n as usize,
+            Ok(None) | Err(_) => 16384,
+        };
+
+        let mut cbuf = Vec::with_capacity(bufsize);
+        let mut pwd = mem::MaybeUninit::<libc::passwd>::uninit();
+        let mut res = ptr::null_mut();
+
+        loop {
+            let error = f(pwd.as_mut_ptr(), cbuf.as_mut_ptr(), cbuf.capacity(), &mut res);
+            if error == 0 {
+                if res.is_null() {
+                    return Ok(None);
+                } else {
+                    let pwd = unsafe { pwd.assume_init() };
+                    return Ok(Some(User::from(&pwd)));
+                }
+            } else if Errno::last() == Errno::ERANGE {
+                // Trigger the internal buffer resizing logic.
+                reserve_double_buffer_size(&mut cbuf, buflimit)?;
+            } else {
+                return Err(Errno::last());
+            }
+        }
+    }
+
+    /// Get a user by UID.
+    ///
+    /// Internally, this function calls
+    /// [getpwuid_r(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpwuid_r.html)
+    ///
+    /// # Examples
+    ///
+    /// ```
+    /// use nix::unistd::{Uid, User};
+    /// // Returns an Result<Option<User>>, thus the double unwrap.
+    /// let res = User::from_uid(Uid::from_raw(0)).unwrap().unwrap();
+    /// assert!(res.name == "root");
+    /// ```
+    pub fn from_uid(uid: Uid) -> Result<Option<Self>> {
+        User::from_anything(|pwd, cbuf, cap, res| {
+            unsafe { libc::getpwuid_r(uid.0, pwd, cbuf, cap, res) }
+        })
+    }
+
+    /// Get a user by name.
+    ///
+    /// Internally, this function calls
+    /// [getpwnam_r(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpwuid_r.html)
+    ///
+    /// # Examples
+    ///
+    /// ```
+    /// use nix::unistd::User;
+    /// // Returns an Result<Option<User>>, thus the double unwrap.
+    /// let res = User::from_name("root").unwrap().unwrap();
+    /// assert!(res.name == "root");
+    /// ```
+    pub fn from_name(name: &str) -> Result<Option<Self>> {
+        let name = CString::new(name).unwrap();
+        User::from_anything(|pwd, cbuf, cap, res| {
+            unsafe { libc::getpwnam_r(name.as_ptr(), pwd, cbuf, cap, res) }
+        })
+    }
+}
+
+/// Representation of a Group, based on `libc::group`
+#[cfg(not(target_os = "redox"))] // RedoxFS does not support passwd
+#[derive(Debug, Clone, PartialEq)]
+pub struct Group {
+    /// Group name
+    pub name: String,
+    /// Group password
+    pub passwd: CString,
+    /// Group ID
+    pub gid: Gid,
+    /// List of Group members
+    pub mem: Vec<String>
+}
+
+#[cfg(not(target_os = "redox"))] // RedoxFS does not support passwd
+impl From<&libc::group> for Group {
+    fn from(gr: &libc::group) -> Group {
+        unsafe {
+            Group {
+                name: CStr::from_ptr((*gr).gr_name).to_string_lossy().into_owned(),
+                passwd: CString::new(CStr::from_ptr((*gr).gr_passwd).to_bytes()).unwrap(),
+                gid: Gid::from_raw((*gr).gr_gid),
+                mem: Group::members((*gr).gr_mem)
+            }
+        }
+    }
+}
+
+#[cfg(not(target_os = "redox"))] // RedoxFS does not support passwd
+impl Group {
+    unsafe fn members(mem: *mut *mut c_char) -> Vec<String> {
+        let mut ret = Vec::new();
+
+        for i in 0.. {
+            let u = mem.offset(i);
+            if (*u).is_null() {
+                break;
+            } else {
+                let s = CStr::from_ptr(*u).to_string_lossy().into_owned();
+                ret.push(s);
+            }
+        }
+
+        ret
+    }
+
+    fn from_anything<F>(f: F) -> Result<Option<Self>>
+    where
+        F: Fn(*mut libc::group,
+              *mut libc::c_char,
+              libc::size_t,
+              *mut *mut libc::group) -> libc::c_int
+    {
+        let buflimit = 1048576;
+        let bufsize = match sysconf(SysconfVar::GETGR_R_SIZE_MAX) {
+            Ok(Some(n)) => n as usize,
+            Ok(None) | Err(_) => 16384,
+        };
+
+        let mut cbuf = Vec::with_capacity(bufsize);
+        let mut grp = mem::MaybeUninit::<libc::group>::uninit();
+        let mut res = ptr::null_mut();
+
+        loop {
+            let error = f(grp.as_mut_ptr(), cbuf.as_mut_ptr(), cbuf.capacity(), &mut res);
+            if error == 0 {
+                if res.is_null() {
+                    return Ok(None);
+                } else {
+                    let grp = unsafe { grp.assume_init() };
+                    return Ok(Some(Group::from(&grp)));
+                }
+            } else if Errno::last() == Errno::ERANGE {
+                // Trigger the internal buffer resizing logic.
+                reserve_double_buffer_size(&mut cbuf, buflimit)?;
+            } else {
+                return Err(Errno::last());
+            }
+        }
+    }
+
+    /// Get a group by GID.
+    ///
+    /// Internally, this function calls
+    /// [getgrgid_r(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpwuid_r.html)
+    ///
+    /// # Examples
+    ///
+    // Disable this test on all OS except Linux as root group may not exist.
+    #[cfg_attr(not(target_os = "linux"), doc = " ```no_run")]
+    #[cfg_attr(target_os = "linux", doc = " ```")]
+    /// use nix::unistd::{Gid, Group};
+    /// // Returns an Result<Option<Group>>, thus the double unwrap.
+    /// let res = Group::from_gid(Gid::from_raw(0)).unwrap().unwrap();
+    /// assert!(res.name == "root");
+    /// ```
+    pub fn from_gid(gid: Gid) -> Result<Option<Self>> {
+        Group::from_anything(|grp, cbuf, cap, res| {
+            unsafe { libc::getgrgid_r(gid.0, grp, cbuf, cap, res) }
+        })
+    }
+
+    /// Get a group by name.
+    ///
+    /// Internally, this function calls
+    /// [getgrnam_r(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpwuid_r.html)
+    ///
+    /// # Examples
+    ///
+    // Disable this test on all OS except Linux as root group may not exist.
+    #[cfg_attr(not(target_os = "linux"), doc = " ```no_run")]
+    #[cfg_attr(target_os = "linux", doc = " ```")]
+    /// use nix::unistd::Group;
+    /// // Returns an Result<Option<Group>>, thus the double unwrap.
+    /// let res = Group::from_name("root").unwrap().unwrap();
+    /// assert!(res.name == "root");
+    /// ```
+    pub fn from_name(name: &str) -> Result<Option<Self>> {
+        let name = CString::new(name).unwrap();
+        Group::from_anything(|grp, cbuf, cap, res| {
+            unsafe { libc::getgrnam_r(name.as_ptr(), grp, cbuf, cap, res) }
+        })
+    }
+}
+
+/// Get the name of the terminal device that is open on file descriptor fd
+/// (see [`ttyname(3)`](https://man7.org/linux/man-pages/man3/ttyname.3.html)).
+#[cfg(not(target_os = "fuchsia"))]
+pub fn ttyname(fd: RawFd) -> Result<PathBuf> {
+    const PATH_MAX: usize = libc::PATH_MAX as usize;
+    let mut buf = vec![0_u8; PATH_MAX];
+    let c_buf = buf.as_mut_ptr() as *mut libc::c_char;
+
+    let ret = unsafe { libc::ttyname_r(fd, c_buf, buf.len()) };
+    if ret != 0 {
+        return Err(Errno::from_i32(ret));
+    }
+
+    let nul = buf.iter().position(|c| *c == b'\0').unwrap();
+    buf.truncate(nul);
+    Ok(OsString::from_vec(buf).into())
+}
+
+/// Get the effective user ID and group ID associated with a Unix domain socket.
+///
+/// See also [getpeereid(3)](https://www.freebsd.org/cgi/man.cgi?query=getpeereid)
+#[cfg(any(
+    target_os = "macos",
+    target_os = "ios",
+    target_os = "freebsd",
+    target_os = "openbsd",
+    target_os = "netbsd",
+    target_os = "dragonfly",
+))]
+pub fn getpeereid(fd: RawFd) -> Result<(Uid, Gid)> {
+    let mut uid = 1;
+    let mut gid = 1;
+
+    let ret = unsafe { libc::getpeereid(fd, &mut uid, &mut gid) };
+
+    Errno::result(ret).map(|_| (Uid(uid), Gid(gid)))
+}
diff --git a/third_party/rust/nix/test/common/mod.rs b/third_party/rust/nix/test/common/mod.rs
new file mode 100644
index 0000000000000..84a0b4fa30823
--- /dev/null
+++ b/third_party/rust/nix/test/common/mod.rs
@@ -0,0 +1,141 @@
+use cfg_if::cfg_if;
+
+#[macro_export] macro_rules! skip {
+    ($($reason: expr),+) => {
+        use ::std::io::{self, Write};
+
+        let stderr = io::stderr();
+        let mut handle = stderr.lock();
+        writeln!(handle, $($reason),+).unwrap();
+        return;
+    }
+}
+
+cfg_if! {
+    if #[cfg(any(target_os = "android", target_os = "linux"))] {
+        #[macro_export] macro_rules! require_capability {
+            ($name:expr, $capname:ident) => {
+                use ::caps::{Capability, CapSet, has_cap};
+
+                if !has_cap(None, CapSet::Effective, Capability::$capname)
+                    .unwrap()
+                {
+                    skip!("{} requires capability {}. Skipping test.", $name, Capability::$capname);
+                }
+            }
+        }
+    } else if #[cfg(not(target_os = "redox"))] {
+        #[macro_export] macro_rules! require_capability {
+            ($name:expr, $capname:ident) => {}
+        }
+    }
+}
+
+/// Skip the test if we don't have the ability to mount file systems.
+#[cfg(target_os = "freebsd")]
+#[macro_export] macro_rules! require_mount {
+    ($name:expr) => {
+        use ::sysctl::CtlValue;
+        use nix::unistd::Uid;
+
+        if !Uid::current().is_root() && CtlValue::Int(0) == ::sysctl::value("vfs.usermount").unwrap()
+        {
+            skip!("{} requires the ability to mount file systems. Skipping test.", $name);
+        }
+    }
+}
+
+#[cfg(any(target_os = "linux", target_os= "android"))]
+#[macro_export] macro_rules! skip_if_cirrus {
+    ($reason:expr) => {
+        if std::env::var_os("CIRRUS_CI").is_some() {
+            skip!("{}", $reason);
+        }
+    }
+}
+
+#[cfg(target_os = "freebsd")]
+#[macro_export] macro_rules! skip_if_jailed {
+    ($name:expr) => {
+        use ::sysctl::CtlValue;
+
+        if let CtlValue::Int(1) = ::sysctl::value("security.jail.jailed")
+            .unwrap()
+        {
+            skip!("{} cannot run in a jail. Skipping test.", $name);
+        }
+    }
+}
+
+#[cfg(not(any(target_os = "redox", target_os = "fuchsia")))]
+#[macro_export] macro_rules! skip_if_not_root {
+    ($name:expr) => {
+        use nix::unistd::Uid;
+
+        if !Uid::current().is_root() {
+            skip!("{} requires root privileges. Skipping test.", $name);
+        }
+    };
+}
+
+cfg_if! {
+    if #[cfg(any(target_os = "android", target_os = "linux"))] {
+        #[macro_export] macro_rules! skip_if_seccomp {
+            ($name:expr) => {
+                if let Ok(s) = std::fs::read_to_string("/proc/self/status") {
+                    for l in s.lines() {
+                        let mut fields = l.split_whitespace();
+                        if fields.next() == Some("Seccomp:") &&
+                            fields.next() != Some("0")
+                        {
+                            skip!("{} cannot be run in Seccomp mode.  Skipping test.",
+                                stringify!($name));
+                        }
+                    }
+                }
+            }
+        }
+    } else if #[cfg(not(target_os = "redox"))] {
+        #[macro_export] macro_rules! skip_if_seccomp {
+            ($name:expr) => {}
+        }
+    }
+}
+
+cfg_if! {
+    if #[cfg(target_os = "linux")] {
+        #[macro_export] macro_rules! require_kernel_version {
+            ($name:expr, $version_requirement:expr) => {
+                use semver::{Version, VersionReq};
+
+                let version_requirement = VersionReq::parse($version_requirement)
+                        .expect("Bad match_version provided");
+
+                let uname = nix::sys::utsname::uname();
+                println!("{}", uname.sysname());
+                println!("{}", uname.nodename());
+                println!("{}", uname.release());
+                println!("{}", uname.version());
+                println!("{}", uname.machine());
+
+                // Fix stuff that the semver parser can't handle
+                let fixed_release = &uname.release().to_string()
+                    // Fedora 33 reports version as 4.18.el8_2.x86_64 or
+                    // 5.18.200-fc33.x86_64.  Remove the underscore.
+                    .replace("_", "-")
+                    // Cirrus-CI reports version as 4.19.112+ .  Remove the +
+                    .replace("+", "");
+                let mut version = Version::parse(fixed_release).unwrap();
+
+                //Keep only numeric parts
+                version.pre = semver::Prerelease::EMPTY;
+                version.build = semver::BuildMetadata::EMPTY;
+
+                if !version_requirement.matches(&version) {
+                    skip!("Skip {} because kernel version `{}` doesn't match the requirement `{}`",
+                        stringify!($name), version, version_requirement);
+                }
+            }
+        }
+    }
+}
diff --git a/third_party/rust/nix/test/sys/mod.rs b/third_party/rust/nix/test/sys/mod.rs
index 60a58dd106f19..e73d9b1dc673c 100644
--- a/third_party/rust/nix/test/sys/mod.rs
+++ b/third_party/rust/nix/test/sys/mod.rs
@@ -11,14 +11,21 @@ mod test_signal;
           target_os = "macos",
           target_os = "netbsd"))]
 mod test_aio;
+#[cfg(not(target_os = "redox"))]
+mod test_mman;
 #[cfg(target_os = "linux")]
 mod test_signalfd;
+#[cfg(not(target_os = "redox"))]
 mod test_socket;
+#[cfg(not(target_os = "redox"))]
 mod test_sockopt;
+#[cfg(not(target_os = "redox"))]
 mod test_select;
 #[cfg(any(target_os = "android", target_os = "linux"))]
 mod test_sysinfo;
+#[cfg(not(any(target_os = "redox", target_os = "fuchsia")))]
 mod test_termios;
+#[cfg(not(any(target_os = "redox", target_os = "fuchsia")))]
 mod test_ioctl;
 mod test_wait;
 mod test_uio;
@@ -36,3 +43,5 @@ mod test_pthread;
           target_os = "netbsd",
           target_os = "openbsd"))]
 mod test_ptrace;
+#[cfg(any(target_os = "android", target_os = "linux"))]
+mod test_timerfd;
diff --git a/third_party/rust/nix/test/sys/test_aio.rs b/third_party/rust/nix/test/sys/test_aio.rs
index d4b09b0b81905..80cd053f8defa 100644
--- a/third_party/rust/nix/test/sys/test_aio.rs
+++ b/third_party/rust/nix/test/sys/test_aio.rs
@@ -1,6 +1,5 @@
-use bytes::{Bytes, BytesMut};
 use libc::{c_int, c_void};
-use nix::{Error, Result};
+use nix::Result;
 use nix::errno::*;
 use nix::sys::aio::*;
 use nix::sys::signal::{SaFlags, SigAction, sigaction, SigevNotify, SigHandler, Signal, SigSet};
@@ -8,15 +7,26 @@ use nix::sys::time::{TimeSpec, TimeValLike};
 use std::io::{Write, Read, Seek, SeekFrom};
 use std::ops::Deref;
 use std::os::unix::io::AsRawFd;
+use std::pin::Pin;
 use std::sync::atomic::{AtomicBool, Ordering};
 use std::{thread, time};
 use tempfile::tempfile;
 
 // Helper that polls an AioCb for completion or error
-fn poll_aio(aiocb: &mut AioCb) -> Result<()> {
+fn poll_aio(aiocb: &mut Pin<Box<AioCb>>) -> Result<()> {
     loop {
         let err = aiocb.error();
-        if err != Err(Error::from(Errno::EINPROGRESS)) { return err; };
+        if err != Err(Errno::EINPROGRESS) { return err; };
+        thread::sleep(time::Duration::from_millis(10));
+    }
+}
+
+// Helper that polls a component of an LioCb for completion or error
+#[cfg(not(any(target_os = "ios", target_os = "macos")))]
+fn poll_lio(liocb: &mut LioCb, i: usize) -> Result<()> {
+    loop {
+        let err = liocb.error(i);
+        if err != Err(Errno::EINPROGRESS) { return err; };
         thread::sleep(time::Duration::from_millis(10));
     }
 }
@@ -47,7 +57,7 @@ fn test_accessors() {
 // our bindings.  So it's sufficient to check that AioCb.cancel returned any
 // AioCancelStat value.
 #[test]
-#[cfg_attr(all(target_env = "musl", target_arch = "x86_64"), ignore)]
+#[cfg_attr(target_env = "musl", ignore)]
 fn test_cancel() {
     let wbuf: &[u8] = b"CDEF";
 
@@ -60,7 +70,7 @@ fn test_cancel() {
                             LioOpcode::LIO_NOP);
     aiocb.write().unwrap();
     let err = aiocb.error();
-    assert!(err == Ok(()) || err == Err(Error::from(Errno::EINPROGRESS)));
+    assert!(err == Ok(()) || err == Err(Errno::EINPROGRESS));
 
     let cancelstat = aiocb.cancel();
     assert!(cancelstat.is_ok());
@@ -72,7 +82,7 @@ fn test_cancel() {
 
 // Tests using aio_cancel_all for all outstanding IOs.
 #[test]
-#[cfg_attr(all(target_env = "musl", target_arch = "x86_64"), ignore)]
+#[cfg_attr(target_env = "musl", ignore)]
 fn test_aio_cancel_all() {
     let wbuf: &[u8] = b"CDEF";
 
@@ -85,7 +95,7 @@ fn test_aio_cancel_all() {
                             LioOpcode::LIO_NOP);
     aiocb.write().unwrap();
     let err = aiocb.error();
-    assert!(err == Ok(()) || err == Err(Error::from(Errno::EINPROGRESS)));
+    assert!(err == Ok(()) || err == Err(Errno::EINPROGRESS));
 
     let cancelstat = aio_cancel_all(f.as_raw_fd());
     assert!(cancelstat.is_ok());
@@ -132,7 +142,12 @@ fn test_fsync_error() {
 }
 
 #[test]
-#[cfg_attr(all(target_env = "musl", target_arch = "x86_64"), ignore)]
+// On Cirrus on Linux, this test fails due to a glibc bug.
+// https://github.com/nix-rust/nix/issues/1099
+#[cfg_attr(target_os = "linux", ignore)]
+// On Cirrus, aio_suspend is failing with EINVAL
+// https://github.com/nix-rust/nix/issues/1361
+#[cfg_attr(target_os = "macos", ignore)]
 fn test_aio_suspend() {
     const INITIAL: &[u8] = b"abcdef123456";
     const WBUF: &[u8] = b"CDEFG";
@@ -159,17 +174,22 @@ fn test_aio_suspend() {
     rcb.read().unwrap();
     loop {
         {
-            let cbbuf = [&wcb, &rcb];
-            assert!(aio_suspend(&cbbuf[..], Some(timeout)).is_ok());
+            let cbbuf = [wcb.as_ref(), rcb.as_ref()];
+            let r = aio_suspend(&cbbuf[..], Some(timeout));
+            match r {
+                Err(Errno::EINTR) => continue,
+                Err(e) => panic!("aio_suspend returned {:?}", e),
+                Ok(_) => ()
+            };
         }
-        if rcb.error() != Err(Error::from(Errno::EINPROGRESS)) &&
-           wcb.error() != Err(Error::from(Errno::EINPROGRESS)) {
+        if rcb.error() != Err(Errno::EINPROGRESS) &&
+           wcb.error() != Err(Errno::EINPROGRESS) {
             break
         }
     }
 
-    assert!(wcb.aio_return().unwrap() as usize == WBUF.len());
-    assert!(rcb.aio_return().unwrap() as usize == rlen);
+    assert_eq!(wcb.aio_return().unwrap() as usize, WBUF.len());
+    assert_eq!(rcb.aio_return().unwrap() as usize, rlen);
 }
 
 // Test a simple aio operation with no completion notification.  We must poll
@@ -192,11 +212,11 @@ fn test_read() {
         aiocb.read().unwrap();
 
         let err = poll_aio(&mut aiocb);
-        assert!(err == Ok(()));
-        assert!(aiocb.aio_return().unwrap() as usize == EXPECT.len());
+        assert_eq!(err, Ok(()));
+        assert_eq!(aiocb.aio_return().unwrap() as usize, EXPECT.len());
     }
 
-    assert!(EXPECT == rbuf.deref().deref());
+    assert_eq!(EXPECT, rbuf.deref().deref());
 }
 
 /// `AioCb::read` should not modify the `AioCb` object if `libc::aio_read`
@@ -238,11 +258,11 @@ fn test_read_into_mut_slice() {
         aiocb.read().unwrap();
 
         let err = poll_aio(&mut aiocb);
-        assert!(err == Ok(()));
-        assert!(aiocb.aio_return().unwrap() as usize == EXPECT.len());
+        assert_eq!(err, Ok(()));
+        assert_eq!(aiocb.aio_return().unwrap() as usize, EXPECT.len());
     }
 
-    assert!(rbuf == EXPECT);
+    assert_eq!(rbuf, EXPECT);
 }
 
 // Tests from_ptr
@@ -268,11 +288,11 @@ fn test_read_into_pointer() {
         aiocb.read().unwrap();
 
         let err = poll_aio(&mut aiocb);
-        assert!(err == Ok(()));
-        assert!(aiocb.aio_return().unwrap() as usize == EXPECT.len());
+        assert_eq!(err, Ok(()));
+        assert_eq!(aiocb.aio_return().unwrap() as usize, EXPECT.len());
     }
 
-    assert!(rbuf == EXPECT);
+    assert_eq!(rbuf, EXPECT);
 }
 
 // Test reading into an immutable buffer.  It should fail
@@ -314,68 +334,13 @@ fn test_write() {
     aiocb.write().unwrap();
 
     let err = poll_aio(&mut aiocb);
-    assert!(err == Ok(()));
-    assert!(aiocb.aio_return().unwrap() as usize == wbuf.len());
-
-    f.seek(SeekFrom::Start(0)).unwrap();
-    let len = f.read_to_end(&mut rbuf).unwrap();
-    assert!(len == EXPECT.len());
-    assert!(rbuf == EXPECT);
-}
-
-// Tests `AioCb::from_boxed_slice` with `Bytes`
-#[test]
-#[cfg_attr(all(target_env = "musl", target_arch = "x86_64"), ignore)]
-fn test_write_bytes() {
-    const INITIAL: &[u8] = b"abcdef123456";
-    let wbuf = Box::new(Bytes::from(&b"CDEF"[..]));
-    let mut rbuf = Vec::new();
-    const EXPECT: &[u8] = b"abCDEF123456";
-    let expected_len = wbuf.len();
-
-    let mut f = tempfile().unwrap();
-    f.write_all(INITIAL).unwrap();
-    let mut aiocb = AioCb::from_boxed_slice( f.as_raw_fd(),
-                           2,   //offset
-                           wbuf,
-                           0,   //priority
-                           SigevNotify::SigevNone,
-                           LioOpcode::LIO_NOP);
-    aiocb.write().unwrap();
-
-    let err = poll_aio(&mut aiocb);
-    assert!(err == Ok(()));
-    assert!(aiocb.aio_return().unwrap() as usize == expected_len);
+    assert_eq!(err, Ok(()));
+    assert_eq!(aiocb.aio_return().unwrap() as usize, wbuf.len());
 
     f.seek(SeekFrom::Start(0)).unwrap();
     let len = f.read_to_end(&mut rbuf).unwrap();
-    assert!(len == EXPECT.len());
-    assert!(rbuf == EXPECT);
-}
-
-// Tests `AioCb::from_boxed_mut_slice` with `BytesMut`
-#[test]
-#[cfg_attr(all(target_env = "musl", target_arch = "x86_64"), ignore)]
-fn test_read_bytes_mut_small() {
-    const INITIAL: &[u8] = b"abcdef";
-    let rbuf = Box::new(BytesMut::from(vec![0; 4]));
-    const EXPECT: &[u8] = b"cdef";
-    let mut f = tempfile().unwrap();
-    f.write_all(INITIAL).unwrap();
-
-    let mut aiocb = AioCb::from_boxed_mut_slice( f.as_raw_fd(),
-                           2,   //offset
-                           rbuf,
-                           0,   //priority
-                           SigevNotify::SigevNone,
-                           LioOpcode::LIO_NOP);
-    aiocb.read().unwrap();
-
-    let err = poll_aio(&mut aiocb);
-    assert_eq!(err, Ok(()));
-    assert_eq!(aiocb.aio_return().unwrap() as usize, EXPECT.len());
-    let buffer = aiocb.boxed_mut_slice().unwrap();
-    assert_eq!(buffer.borrow(), EXPECT);
+    assert_eq!(len, EXPECT.len());
+    assert_eq!(rbuf, EXPECT);
 }
 
 // Tests `AioCb::from_ptr`
@@ -402,13 +367,13 @@ fn test_write_from_pointer() {
     aiocb.write().unwrap();
 
     let err = poll_aio(&mut aiocb);
-    assert!(err == Ok(()));
-    assert!(aiocb.aio_return().unwrap() as usize == wbuf.len());
+    assert_eq!(err, Ok(()));
+    assert_eq!(aiocb.aio_return().unwrap() as usize, wbuf.len());
 
     f.seek(SeekFrom::Start(0)).unwrap();
     let len = f.read_to_end(&mut rbuf).unwrap();
-    assert!(len == EXPECT.len());
-    assert!(rbuf == EXPECT);
+    assert_eq!(len, EXPECT.len());
+    assert_eq!(rbuf, EXPECT);
 }
 
 /// `AioCb::write` should not modify the `AioCb` object if `libc::aio_write`
@@ -441,7 +406,7 @@ extern fn sigfunc(_: c_int) {
 #[test]
 #[cfg_attr(any(all(target_env = "musl", target_arch = "x86_64"), target_arch = "mips", target_arch = "mips64"), ignore)]
 fn test_write_sigev_signal() {
-    let _m = ::SIGNAL_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::SIGNAL_MTX.lock();
     let sa = SigAction::new(SigHandler::Handler(sigfunc),
                             SaFlags::SA_RESETHAND,
                             SigSet::empty());
@@ -469,11 +434,11 @@ fn test_write_sigev_signal() {
         thread::sleep(time::Duration::from_millis(10));
     }
 
-    assert!(aiocb.aio_return().unwrap() as usize == WBUF.len());
+    assert_eq!(aiocb.aio_return().unwrap() as usize, WBUF.len());
     f.seek(SeekFrom::Start(0)).unwrap();
     let len = f.read_to_end(&mut rbuf).unwrap();
-    assert!(len == EXPECT.len());
-    assert!(rbuf == EXPECT);
+    assert_eq!(len, EXPECT.len());
+    assert_eq!(rbuf, EXPECT);
 }
 
 // Test LioCb::listio with LIO_WAIT, so all AIO ops should be complete by the
@@ -493,34 +458,34 @@ fn test_liocb_listio_wait() {
     f.write_all(INITIAL).unwrap();
 
     {
-        let wcb = AioCb::from_slice( f.as_raw_fd(),
-                               2,   //offset
-                               WBUF,
-                               0,   //priority
-                               SigevNotify::SigevNone,
-                               LioOpcode::LIO_WRITE);
-
-        let rcb = AioCb::from_mut_slice( f.as_raw_fd(),
-                                8,   //offset
-                                &mut rbuf,
-                                0,   //priority
-                                SigevNotify::SigevNone,
-                                LioOpcode::LIO_READ);
-        let mut liocb = LioCb::with_capacity(2);
-        liocb.aiocbs.push(wcb);
-        liocb.aiocbs.push(rcb);
+        let mut liocb = LioCbBuilder::with_capacity(2)
+            .emplace_slice(
+                f.as_raw_fd(),
+                2,   //offset
+                WBUF,
+                0,   //priority
+                SigevNotify::SigevNone,
+                LioOpcode::LIO_WRITE
+            ).emplace_mut_slice(
+                f.as_raw_fd(),
+                8,   //offset
+                &mut rbuf,
+                0,   //priority
+                SigevNotify::SigevNone,
+                LioOpcode::LIO_READ
+            ).finish();
         let err = liocb.listio(LioMode::LIO_WAIT, SigevNotify::SigevNone);
         err.expect("lio_listio");
 
-        assert!(liocb.aio_return(0).unwrap() as usize == WBUF.len());
-        assert!(liocb.aio_return(1).unwrap() as usize == rlen);
+        assert_eq!(liocb.aio_return(0).unwrap() as usize, WBUF.len());
+        assert_eq!(liocb.aio_return(1).unwrap() as usize, rlen);
     }
-    assert!(rbuf.deref().deref() == b"3456");
+    assert_eq!(rbuf.deref().deref(), b"3456");
 
     f.seek(SeekFrom::Start(0)).unwrap();
     let len = f.read_to_end(&mut rbuf2).unwrap();
-    assert!(len == EXPECT.len());
-    assert!(rbuf2 == EXPECT);
+    assert_eq!(len, EXPECT.len());
+    assert_eq!(rbuf2, EXPECT);
 }
 
 // Test LioCb::listio with LIO_NOWAIT and no SigEvent, so we must use some other
@@ -540,36 +505,36 @@ fn test_liocb_listio_nowait() {
     f.write_all(INITIAL).unwrap();
 
     {
-        let wcb = AioCb::from_slice( f.as_raw_fd(),
-                               2,   //offset
-                               WBUF,
-                               0,   //priority
-                               SigevNotify::SigevNone,
-                               LioOpcode::LIO_WRITE);
-
-        let rcb = AioCb::from_mut_slice( f.as_raw_fd(),
-                                8,   //offset
-                                &mut rbuf,
-                                0,   //priority
-                                SigevNotify::SigevNone,
-                                LioOpcode::LIO_READ);
-        let mut liocb = LioCb::with_capacity(2);
-        liocb.aiocbs.push(wcb);
-        liocb.aiocbs.push(rcb);
+        let mut liocb = LioCbBuilder::with_capacity(2)
+            .emplace_slice(
+                f.as_raw_fd(),
+                2,   //offset
+                WBUF,
+                0,   //priority
+                SigevNotify::SigevNone,
+                LioOpcode::LIO_WRITE
+            ).emplace_mut_slice(
+                f.as_raw_fd(),
+                8,   //offset
+                &mut rbuf,
+                0,   //priority
+                SigevNotify::SigevNone,
+                LioOpcode::LIO_READ
+            ).finish();
         let err = liocb.listio(LioMode::LIO_NOWAIT, SigevNotify::SigevNone);
         err.expect("lio_listio");
 
-        poll_aio(&mut liocb.aiocbs[0]).unwrap();
-        poll_aio(&mut liocb.aiocbs[1]).unwrap();
-        assert!(liocb.aiocbs[0].aio_return().unwrap() as usize == WBUF.len());
-        assert!(liocb.aiocbs[1].aio_return().unwrap() as usize == rlen);
+        poll_lio(&mut liocb, 0).unwrap();
+        poll_lio(&mut liocb, 1).unwrap();
+        assert_eq!(liocb.aio_return(0).unwrap() as usize, WBUF.len());
+        assert_eq!(liocb.aio_return(1).unwrap() as usize, rlen);
     }
-    assert!(rbuf.deref().deref() == b"3456");
+    assert_eq!(rbuf.deref().deref(), b"3456");
 
     f.seek(SeekFrom::Start(0)).unwrap();
     let len = f.read_to_end(&mut rbuf2).unwrap();
-    assert!(len == EXPECT.len());
-    assert!(rbuf2 == EXPECT);
+    assert_eq!(len, EXPECT.len());
+    assert_eq!(rbuf2, EXPECT);
 }
 
 // Test LioCb::listio with LIO_NOWAIT and a SigEvent to indicate when all
@@ -579,7 +544,7 @@ fn test_liocb_listio_nowait() {
 #[cfg(not(any(target_os = "ios", target_os = "macos")))]
 #[cfg_attr(any(target_arch = "mips", target_arch = "mips64", target_env = "musl"), ignore)]
 fn test_liocb_listio_signal() {
-    let _m = ::SIGNAL_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::SIGNAL_MTX.lock();
     const INITIAL: &[u8] = b"abcdef123456";
     const WBUF: &[u8] = b"CDEF";
     let mut rbuf = vec![0; 4];
@@ -596,22 +561,22 @@ fn test_liocb_listio_signal() {
     f.write_all(INITIAL).unwrap();
 
     {
-        let wcb = AioCb::from_slice( f.as_raw_fd(),
-                               2,   //offset
-                               WBUF,
-                               0,   //priority
-                               SigevNotify::SigevNone,
-                               LioOpcode::LIO_WRITE);
-
-        let rcb = AioCb::from_mut_slice( f.as_raw_fd(),
-                                8,   //offset
-                                &mut rbuf,
-                                0,   //priority
-                                SigevNotify::SigevNone,
-                                LioOpcode::LIO_READ);
-        let mut liocb = LioCb::with_capacity(2);
-        liocb.aiocbs.push(wcb);
-        liocb.aiocbs.push(rcb);
+        let mut liocb = LioCbBuilder::with_capacity(2)
+            .emplace_slice(
+                f.as_raw_fd(),
+                2,   //offset
+                WBUF,
+                0,   //priority
+                SigevNotify::SigevNone,
+                LioOpcode::LIO_WRITE
+            ).emplace_mut_slice(
+                f.as_raw_fd(),
+                8,   //offset
+                &mut rbuf,
+                0,   //priority
+                SigevNotify::SigevNone,
+                LioOpcode::LIO_READ
+            ).finish();
         SIGNALED.store(false, Ordering::Relaxed);
         unsafe { sigaction(Signal::SIGUSR2, &sa) }.unwrap();
         let err = liocb.listio(LioMode::LIO_NOWAIT, sigev_notify);
@@ -620,15 +585,15 @@ fn test_liocb_listio_signal() {
             thread::sleep(time::Duration::from_millis(10));
         }
 
-        assert!(liocb.aiocbs[0].aio_return().unwrap() as usize == WBUF.len());
-        assert!(liocb.aiocbs[1].aio_return().unwrap() as usize == rlen);
+        assert_eq!(liocb.aio_return(0).unwrap() as usize, WBUF.len());
+        assert_eq!(liocb.aio_return(1).unwrap() as usize, rlen);
     }
-    assert!(rbuf.deref().deref() == b"3456");
+    assert_eq!(rbuf.deref().deref(), b"3456");
 
     f.seek(SeekFrom::Start(0)).unwrap();
     let len = f.read_to_end(&mut rbuf2).unwrap();
-    assert!(len == EXPECT.len());
-    assert!(rbuf2 == EXPECT);
+    assert_eq!(len, EXPECT.len());
+    assert_eq!(rbuf2, EXPECT);
 }
 
 // Try to use LioCb::listio to read into an immutable buffer.  It should fail
@@ -642,13 +607,14 @@ fn test_liocb_listio_read_immutable() {
     let f = tempfile().unwrap();
 
 
-    let mut liocb = LioCb::from(vec![
-        AioCb::from_slice( f.as_raw_fd(),
+    let mut liocb = LioCbBuilder::with_capacity(1)
+        .emplace_slice(
+            f.as_raw_fd(),
             2,   //offset
             rbuf,
             0,   //priority
             SigevNotify::SigevNone,
-            LioOpcode::LIO_READ)
-    ]);
+            LioOpcode::LIO_READ
+        ).finish();
     let _ = liocb.listio(LioMode::LIO_NOWAIT, SigevNotify::SigevNone);
 }
diff --git a/third_party/rust/nix/test/sys/test_aio_drop.rs b/third_party/rust/nix/test/sys/test_aio_drop.rs
index 492da401ef726..71a2183bc1b56 100644
--- a/third_party/rust/nix/test/sys/test_aio_drop.rs
+++ b/third_party/rust/nix/test/sys/test_aio_drop.rs
@@ -1,6 +1,3 @@
-extern crate nix;
-extern crate tempfile;
-
 // Test dropping an AioCb that hasn't yet finished.
 // This must happen in its own process, because on OSX this test seems to hose
 // the AIO subsystem and causes subsequent tests to fail
diff --git a/third_party/rust/nix/test/sys/test_epoll.rs b/third_party/rust/nix/test/sys/test_epoll.rs
index e0dc5131defe0..8d44cd08f01c9 100644
--- a/third_party/rust/nix/test/sys/test_epoll.rs
+++ b/third_party/rust/nix/test/sys/test_epoll.rs
@@ -1,6 +1,5 @@
 use nix::sys::epoll::{EpollCreateFlags, EpollFlags, EpollOp, EpollEvent};
 use nix::sys::epoll::{epoll_create1, epoll_ctl};
-use nix::Error;
 use nix::errno::Errno;
 
 #[test]
@@ -8,11 +7,11 @@ pub fn test_epoll_errno() {
     let efd = epoll_create1(EpollCreateFlags::empty()).unwrap();
     let result = epoll_ctl(efd, EpollOp::EpollCtlDel, 1, None);
     assert!(result.is_err());
-    assert_eq!(result.unwrap_err(), Error::Sys(Errno::ENOENT));
+    assert_eq!(result.unwrap_err(), Errno::ENOENT);
 
     let result = epoll_ctl(efd, EpollOp::EpollCtlAdd, 1, None);
     assert!(result.is_err());
-    assert_eq!(result.unwrap_err(), Error::Sys(Errno::EINVAL));
+    assert_eq!(result.unwrap_err(), Errno::EINVAL);
 }
 
 #[test]
diff --git a/third_party/rust/nix/test/sys/test_inotify.rs b/third_party/rust/nix/test/sys/test_inotify.rs
index a8ead46d487ba..137816a352086 100644
--- a/third_party/rust/nix/test/sys/test_inotify.rs
+++ b/third_party/rust/nix/test/sys/test_inotify.rs
@@ -1,7 +1,5 @@
 use nix::sys::inotify::{AddWatchFlags,InitFlags,Inotify};
-use nix::Error;
 use nix::errno::Errno;
-use tempfile;
 use std::ffi::OsString;
 use std::fs::{rename, File};
 
@@ -14,7 +12,7 @@ pub fn test_inotify() {
     instance.add_watch(tempdir.path(), AddWatchFlags::IN_ALL_EVENTS).unwrap();
 
     let events = instance.read_events();
-    assert_eq!(events.unwrap_err(), Error::Sys(Errno::EAGAIN));
+    assert_eq!(events.unwrap_err(), Errno::EAGAIN);
 
     File::create(tempdir.path().join("test")).unwrap();
 
@@ -31,7 +29,7 @@ pub fn test_inotify_multi_events() {
     instance.add_watch(tempdir.path(), AddWatchFlags::IN_ALL_EVENTS).unwrap();
 
     let events = instance.read_events();
-    assert_eq!(events.unwrap_err(), Error::Sys(Errno::EAGAIN));
+    assert_eq!(events.unwrap_err(), Errno::EAGAIN);
 
     File::create(tempdir.path().join("test")).unwrap();
     rename(tempdir.path().join("test"), tempdir.path().join("test2")).unwrap();
diff --git a/third_party/rust/nix/test/sys/test_ioctl.rs b/third_party/rust/nix/test/sys/test_ioctl.rs
index 0a439b3346f53..236d24268a738 100644
--- a/third_party/rust/nix/test/sys/test_ioctl.rs
+++ b/third_party/rust/nix/test/sys/test_ioctl.rs
@@ -33,22 +33,22 @@ mod linux {
     #[test]
     fn test_op_none() {
         if cfg!(any(target_arch = "mips", target_arch = "mips64", target_arch="powerpc", target_arch="powerpc64")){
-            assert_eq!(request_code_none!(b'q', 10), 0x2000_710A);
-            assert_eq!(request_code_none!(b'a', 255), 0x2000_61FF);
+            assert_eq!(request_code_none!(b'q', 10) as u32, 0x2000_710A);
+            assert_eq!(request_code_none!(b'a', 255) as u32, 0x2000_61FF);
         } else {
-            assert_eq!(request_code_none!(b'q', 10), 0x0000_710A);
-            assert_eq!(request_code_none!(b'a', 255), 0x0000_61FF);
+            assert_eq!(request_code_none!(b'q', 10) as u32, 0x0000_710A);
+            assert_eq!(request_code_none!(b'a', 255) as u32, 0x0000_61FF);
         }
     }
 
     #[test]
     fn test_op_write() {
         if cfg!(any(target_arch = "mips", target_arch = "mips64", target_arch="powerpc", target_arch="powerpc64")){
-            assert_eq!(request_code_write!(b'z', 10, 1), 0x8001_7A0A);
-            assert_eq!(request_code_write!(b'z', 10, 512), 0x8200_7A0A);
+            assert_eq!(request_code_write!(b'z', 10, 1) as u32, 0x8001_7A0A);
+            assert_eq!(request_code_write!(b'z', 10, 512) as u32, 0x8200_7A0A);
         } else {
-            assert_eq!(request_code_write!(b'z', 10, 1), 0x4001_7A0A);
-            assert_eq!(request_code_write!(b'z', 10, 512), 0x4200_7A0A);
+            assert_eq!(request_code_write!(b'z', 10, 1) as u32, 0x4001_7A0A);
+            assert_eq!(request_code_write!(b'z', 10, 512) as u32, 0x4200_7A0A);
         }
     }
 
@@ -56,9 +56,11 @@ mod linux {
     #[test]
     fn test_op_write_64() {
         if cfg!(any(target_arch = "mips64", target_arch="powerpc64")){
-            assert_eq!(request_code_write!(b'z', 10, (1 as u64) << 32), 0x8000_7A0A);
+            assert_eq!(request_code_write!(b'z', 10, 1u64 << 32) as u32,
+                       0x8000_7A0A);
         } else {
-            assert_eq!(request_code_write!(b'z', 10, (1 as u64) << 32), 0x4000_7A0A);
+            assert_eq!(request_code_write!(b'z', 10, 1u64 << 32) as u32,
+                       0x4000_7A0A);
         }
 
     }
@@ -66,11 +68,11 @@ mod linux {
     #[test]
     fn test_op_read() {
         if cfg!(any(target_arch = "mips", target_arch = "mips64", target_arch="powerpc", target_arch="powerpc64")){
-            assert_eq!(request_code_read!(b'z', 10, 1), 0x4001_7A0A);
-            assert_eq!(request_code_read!(b'z', 10, 512), 0x4200_7A0A);
+            assert_eq!(request_code_read!(b'z', 10, 1) as u32, 0x4001_7A0A);
+            assert_eq!(request_code_read!(b'z', 10, 512) as u32, 0x4200_7A0A);
         } else {
-            assert_eq!(request_code_read!(b'z', 10, 1), 0x8001_7A0A);
-            assert_eq!(request_code_read!(b'z', 10, 512), 0x8200_7A0A);
+            assert_eq!(request_code_read!(b'z', 10, 1) as u32, 0x8001_7A0A);
+            assert_eq!(request_code_read!(b'z', 10, 512) as u32, 0x8200_7A0A);
         }
     }
 
@@ -78,22 +80,25 @@ mod linux {
     #[test]
     fn test_op_read_64() {
         if cfg!(any(target_arch = "mips64", target_arch="powerpc64")){
-            assert_eq!(request_code_read!(b'z', 10, (1 as u64) << 32), 0x4000_7A0A);
+            assert_eq!(request_code_read!(b'z', 10, 1u64 << 32) as u32,
+                       0x4000_7A0A);
         } else {
-            assert_eq!(request_code_read!(b'z', 10, (1 as u64) << 32), 0x8000_7A0A);
+            assert_eq!(request_code_read!(b'z', 10, 1u64 << 32) as u32,
+                       0x8000_7A0A);
         }
     }
 
     #[test]
     fn test_op_read_write() {
-        assert_eq!(request_code_readwrite!(b'z', 10, 1), 0xC001_7A0A);
-        assert_eq!(request_code_readwrite!(b'z', 10, 512), 0xC200_7A0A);
+        assert_eq!(request_code_readwrite!(b'z', 10, 1) as u32, 0xC001_7A0A);
+        assert_eq!(request_code_readwrite!(b'z', 10, 512) as u32, 0xC200_7A0A);
     }
 
     #[cfg(target_pointer_width = "64")]
     #[test]
     fn test_op_read_write_64() {
-        assert_eq!(request_code_readwrite!(b'z', 10, (1 as u64) << 32), 0xC000_7A0A);
+        assert_eq!(request_code_readwrite!(b'z', 10, 1u64 << 32) as u32,
+                   0xC000_7A0A);
     }
 }
 
@@ -126,7 +131,7 @@ mod bsd {
     #[cfg(target_pointer_width = "64")]
     #[test]
     fn test_op_write_64() {
-        assert_eq!(request_code_write!(b'z', 10, (1 as u64) << 32), 0x8000_7A0A);
+        assert_eq!(request_code_write!(b'z', 10, 1u64 << 32), 0x8000_7A0A);
     }
 
     #[test]
@@ -138,7 +143,7 @@ mod bsd {
     #[cfg(target_pointer_width = "64")]
     #[test]
     fn test_op_read_64() {
-        assert_eq!(request_code_read!(b'z', 10, (1 as u64) << 32), 0x4000_7A0A);
+        assert_eq!(request_code_read!(b'z', 10, 1u64 << 32), 0x4000_7A0A);
     }
 
     #[test]
@@ -150,7 +155,7 @@ mod bsd {
     #[cfg(target_pointer_width = "64")]
     #[test]
     fn test_op_read_write_64() {
-        assert_eq!(request_code_readwrite!(b'z', 10, (1 as u64) << 32), 0xC000_7A0A);
+        assert_eq!(request_code_readwrite!(b'z', 10, 1u64 << 32), 0xC000_7A0A);
     }
 }
 
@@ -162,24 +167,23 @@ mod linux_ioctls {
     use tempfile::tempfile;
     use libc::{TCGETS, TCSBRK, TCSETS, TIOCNXCL, termios};
 
-    use nix::Error::Sys;
-    use nix::errno::Errno::{ENOTTY, ENOSYS};
+    use nix::errno::Errno;
 
     ioctl_none_bad!(tiocnxcl, TIOCNXCL);
     #[test]
     fn test_ioctl_none_bad() {
         let file = tempfile().unwrap();
         let res = unsafe { tiocnxcl(file.as_raw_fd()) };
-        assert_eq!(res, Err(Sys(ENOTTY)));
+        assert_eq!(res, Err(Errno::ENOTTY));
     }
 
     ioctl_read_bad!(tcgets, TCGETS, termios);
     #[test]
     fn test_ioctl_read_bad() {
         let file = tempfile().unwrap();
-        let mut termios = unsafe { mem::uninitialized() };
+        let mut termios = unsafe { mem::zeroed() };
         let res = unsafe { tcgets(file.as_raw_fd(), &mut termios) };
-        assert_eq!(res, Err(Sys(ENOTTY)));
+        assert_eq!(res, Err(Errno::ENOTTY));
     }
 
     ioctl_write_int_bad!(tcsbrk, TCSBRK);
@@ -187,16 +191,16 @@ mod linux_ioctls {
     fn test_ioctl_write_int_bad() {
         let file = tempfile().unwrap();
         let res = unsafe { tcsbrk(file.as_raw_fd(), 0) };
-        assert_eq!(res, Err(Sys(ENOTTY)));
+        assert_eq!(res, Err(Errno::ENOTTY));
     }
 
     ioctl_write_ptr_bad!(tcsets, TCSETS, termios);
     #[test]
     fn test_ioctl_write_ptr_bad() {
         let file = tempfile().unwrap();
-        let termios: termios = unsafe { mem::uninitialized() };
+        let termios: termios = unsafe { mem::zeroed() };
         let res = unsafe { tcsets(file.as_raw_fd(), &termios) };
-        assert_eq!(res, Err(Sys(ENOTTY)));
+        assert_eq!(res, Err(Errno::ENOTTY));
     }
 
     // FIXME: Find a suitable example for `ioctl_readwrite_bad`
@@ -207,7 +211,7 @@ mod linux_ioctls {
     fn test_ioctl_none() {
         let file = tempfile().unwrap();
         let res = unsafe { log_status(file.as_raw_fd()) };
-        assert!(res == Err(Sys(ENOTTY)) || res == Err(Sys(ENOSYS)));
+        assert!(res == Err(Errno::ENOTTY) || res == Err(Errno::ENOSYS));
     }
 
     #[repr(C)]
@@ -226,7 +230,7 @@ mod linux_ioctls {
         let file = tempfile().unwrap();
         let data: v4l2_audio = unsafe { mem::zeroed() };
         let res = unsafe { s_audio(file.as_raw_fd(), &data) };
-        assert!(res == Err(Sys(ENOTTY)) || res == Err(Sys(ENOSYS)));
+        assert!(res == Err(Errno::ENOTTY) || res == Err(Errno::ENOSYS));
     }
 
     // From linux/net/bluetooth/hci_sock.h
@@ -237,7 +241,7 @@ mod linux_ioctls {
     fn test_ioctl_write_int() {
         let file = tempfile().unwrap();
         let res = unsafe { hcidevup(file.as_raw_fd(), 0) };
-        assert!(res == Err(Sys(ENOTTY)) || res == Err(Sys(ENOSYS)));
+        assert!(res == Err(Errno::ENOTTY) || res == Err(Errno::ENOSYS));
     }
 
     // From linux/videodev2.h
@@ -245,9 +249,9 @@ mod linux_ioctls {
     #[test]
     fn test_ioctl_read() {
         let file = tempfile().unwrap();
-        let mut data: v4l2_audio = unsafe { mem::uninitialized() };
+        let mut data: v4l2_audio = unsafe { mem::zeroed() };
         let res = unsafe { g_audio(file.as_raw_fd(), &mut data) };
-        assert!(res == Err(Sys(ENOTTY)) || res == Err(Sys(ENOSYS)));
+        assert!(res == Err(Errno::ENOTTY) || res == Err(Errno::ENOSYS));
     }
 
     // From linux/videodev2.h
@@ -255,9 +259,9 @@ mod linux_ioctls {
     #[test]
     fn test_ioctl_readwrite() {
         let file = tempfile().unwrap();
-        let mut data: v4l2_audio = unsafe { mem::uninitialized() };
+        let mut data: v4l2_audio = unsafe { mem::zeroed() };
         let res = unsafe { enum_audio(file.as_raw_fd(), &mut data) };
-        assert!(res == Err(Sys(ENOTTY)) || res == Err(Sys(ENOSYS)));
+        assert!(res == Err(Errno::ENOTTY) || res == Err(Errno::ENOSYS));
     }
 
     // FIXME: Find a suitable example for `ioctl_read_buf`.
@@ -283,7 +287,7 @@ mod linux_ioctls {
         let file = tempfile().unwrap();
         let data: [spi_ioc_transfer; 4] = unsafe { mem::zeroed() };
         let res = unsafe { spi_ioc_message(file.as_raw_fd(), &data[..]) };
-        assert!(res == Err(Sys(ENOTTY)) || res == Err(Sys(ENOSYS)));
+        assert!(res == Err(Errno::ENOTTY) || res == Err(Errno::ENOSYS));
     }
 
     // FIXME: Find a suitable example for `ioctl_readwrite_buf`.
@@ -297,8 +301,7 @@ mod freebsd_ioctls {
     use tempfile::tempfile;
     use libc::termios;
 
-    use nix::Error::Sys;
-    use nix::errno::Errno::ENOTTY;
+    use nix::errno::Errno;
 
     // From sys/sys/ttycom.h
     const TTY_IOC_MAGIC: u8 = b't';
@@ -311,24 +314,24 @@ mod freebsd_ioctls {
     fn test_ioctl_none() {
         let file = tempfile().unwrap();
         let res = unsafe { tiocnxcl(file.as_raw_fd()) };
-        assert_eq!(res, Err(Sys(ENOTTY)));
+        assert_eq!(res, Err(Errno::ENOTTY));
     }
 
     ioctl_read!(tiocgeta, TTY_IOC_MAGIC, TTY_IOC_TYPE_GETA, termios);
     #[test]
     fn test_ioctl_read() {
         let file = tempfile().unwrap();
-        let mut termios = unsafe { mem::uninitialized() };
+        let mut termios = unsafe { mem::zeroed() };
         let res = unsafe { tiocgeta(file.as_raw_fd(), &mut termios) };
-        assert_eq!(res, Err(Sys(ENOTTY)));
+        assert_eq!(res, Err(Errno::ENOTTY));
     }
 
     ioctl_write_ptr!(tiocseta, TTY_IOC_MAGIC, TTY_IOC_TYPE_SETA, termios);
     #[test]
     fn test_ioctl_write_ptr() {
         let file = tempfile().unwrap();
-        let termios: termios = unsafe { mem::uninitialized() };
+        let termios: termios = unsafe { mem::zeroed() };
         let res = unsafe { tiocseta(file.as_raw_fd(), &termios) };
-        assert_eq!(res, Err(Sys(ENOTTY)));
+        assert_eq!(res, Err(Errno::ENOTTY));
     }
 }
diff --git a/third_party/rust/nix/test/sys/test_lio_listio_resubmit.rs b/third_party/rust/nix/test/sys/test_lio_listio_resubmit.rs
index 19ee3facf87d7..c9077891cb192 100644
--- a/third_party/rust/nix/test/sys/test_lio_listio_resubmit.rs
+++ b/third_party/rust/nix/test/sys/test_lio_listio_resubmit.rs
@@ -4,11 +4,6 @@
 // we must disable the test here rather than in Cargo.toml
 #![cfg(target_os = "freebsd")]
 
-extern crate nix;
-extern crate sysctl;
-extern crate tempfile;
-
-use nix::Error;
 use nix::errno::*;
 use nix::libc::off_t;
 use nix::sys::aio::*;
@@ -24,12 +19,12 @@ const BYTES_PER_OP: usize = 512;
 /// Attempt to collect final status for all of `liocb`'s operations, freeing
 /// system resources
 fn finish_liocb(liocb: &mut LioCb) {
-    for j in 0..liocb.aiocbs.len() {
+    for j in 0..liocb.len() {
         loop {
             let e = liocb.error(j);
             match e {
                 Ok(()) => break,
-                Err(Error::Sys(Errno::EINPROGRESS)) =>
+                Err(Errno::EINPROGRESS) =>
                     thread::sleep(time::Duration::from_millis(10)),
                 Err(x) => panic!("aio_error({:?})", x)
             }
@@ -74,21 +69,21 @@ fn test_lio_listio_resubmit() {
     }).collect::<Vec<_>>();
 
     let mut liocbs = (0..num_listios).map(|i| {
-        let mut liocb = LioCb::with_capacity(ops_per_listio);
+        let mut builder = LioCbBuilder::with_capacity(ops_per_listio);
         for j in 0..ops_per_listio {
             let offset = (BYTES_PER_OP * (i * ops_per_listio + j)) as off_t;
-            let wcb = AioCb::from_slice( f.as_raw_fd(),
-                                   offset,
-                                   &buffer_set[i][j][..],
-                                   0,   //priority
-                                   SigevNotify::SigevNone,
-                                   LioOpcode::LIO_WRITE);
-            liocb.aiocbs.push(wcb);
+            builder = builder.emplace_slice(f.as_raw_fd(),
+                                offset,
+                                &buffer_set[i][j][..],
+                                0,   //priority
+                                SigevNotify::SigevNone,
+                                LioOpcode::LIO_WRITE);
         }
+        let mut liocb = builder.finish();
         let mut err = liocb.listio(LioMode::LIO_NOWAIT, SigevNotify::SigevNone);
-        while err == Err(Error::Sys(Errno::EIO)) ||
-              err == Err(Error::Sys(Errno::EAGAIN)) ||
-              err == Err(Error::Sys(Errno::EINTR)) {
+        while err == Err(Errno::EIO) ||
+              err == Err(Errno::EAGAIN) ||
+              err == Err(Errno::EINTR) {
             // 
             thread::sleep(time::Duration::from_millis(10));
             resubmit_count += 1;
diff --git a/third_party/rust/nix/test/sys/test_mman.rs b/third_party/rust/nix/test/sys/test_mman.rs
new file mode 100644
index 0000000000000..a7ceedcbd1150
--- /dev/null
+++ b/third_party/rust/nix/test/sys/test_mman.rs
@@ -0,0 +1,92 @@
+use nix::sys::mman::{mmap, MapFlags, ProtFlags};
+
+#[test]
+fn test_mmap_anonymous() {
+    unsafe {
+        let ptr = mmap(std::ptr::null_mut(), 1,
+                       ProtFlags::PROT_READ | ProtFlags::PROT_WRITE,
+                       MapFlags::MAP_PRIVATE | MapFlags::MAP_ANONYMOUS, -1, 0)
+                      .unwrap() as *mut u8;
+        assert_eq !(*ptr, 0x00u8);
+        *ptr = 0xffu8;
+        assert_eq !(*ptr, 0xffu8);
+    }
+}
+
+#[test]
+#[cfg(any(target_os = "linux", target_os = "netbsd"))]
+fn test_mremap_grow() {
+    use nix::sys::mman::{mremap, MRemapFlags};
+    use nix::libc::{c_void, size_t};
+
+    const ONE_K : size_t = 1024;
+    let slice : &mut[u8] = unsafe {
+        let mem = mmap(std::ptr::null_mut(), ONE_K,
+                       ProtFlags::PROT_READ | ProtFlags::PROT_WRITE,
+                       MapFlags::MAP_ANONYMOUS | MapFlags::MAP_PRIVATE, -1, 0)
+                      .unwrap();
+        std::slice::from_raw_parts_mut(mem as * mut u8, ONE_K)
+    };
+    assert_eq !(slice[ONE_K - 1], 0x00);
+    slice[ONE_K - 1] = 0xFF;
+    assert_eq !(slice[ONE_K - 1], 0xFF);
+
+    let slice : &mut[u8] = unsafe {
+        #[cfg(target_os = "linux")]
+        let mem = mremap(slice.as_mut_ptr() as * mut c_void, ONE_K, 10 * ONE_K,
+                         MRemapFlags::MREMAP_MAYMOVE, None)
+                      .unwrap();
+        #[cfg(target_os = "netbsd")]
+        let mem = mremap(slice.as_mut_ptr() as * mut c_void, ONE_K, 10 * ONE_K,
+                         MRemapFlags::MAP_REMAPDUP, None)
+                      .unwrap();
+        std::slice::from_raw_parts_mut(mem as * mut u8, 10 * ONE_K)
+    };
+
+    // The first KB should still have the old data in it.
+    assert_eq !(slice[ONE_K - 1], 0xFF);
+
+    // The additional range should be zero-init'd and accessible.
+    assert_eq !(slice[10 * ONE_K - 1], 0x00);
+    slice[10 * ONE_K - 1] = 0xFF;
+    assert_eq !(slice[10 * ONE_K - 1], 0xFF);
+}
+
+#[test]
+#[cfg(any(target_os = "linux", target_os = "netbsd"))]
+// Segfaults for unknown reasons under QEMU for 32-bit targets
+#[cfg_attr(all(target_pointer_width = "32", qemu), ignore)]
+fn test_mremap_shrink() {
+    use nix::sys::mman::{mremap, MRemapFlags};
+    use nix::libc::{c_void, size_t};
+
+    const ONE_K : size_t = 1024;
+    let slice : &mut[u8] = unsafe {
+        let mem = mmap(std::ptr::null_mut(), 10 * ONE_K,
+                       ProtFlags::PROT_READ | ProtFlags::PROT_WRITE,
+                       MapFlags::MAP_ANONYMOUS | MapFlags::MAP_PRIVATE, -1, 0)
+                      .unwrap();
+        std::slice::from_raw_parts_mut(mem as * mut u8, ONE_K)
+    };
+    assert_eq !(slice[ONE_K - 1], 0x00);
+    slice[ONE_K - 1] = 0xFF;
+    assert_eq !(slice[ONE_K - 1], 0xFF);
+
+    let slice : &mut[u8] = unsafe {
+        #[cfg(target_os = "linux")]
+        let mem = mremap(slice.as_mut_ptr() as * mut c_void, 10 * ONE_K, ONE_K,
+                         MRemapFlags::empty(), None)
+                      .unwrap();
+        // Since we didn't supply MREMAP_MAYMOVE, the address should be the
+        // same.
+        #[cfg(target_os = "netbsd")]
+        let mem = mremap(slice.as_mut_ptr() as * mut c_void, 10 * ONE_K, ONE_K,
+                         MRemapFlags::MAP_FIXED, None)
+                      .unwrap();
+        assert_eq !(mem, slice.as_mut_ptr() as * mut c_void);
+        std::slice::from_raw_parts_mut(mem as * mut u8, ONE_K)
+    };
+
+    // The first KB should still be accessible and have the old data in it.
+    assert_eq !(slice[ONE_K - 1], 0xFF);
+}
diff --git a/third_party/rust/nix/test/sys/test_pthread.rs b/third_party/rust/nix/test/sys/test_pthread.rs
index 8928010087a13..fa9b510e8532e 100644
--- a/third_party/rust/nix/test/sys/test_pthread.rs
+++ b/third_party/rust/nix/test/sys/test_pthread.rs
@@ -1,15 +1,22 @@
 use nix::sys::pthread::*;
 
-#[cfg(target_env = "musl")]
+#[cfg(any(target_env = "musl", target_os = "redox"))]
 #[test]
 fn test_pthread_self() {
     let tid = pthread_self();
     assert!(tid != ::std::ptr::null_mut());
 }
 
-#[cfg(not(target_env = "musl"))]
+#[cfg(not(any(target_env = "musl", target_os = "redox")))]
 #[test]
 fn test_pthread_self() {
     let tid = pthread_self();
     assert!(tid != 0);
 }
+
+#[test]
+#[cfg(not(target_os = "redox"))]
+fn test_pthread_kill_none() {
+    pthread_kill(pthread_self(), None)
+        .expect("Should be able to send signal to my thread.");
+}
diff --git a/third_party/rust/nix/test/sys/test_ptrace.rs b/third_party/rust/nix/test/sys/test_ptrace.rs
index 24d9b522ee4e5..83fff9a5b4109 100644
--- a/third_party/rust/nix/test/sys/test_ptrace.rs
+++ b/third_party/rust/nix/test/sys/test_ptrace.rs
@@ -1,4 +1,3 @@
-use nix::Error;
 use nix::errno::Errno;
 use nix::unistd::getpid;
 use nix::sys::ptrace;
@@ -8,37 +7,43 @@ use nix::sys::ptrace::Options;
 #[cfg(any(target_os = "android", target_os = "linux"))]
 use std::mem;
 
+use crate::*;
+
 #[test]
 fn test_ptrace() {
     // Just make sure ptrace can be called at all, for now.
     // FIXME: qemu-user doesn't implement ptrace on all arches, so permit ENOSYS
+    require_capability!("test_ptrace", CAP_SYS_PTRACE);
     let err = ptrace::attach(getpid()).unwrap_err();
-    assert!(err == Error::Sys(Errno::EPERM) || err == Error::Sys(Errno::EINVAL) ||
-            err == Error::Sys(Errno::ENOSYS));
+    assert!(err == Errno::EPERM || err == Errno::EINVAL ||
+            err == Errno::ENOSYS);
 }
 
 // Just make sure ptrace_setoptions can be called at all, for now.
 #[test]
 #[cfg(any(target_os = "android", target_os = "linux"))]
 fn test_ptrace_setoptions() {
+    require_capability!("test_ptrace_setoptions", CAP_SYS_PTRACE);
     let err = ptrace::setoptions(getpid(), Options::PTRACE_O_TRACESYSGOOD).unwrap_err();
-    assert!(err != Error::UnsupportedOperation);
+    assert!(err != Errno::EOPNOTSUPP);
 }
 
 // Just make sure ptrace_getevent can be called at all, for now.
 #[test]
 #[cfg(any(target_os = "android", target_os = "linux"))]
 fn test_ptrace_getevent() {
+    require_capability!("test_ptrace_getevent", CAP_SYS_PTRACE);
     let err = ptrace::getevent(getpid()).unwrap_err();
-    assert!(err != Error::UnsupportedOperation);
+    assert!(err != Errno::EOPNOTSUPP);
 }
 
 // Just make sure ptrace_getsiginfo can be called at all, for now.
 #[test]
 #[cfg(any(target_os = "android", target_os = "linux"))]
 fn test_ptrace_getsiginfo() {
-    if let Err(Error::UnsupportedOperation) = ptrace::getsiginfo(getpid()) {
-        panic!("ptrace_getsiginfo returns Error::UnsupportedOperation!");
+    require_capability!("test_ptrace_getsiginfo", CAP_SYS_PTRACE);
+    if let Err(Errno::EOPNOTSUPP) = ptrace::getsiginfo(getpid()) {
+        panic!("ptrace_getsiginfo returns Errno::EOPNOTSUPP!");
     }
 }
 
@@ -46,9 +51,10 @@ fn test_ptrace_getsiginfo() {
 #[test]
 #[cfg(any(target_os = "android", target_os = "linux"))]
 fn test_ptrace_setsiginfo() {
-    let siginfo = unsafe { mem::uninitialized() };
-    if let Err(Error::UnsupportedOperation) = ptrace::setsiginfo(getpid(), &siginfo) {
-        panic!("ptrace_setsiginfo returns Error::UnsupportedOperation!");
+    require_capability!("test_ptrace_setsiginfo", CAP_SYS_PTRACE);
+    let siginfo = unsafe { mem::zeroed() };
+    if let Err(Errno::EOPNOTSUPP) = ptrace::setsiginfo(getpid(), &siginfo) {
+        panic!("ptrace_setsiginfo returns Errno::EOPNOTSUPP!");
     }
 }
 
@@ -61,7 +67,9 @@ fn test_ptrace_cont() {
     use nix::unistd::fork;
     use nix::unistd::ForkResult::*;
 
-    let _m = ::FORK_MTX.lock().expect("Mutex got poisoned by another test");
+    require_capability!("test_ptrace_cont", CAP_SYS_PTRACE);
+
+    let _m = crate::FORK_MTX.lock();
 
     // FIXME: qemu-user doesn't implement ptrace on all architectures
     // and retunrs ENOSYS in this case.
@@ -70,11 +78,11 @@ fn test_ptrace_cont() {
     // On valid platforms the ptrace call should return Errno::EPERM, this
     // is already tested by `test_ptrace`.
     let err = ptrace::attach(getpid()).unwrap_err();
-    if err == Error::Sys(Errno::ENOSYS) {
+    if err == Errno::ENOSYS {
         return;
     }
 
-    match fork().expect("Error: Fork Failed") {
+    match unsafe{fork()}.expect("Error: Fork Failed") {
         Child => {
             ptrace::traceme().unwrap();
             // As recommended by ptrace(2), raise SIGTRAP to pause the child
@@ -91,7 +99,7 @@ fn test_ptrace_cont() {
             ptrace::cont(child, Some(Signal::SIGKILL)).unwrap();
             match waitpid(child, None) {
                 Ok(WaitStatus::Signaled(pid, Signal::SIGKILL, _)) if pid == child => {
-                    // FIXME It's been observed on some systems (apple) the 
+                    // FIXME It's been observed on some systems (apple) the
                     // tracee may not be killed but remain as a zombie process
                     // affecting other wait based tests. Add an extra kill just
                     // to make sure there are no zombies.
@@ -105,3 +113,107 @@ fn test_ptrace_cont() {
         },
     }
 }
+
+#[cfg(target_os = "linux")]
+#[test]
+fn test_ptrace_interrupt() {
+    use nix::sys::ptrace;
+    use nix::sys::signal::Signal;
+    use nix::sys::wait::{waitpid, WaitPidFlag, WaitStatus};
+    use nix::unistd::fork;
+    use nix::unistd::ForkResult::*;
+    use std::thread::sleep;
+    use std::time::Duration;
+
+    require_capability!("test_ptrace_interrupt", CAP_SYS_PTRACE);
+
+    let _m = crate::FORK_MTX.lock();
+
+    match unsafe{fork()}.expect("Error: Fork Failed") {
+        Child => {
+            loop {
+                sleep(Duration::from_millis(1000));
+            }
+
+        },
+        Parent { child } => {
+            ptrace::seize(child, ptrace::Options::PTRACE_O_TRACESYSGOOD).unwrap();
+            ptrace::interrupt(child).unwrap();
+            assert_eq!(waitpid(child, None), Ok(WaitStatus::PtraceEvent(child, Signal::SIGTRAP, 128)));
+            ptrace::syscall(child, None).unwrap();
+            assert_eq!(waitpid(child, None), Ok(WaitStatus::PtraceSyscall(child)));
+            ptrace::detach(child, Some(Signal::SIGKILL)).unwrap();
+            match waitpid(child, None) {
+                Ok(WaitStatus::Signaled(pid, Signal::SIGKILL, _)) if pid == child => {
+                    let _ = waitpid(child, Some(WaitPidFlag::WNOHANG));
+                    while ptrace::cont(child, Some(Signal::SIGKILL)).is_ok() {
+                        let _ = waitpid(child, Some(WaitPidFlag::WNOHANG));
+                    }
+                }
+                _ => panic!("The process should have been killed"),
+            }
+        },
+    }
+}
+
+// ptrace::{setoptions, getregs} are only available in these platforms
+#[cfg(all(target_os = "linux",
+          any(target_arch = "x86_64",
+              target_arch = "x86"),
+          target_env = "gnu"))]
+#[test]
+fn test_ptrace_syscall() {
+    use nix::sys::signal::kill;
+    use nix::sys::ptrace;
+    use nix::sys::signal::Signal;
+    use nix::sys::wait::{waitpid, WaitStatus};
+    use nix::unistd::fork;
+    use nix::unistd::getpid;
+    use nix::unistd::ForkResult::*;
+
+    require_capability!("test_ptrace_syscall", CAP_SYS_PTRACE);
+
+    let _m = crate::FORK_MTX.lock();
+
+    match unsafe{fork()}.expect("Error: Fork Failed") {
+        Child => {
+            ptrace::traceme().unwrap();
+            // first sigstop until parent is ready to continue
+            let pid = getpid();
+            kill(pid, Signal::SIGSTOP).unwrap();
+            kill(pid, Signal::SIGTERM).unwrap();
+            unsafe { ::libc::_exit(0); }
+        },
+
+        Parent { child } => {
+            assert_eq!(waitpid(child, None), Ok(WaitStatus::Stopped(child, Signal::SIGSTOP)));
+
+            // set this option to recognize syscall-stops
+            ptrace::setoptions(child, ptrace::Options::PTRACE_O_TRACESYSGOOD).unwrap();
+
+            #[cfg(target_arch = "x86_64")]
+            let get_syscall_id = || ptrace::getregs(child).unwrap().orig_rax as libc::c_long;
+
+            #[cfg(target_arch = "x86")]
+            let get_syscall_id = || ptrace::getregs(child).unwrap().orig_eax as libc::c_long;
+
+            // kill entry
+            ptrace::syscall(child, None).unwrap();
+            assert_eq!(waitpid(child, None), Ok(WaitStatus::PtraceSyscall(child)));
+            assert_eq!(get_syscall_id(), ::libc::SYS_kill);
+
+            // kill exit
+            ptrace::syscall(child, None).unwrap();
+            assert_eq!(waitpid(child, None), Ok(WaitStatus::PtraceSyscall(child)));
+            assert_eq!(get_syscall_id(), ::libc::SYS_kill);
+
+            // receive signal
+            ptrace::syscall(child, None).unwrap();
+            assert_eq!(waitpid(child, None), Ok(WaitStatus::Stopped(child, Signal::SIGTERM)));
+
+            // inject signal
+            ptrace::syscall(child, Signal::SIGTERM).unwrap();
+            assert_eq!(waitpid(child, None), Ok(WaitStatus::Signaled(child, Signal::SIGTERM, false)));
+        },
+    }
+}
diff --git a/third_party/rust/nix/test/sys/test_select.rs b/third_party/rust/nix/test/sys/test_select.rs
index cf68700c5e16f..2f7396b1895e5 100644
--- a/third_party/rust/nix/test/sys/test_select.rs
+++ b/third_party/rust/nix/test/sys/test_select.rs
@@ -5,9 +5,7 @@ use nix::sys::time::{TimeSpec, TimeValLike};
 
 #[test]
 pub fn test_pselect() {
-    let _mtx = ::SIGNAL_MTX
-        .lock()
-        .expect("Mutex got poisoned by another test");
+    let _mtx = crate::SIGNAL_MTX.lock();
 
     let (r1, w1) = pipe().unwrap();
     write(w1, b"hi!").unwrap();
@@ -52,3 +50,31 @@ pub fn test_pselect_nfds2() {
     assert!(fd_set.contains(r1));
     assert!(!fd_set.contains(r2));
 }
+
+macro_rules! generate_fdset_bad_fd_tests {
+    ($fd:expr, $($method:ident),* $(,)?) => {
+        $(
+            #[test]
+            #[should_panic]
+            fn $method() {
+                FdSet::new().$method($fd);
+            }
+        )*
+    }
+}
+
+mod test_fdset_negative_fd {
+    use super::*;
+    generate_fdset_bad_fd_tests!(-1, insert, remove, contains);
+}
+
+mod test_fdset_too_large_fd {
+    use super::*;
+    use std::convert::TryInto;
+    generate_fdset_bad_fd_tests!(
+        FD_SETSIZE.try_into().unwrap(),
+        insert,
+        remove,
+        contains,
+    );
+}
diff --git a/third_party/rust/nix/test/sys/test_signal.rs b/third_party/rust/nix/test/sys/test_signal.rs
index 8780763f773ef..fdd2568df463b 100644
--- a/third_party/rust/nix/test/sys/test_signal.rs
+++ b/third_party/rust/nix/test/sys/test_signal.rs
@@ -1,7 +1,8 @@
-use libc;
-use nix::Error;
+#[cfg(not(target_os = "redox"))]
+use nix::errno::Errno;
 use nix::sys::signal::*;
 use nix::unistd::*;
+use std::convert::TryFrom;
 use std::sync::atomic::{AtomicBool, Ordering};
 
 #[test]
@@ -10,6 +11,7 @@ fn test_kill_none() {
 }
 
 #[test]
+#[cfg(not(target_os = "fuchsia"))]
 fn test_killpg_none() {
     killpg(getpgrp(), None)
         .expect("Should be able to send signal to my process group.");
@@ -17,6 +19,8 @@ fn test_killpg_none() {
 
 #[test]
 fn test_old_sigaction_flags() {
+    let _m = crate::SIGNAL_MTX.lock();
+
     extern "C" fn handler(_: ::libc::c_int) {}
     let act = SigAction::new(
         SigHandler::Handler(handler),
@@ -37,7 +41,7 @@ fn test_sigprocmask_noop() {
 
 #[test]
 fn test_sigprocmask() {
-    let _m = ::SIGNAL_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::SIGNAL_MTX.lock();
 
     // This needs to be a signal that rust doesn't use in the test harness.
     const SIGNAL: Signal = Signal::SIGCHLD;
@@ -48,9 +52,9 @@ fn test_sigprocmask() {
 
     // Make sure the old set doesn't contain the signal, otherwise the following
     // test don't make sense.
-    assert_eq!(old_signal_set.contains(SIGNAL), false,
-               "the {:?} signal is already blocked, please change to a \
-                different one", SIGNAL);
+    assert!(!old_signal_set.contains(SIGNAL),
+            "the {:?} signal is already blocked, please change to a \
+             different one", SIGNAL);
 
     // Now block the signal.
     let mut signal_set = SigSet::empty();
@@ -62,8 +66,8 @@ fn test_sigprocmask() {
     old_signal_set.clear();
     sigprocmask(SigmaskHow::SIG_BLOCK, None, Some(&mut old_signal_set))
         .expect("expect to be able to retrieve old signals");
-    assert_eq!(old_signal_set.contains(SIGNAL), true,
-               "expected the {:?} to be blocked", SIGNAL);
+    assert!(old_signal_set.contains(SIGNAL),
+            "expected the {:?} to be blocked", SIGNAL);
 
     // Reset the signal.
     sigprocmask(SigmaskHow::SIG_UNBLOCK, Some(&signal_set), None)
@@ -75,16 +79,25 @@ lazy_static! {
 }
 
 extern fn test_sigaction_handler(signal: libc::c_int) {
-    let signal = Signal::from_c_int(signal).unwrap();
+    let signal = Signal::try_from(signal).unwrap();
     SIGNALED.store(signal == Signal::SIGINT, Ordering::Relaxed);
 }
 
-extern fn test_sigaction_action(_: libc::c_int, _: *mut libc::siginfo_t, _: *mut libc::c_void) {
+#[cfg(not(target_os = "redox"))]
+extern fn test_sigaction_action(_: libc::c_int, _: *mut libc::siginfo_t, _: *mut libc::c_void) {}
+
+#[test]
+#[cfg(not(target_os = "redox"))]
+fn test_signal_sigaction() {
+    let _m = crate::SIGNAL_MTX.lock();
+
+    let action_handler = SigHandler::SigAction(test_sigaction_action);
+    assert_eq!(unsafe { signal(Signal::SIGINT, action_handler) }.unwrap_err(), Errno::ENOTSUP);
 }
 
 #[test]
 fn test_signal() {
-    let _m = ::SIGNAL_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::SIGNAL_MTX.lock();
 
     unsafe { signal(Signal::SIGINT, SigHandler::SigIgn) }.unwrap();
     raise(Signal::SIGINT).unwrap();
@@ -94,10 +107,14 @@ fn test_signal() {
     assert_eq!(unsafe { signal(Signal::SIGINT, handler) }.unwrap(), SigHandler::SigDfl);
     raise(Signal::SIGINT).unwrap();
     assert!(SIGNALED.load(Ordering::Relaxed));
+
+    #[cfg(not(any(target_os = "illumos", target_os = "solaris")))]
     assert_eq!(unsafe { signal(Signal::SIGINT, SigHandler::SigDfl) }.unwrap(), handler);
 
-    let action_handler = SigHandler::SigAction(test_sigaction_action);
-    assert_eq!(unsafe { signal(Signal::SIGINT, action_handler) }.unwrap_err(), Error::UnsupportedOperation);
+    // System V based OSes (e.g. illumos and Solaris) always resets the
+    // disposition to SIG_DFL prior to calling the signal handler
+    #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+    assert_eq!(unsafe { signal(Signal::SIGINT, SigHandler::SigDfl) }.unwrap(), SigHandler::SigDfl);
 
     // Restore default signal handler
     unsafe { signal(Signal::SIGINT, SigHandler::SigDfl) }.unwrap();
diff --git a/third_party/rust/nix/test/sys/test_signalfd.rs b/third_party/rust/nix/test/sys/test_signalfd.rs
index a3b6098841f1c..b6f748b46a42b 100644
--- a/third_party/rust/nix/test/sys/test_signalfd.rs
+++ b/third_party/rust/nix/test/sys/test_signalfd.rs
@@ -1,10 +1,12 @@
+use std::convert::TryFrom;
+
 #[test]
 fn test_signalfd() {
     use nix::sys::signalfd::SignalFd;
     use nix::sys::signal::{self, raise, Signal, SigSet};
 
     // Grab the mutex for altering signals so we don't interfere with other tests.
-    let _m = ::SIGNAL_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::SIGNAL_MTX.lock();
 
     // Block the SIGUSR1 signal from automatic processing for this thread
     let mut mask = SigSet::empty();
@@ -20,6 +22,6 @@ fn test_signalfd() {
 
     // And now catch that same signal.
     let res = fd.read_signal().unwrap().unwrap();
-    let signo = Signal::from_c_int(res.ssi_signo as i32).unwrap();
+    let signo = Signal::try_from(res.ssi_signo as i32).unwrap();
     assert_eq!(signo, signal::SIGUSR1);
 }
diff --git a/third_party/rust/nix/test/sys/test_socket.rs b/third_party/rust/nix/test/sys/test_socket.rs
index 7e64d2b77f071..0f6fac6664d56 100644
--- a/third_party/rust/nix/test/sys/test_socket.rs
+++ b/third_party/rust/nix/test/sys/test_socket.rs
@@ -1,14 +1,15 @@
-use nix::ifaddrs::InterfaceAddress;
-use nix::sys::socket::{AddressFamily, InetAddr, UnixAddr, getsockname};
+use nix::sys::socket::{AddressFamily, InetAddr, SockAddr, UnixAddr, getsockname, sockaddr, sockaddr_in6, sockaddr_storage_to_addr};
 use std::collections::hash_map::DefaultHasher;
 use std::hash::{Hash, Hasher};
+use std::mem::{self, MaybeUninit};
 use std::net::{self, Ipv6Addr, SocketAddr, SocketAddrV6};
 use std::os::unix::io::RawFd;
 use std::path::Path;
 use std::slice;
 use std::str::FromStr;
-use libc::c_char;
-use tempfile;
+use libc::{c_char, sockaddr_storage};
+#[cfg(any(target_os = "linux", target_os= "android"))]
+use crate::*;
 
 #[test]
 pub fn test_inetv4_addr_to_sock_addr() {
@@ -27,12 +28,35 @@ pub fn test_inetv4_addr_to_sock_addr() {
         _ => panic!("nope"),
     }
 
-    assert_eq!(addr.to_str(), "127.0.0.1:3000");
+    assert_eq!(addr.to_string(), "127.0.0.1:3000");
 
     let inet = addr.to_std();
     assert_eq!(actual, inet);
 }
 
+#[test]
+pub fn test_inetv4_addr_roundtrip_sockaddr_storage_to_addr() {
+    let actual: net::SocketAddr = FromStr::from_str("127.0.0.1:3000").unwrap();
+    let addr = InetAddr::from_std(&actual);
+    let sockaddr = SockAddr::new_inet(addr);
+
+    let (storage, ffi_size) = {
+        let mut storage = MaybeUninit::<sockaddr_storage>::zeroed();
+        let storage_ptr = storage.as_mut_ptr().cast::<sockaddr>();
+        let (ffi_ptr, ffi_size) = sockaddr.as_ffi_pair();
+        assert_eq!(mem::size_of::<sockaddr>(), ffi_size as usize);
+        unsafe {
+            storage_ptr.copy_from_nonoverlapping(ffi_ptr as *const sockaddr, 1);
+            (storage.assume_init(), ffi_size)
+        }
+    };
+
+    let from_storage = sockaddr_storage_to_addr(&storage, ffi_size as usize).unwrap();
+    assert_eq!(from_storage, sockaddr);
+    let from_storage = sockaddr_storage_to_addr(&storage, mem::size_of::<sockaddr_storage>()).unwrap();
+    assert_eq!(from_storage, sockaddr);
+}
+
 #[test]
 pub fn test_inetv6_addr_to_sock_addr() {
     let port: u16 = 3000;
@@ -54,6 +78,33 @@ pub fn test_inetv6_addr_to_sock_addr() {
 
     assert_eq!(actual, addr.to_std());
 }
+#[test]
+pub fn test_inetv6_addr_roundtrip_sockaddr_storage_to_addr() {
+    let port: u16 = 3000;
+    let flowinfo: u32 = 1;
+    let scope_id: u32 = 2;
+    let ip: Ipv6Addr = "fe80::1".parse().unwrap();
+
+    let actual = SocketAddr::V6(SocketAddrV6::new(ip, port, flowinfo, scope_id));
+    let addr = InetAddr::from_std(&actual);
+    let sockaddr = SockAddr::new_inet(addr);
+
+    let (storage, ffi_size) = {
+        let mut storage = MaybeUninit::<sockaddr_storage>::zeroed();
+        let storage_ptr = storage.as_mut_ptr().cast::<sockaddr_in6>();
+        let (ffi_ptr, ffi_size) = sockaddr.as_ffi_pair();
+        assert_eq!(mem::size_of::<sockaddr_in6>(), ffi_size as usize);
+        unsafe {
+            storage_ptr.copy_from_nonoverlapping((ffi_ptr as *const sockaddr).cast::<sockaddr_in6>(), 1);
+            (storage.assume_init(), ffi_size)
+        }
+    };
+
+    let from_storage = sockaddr_storage_to_addr(&storage, ffi_size as usize).unwrap();
+    assert_eq!(from_storage, sockaddr);
+    let from_storage = sockaddr_storage_to_addr(&storage, mem::size_of::<sockaddr_storage>()).unwrap();
+    assert_eq!(from_storage, sockaddr);
+}
 
 #[test]
 pub fn test_path_to_sock_addr() {
@@ -62,9 +113,9 @@ pub fn test_path_to_sock_addr() {
     let addr = UnixAddr::new(actual).unwrap();
 
     let expect: &[c_char] = unsafe {
-        slice::from_raw_parts(path.as_bytes().as_ptr() as *const c_char, path.len())
+        slice::from_raw_parts(path.as_ptr() as *const c_char, path.len())
     };
-    assert_eq!(&addr.0.sun_path[..8], expect);
+    assert_eq!(unsafe { &(*addr.as_ptr()).sun_path[..8] }, expect);
 
     assert_eq!(addr.path(), Some(actual));
 }
@@ -80,9 +131,9 @@ pub fn test_addr_equality_path() {
     let path = "/foo/bar";
     let actual = Path::new(path);
     let addr1 = UnixAddr::new(actual).unwrap();
-    let mut addr2 = addr1.clone();
+    let mut addr2 = addr1;
 
-    addr2.0.sun_path[10] = 127;
+    unsafe { (*addr2.as_mut_ptr()).sun_path[10] = 127 };
 
     assert_eq!(addr1, addr2);
     assert_eq!(calculate_hash(&addr1), calculate_hash(&addr2));
@@ -101,12 +152,12 @@ pub fn test_abstract_sun_path_too_long() {
 pub fn test_addr_equality_abstract() {
     let name = String::from("nix\0abstract\0test");
     let addr1 = UnixAddr::new_abstract(name.as_bytes()).unwrap();
-    let mut addr2 = addr1.clone();
+    let mut addr2 = addr1;
 
     assert_eq!(addr1, addr2);
     assert_eq!(calculate_hash(&addr1), calculate_hash(&addr2));
 
-    addr2.0.sun_path[18] = 127;
+    unsafe { (*addr2.as_mut_ptr()).sun_path[17] = 127 };
     assert_ne!(addr1, addr2);
     assert_ne!(calculate_hash(&addr1), calculate_hash(&addr2));
 }
@@ -117,22 +168,19 @@ pub fn test_addr_equality_abstract() {
 pub fn test_abstract_uds_addr() {
     let empty = String::new();
     let addr = UnixAddr::new_abstract(empty.as_bytes()).unwrap();
-    let sun_path = [0u8; 107];
+    let sun_path: [u8; 0] = [];
     assert_eq!(addr.as_abstract(), Some(&sun_path[..]));
 
     let name = String::from("nix\0abstract\0test");
     let addr = UnixAddr::new_abstract(name.as_bytes()).unwrap();
     let sun_path = [
-        110u8, 105, 120, 0, 97, 98, 115, 116, 114, 97, 99, 116, 0, 116, 101, 115, 116, 0, 0, 0, 0,
-        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+        110u8, 105, 120, 0, 97, 98, 115, 116, 114, 97, 99, 116, 0, 116, 101, 115, 116
     ];
     assert_eq!(addr.as_abstract(), Some(&sun_path[..]));
     assert_eq!(addr.path(), None);
 
     // Internally, name is null-prefixed (abstract namespace)
-    assert_eq!(addr.0.sun_path[0], 0);
+    assert_eq!(unsafe { (*addr.as_ptr()).sun_path[0] }, 0);
 }
 
 #[test]
@@ -146,8 +194,7 @@ pub fn test_getsockname() {
                .expect("socket failed");
     let sockaddr = SockAddr::new_unix(&sockname).unwrap();
     bind(sock, &sockaddr).expect("bind failed");
-    assert_eq!(sockaddr.to_str(),
-               getsockname(sock).expect("getsockname failed").to_str());
+    assert_eq!(sockaddr, getsockname(sock).expect("getsockname failed"));
 }
 
 #[test]
@@ -164,10 +211,363 @@ pub fn test_socketpair() {
     assert_eq!(&buf[..], b"hello");
 }
 
+mod recvfrom {
+    use nix::Result;
+    use nix::sys::socket::*;
+    use std::thread;
+    use super::*;
+
+    const MSG: &[u8] = b"Hello, World!";
+
+    fn sendrecv<Fs, Fr>(rsock: RawFd, ssock: RawFd, f_send: Fs, mut f_recv: Fr) -> Option<SockAddr>
+        where
+            Fs: Fn(RawFd, &[u8], MsgFlags) -> Result<usize> + Send + 'static,
+            Fr: FnMut(usize, Option<SockAddr>),
+    {
+        let mut buf: [u8; 13] = [0u8; 13];
+        let mut l = 0;
+        let mut from = None;
+
+        let send_thread = thread::spawn(move || {
+            let mut l = 0;
+            while l < std::mem::size_of_val(MSG) {
+                l += f_send(ssock, &MSG[l..], MsgFlags::empty()).unwrap();
+            }
+        });
+
+        while l < std::mem::size_of_val(MSG) {
+            let (len, from_) = recvfrom(rsock, &mut buf[l..]).unwrap();
+            f_recv(len, from_);
+            from = from_;
+            l += len;
+        }
+        assert_eq!(&buf, MSG);
+        send_thread.join().unwrap();
+        from
+    }
+
+    #[test]
+    pub fn stream() {
+        let (fd2, fd1) = socketpair(AddressFamily::Unix, SockType::Stream,
+                                    None, SockFlag::empty()).unwrap();
+        // Ignore from for stream sockets
+        let _ = sendrecv(fd1, fd2, |s, m, flags| {
+            send(s, m, flags)
+        }, |_, _| {});
+    }
+
+    #[test]
+    pub fn udp() {
+        let std_sa = SocketAddr::from_str("127.0.0.1:6789").unwrap();
+        let inet_addr = InetAddr::from_std(&std_sa);
+        let sock_addr = SockAddr::new_inet(inet_addr);
+        let rsock = socket(AddressFamily::Inet,
+            SockType::Datagram,
+            SockFlag::empty(),
+            None
+        ).unwrap();
+        bind(rsock, &sock_addr).unwrap();
+        let ssock = socket(
+            AddressFamily::Inet,
+            SockType::Datagram,
+            SockFlag::empty(),
+            None,
+        ).expect("send socket failed");
+        let from = sendrecv(rsock, ssock, move |s, m, flags| {
+            sendto(s, m, &sock_addr, flags)
+        },|_, _| {});
+        // UDP sockets should set the from address
+        assert_eq!(AddressFamily::Inet, from.unwrap().family());
+    }
+
+    #[cfg(target_os = "linux")]
+    mod udp_offload {
+        use super::*;
+        use nix::sys::uio::IoVec;
+        use nix::sys::socket::sockopt::{UdpGroSegment, UdpGsoSegment};
+
+        #[test]
+        // Disable the test under emulation because it fails in Cirrus-CI.  Lack
+        // of QEMU support is suspected.
+        #[cfg_attr(qemu, ignore)]
+        pub fn gso() {
+            require_kernel_version!(udp_offload::gso, ">= 4.18");
+
+            // In this test, we send the data and provide a GSO segment size.
+            // Since we are sending the buffer of size 13, six UDP packets
+            // with size 2 and two UDP packet with size 1 will be sent.
+            let segment_size: u16 = 2;
+
+            let std_sa = SocketAddr::from_str("127.0.0.1:6791").unwrap();
+            let inet_addr = InetAddr::from_std(&std_sa);
+            let sock_addr = SockAddr::new_inet(inet_addr);
+            let rsock = socket(AddressFamily::Inet,
+                               SockType::Datagram,
+                               SockFlag::empty(),
+                               None
+            ).unwrap();
+
+            setsockopt(rsock, UdpGsoSegment, &(segment_size as _))
+                .expect("setsockopt UDP_SEGMENT failed");
+
+            bind(rsock, &sock_addr).unwrap();
+            let ssock = socket(
+                AddressFamily::Inet,
+                SockType::Datagram,
+                SockFlag::empty(),
+                None,
+            ).expect("send socket failed");
+
+            let mut num_packets_received: i32 = 0;
+
+            sendrecv(rsock, ssock, move |s, m, flags| {
+                let iov = [IoVec::from_slice(m)];
+                let cmsg = ControlMessage::UdpGsoSegments(&segment_size);
+                sendmsg(s, &iov, &[cmsg], flags, Some(&sock_addr))
+            }, {
+                let num_packets_received_ref = &mut num_packets_received;
+
+                move |len, _| {
+                    // check that we receive UDP packets with payload size
+                    // less or equal to segment size
+                    assert!(len <= segment_size as usize);
+                    *num_packets_received_ref += 1;
+                }
+            });
+
+            // Buffer size is 13, we will receive six packets of size 2,
+            // and one packet of size 1.
+            assert_eq!(7, num_packets_received);
+        }
+
+        #[test]
+        // Disable the test on emulated platforms because it fails in Cirrus-CI.
+        // Lack of QEMU support is suspected.
+        #[cfg_attr(qemu, ignore)]
+        pub fn gro() {
+            require_kernel_version!(udp_offload::gro, ">= 5.3");
+
+            // It's hard to guarantee receiving GRO packets. Just checking
+            // that `setsockopt` doesn't fail with error
+
+            let rsock = socket(AddressFamily::Inet,
+                               SockType::Datagram,
+                               SockFlag::empty(),
+                               None
+            ).unwrap();
+
+            setsockopt(rsock, UdpGroSegment, &true)
+                .expect("setsockopt UDP_GRO failed");
+        }
+    }
+
+    #[cfg(any(
+        target_os = "linux",
+        target_os = "android",
+        target_os = "freebsd",
+        target_os = "netbsd",
+    ))]
+    #[test]
+    pub fn udp_sendmmsg() {
+        use nix::sys::uio::IoVec;
+
+        let std_sa = SocketAddr::from_str("127.0.0.1:6793").unwrap();
+        let std_sa2 = SocketAddr::from_str("127.0.0.1:6794").unwrap();
+        let inet_addr = InetAddr::from_std(&std_sa);
+        let inet_addr2 = InetAddr::from_std(&std_sa2);
+        let sock_addr = SockAddr::new_inet(inet_addr);
+        let sock_addr2 = SockAddr::new_inet(inet_addr2);
+
+        let rsock = socket(AddressFamily::Inet,
+            SockType::Datagram,
+            SockFlag::empty(),
+            None
+        ).unwrap();
+        bind(rsock, &sock_addr).unwrap();
+        let ssock = socket(
+            AddressFamily::Inet,
+            SockType::Datagram,
+            SockFlag::empty(),
+            None,
+        ).expect("send socket failed");
+
+        let from = sendrecv(rsock, ssock, move |s, m, flags| {
+            let iov = [IoVec::from_slice(m)];
+            let mut msgs = vec![
+                SendMmsgData {
+                    iov: &iov,
+                    cmsgs: &[],
+                    addr: Some(sock_addr),
+                    _lt: Default::default(),
+                }
+            ];
+
+            let batch_size = 15;
+
+            for _ in 0..batch_size {
+                msgs.push(
+                    SendMmsgData {
+                        iov: &iov,
+                        cmsgs: &[],
+                        addr: Some(sock_addr2),
+                        _lt: Default::default(),
+                    }
+                );
+            }
+            sendmmsg(s, msgs.iter(), flags)
+                .map(move |sent_bytes| {
+                    assert!(!sent_bytes.is_empty());
+                    for sent in &sent_bytes {
+                        assert_eq!(*sent, m.len());
+                    }
+                    sent_bytes.len()
+                })
+        }, |_, _ | {});
+        // UDP sockets should set the from address
+        assert_eq!(AddressFamily::Inet, from.unwrap().family());
+    }
+
+    #[cfg(any(
+        target_os = "linux",
+        target_os = "android",
+        target_os = "freebsd",
+        target_os = "netbsd",
+    ))]
+    #[test]
+    pub fn udp_recvmmsg() {
+        use nix::sys::uio::IoVec;
+        use nix::sys::socket::{MsgFlags, recvmmsg};
+
+        const NUM_MESSAGES_SENT: usize = 2;
+        const DATA: [u8; 2] = [1,2];
+
+        let std_sa = SocketAddr::from_str("127.0.0.1:6798").unwrap();
+        let inet_addr = InetAddr::from_std(&std_sa);
+        let sock_addr = SockAddr::new_inet(inet_addr);
+
+        let rsock = socket(AddressFamily::Inet,
+            SockType::Datagram,
+            SockFlag::empty(),
+            None
+        ).unwrap();
+        bind(rsock, &sock_addr).unwrap();
+        let ssock = socket(
+            AddressFamily::Inet,
+            SockType::Datagram,
+            SockFlag::empty(),
+            None,
+        ).expect("send socket failed");
+
+        let send_thread = thread::spawn(move || {
+            for _ in 0..NUM_MESSAGES_SENT {
+                sendto(ssock, &DATA[..], &sock_addr, MsgFlags::empty()).unwrap();
+            }
+        });
+
+        let mut msgs = std::collections::LinkedList::new();
+
+        // Buffers to receive exactly `NUM_MESSAGES_SENT` messages
+        let mut receive_buffers = [[0u8; 32]; NUM_MESSAGES_SENT];
+        let iovs: Vec<_> = receive_buffers.iter_mut().map(|buf| {
+            [IoVec::from_mut_slice(&mut buf[..])]
+        }).collect();
+
+        for iov in &iovs {
+            msgs.push_back(RecvMmsgData {
+                iov,
+                cmsg_buffer: None,
+            })
+        };
+
+        let res = recvmmsg(rsock, &mut msgs, MsgFlags::empty(), None).expect("recvmmsg");
+        assert_eq!(res.len(), DATA.len());
+
+        for RecvMsg { address, bytes, .. } in res.into_iter() {
+            assert_eq!(AddressFamily::Inet, address.unwrap().family());
+            assert_eq!(DATA.len(), bytes);
+        }
+
+        for buf in &receive_buffers {
+            assert_eq!(&buf[..DATA.len()], DATA);
+        }
+
+        send_thread.join().unwrap();
+    }
+
+    #[cfg(any(
+        target_os = "linux",
+        target_os = "android",
+        target_os = "freebsd",
+        target_os = "netbsd",
+    ))]
+    #[test]
+    pub fn udp_recvmmsg_dontwait_short_read() {
+        use nix::sys::uio::IoVec;
+        use nix::sys::socket::{MsgFlags, recvmmsg};
+
+        const NUM_MESSAGES_SENT: usize = 2;
+        const DATA: [u8; 4] = [1,2,3,4];
+
+        let std_sa = SocketAddr::from_str("127.0.0.1:6799").unwrap();
+        let inet_addr = InetAddr::from_std(&std_sa);
+        let sock_addr = SockAddr::new_inet(inet_addr);
+
+        let rsock = socket(AddressFamily::Inet,
+            SockType::Datagram,
+            SockFlag::empty(),
+            None
+        ).unwrap();
+        bind(rsock, &sock_addr).unwrap();
+        let ssock = socket(
+            AddressFamily::Inet,
+            SockType::Datagram,
+            SockFlag::empty(),
+            None,
+        ).expect("send socket failed");
+
+        let send_thread = thread::spawn(move || {
+            for _ in 0..NUM_MESSAGES_SENT {
+                sendto(ssock, &DATA[..], &sock_addr, MsgFlags::empty()).unwrap();
+            }
+        });
+        // Ensure we've sent all the messages before continuing so `recvmmsg`
+        // will return right away
+        send_thread.join().unwrap();
+
+        let mut msgs = std::collections::LinkedList::new();
+
+        // Buffers to receive >`NUM_MESSAGES_SENT` messages to ensure `recvmmsg`
+        // will return when there are fewer than requested messages in the
+        // kernel buffers when using `MSG_DONTWAIT`.
+        let mut receive_buffers = [[0u8; 32]; NUM_MESSAGES_SENT + 2];
+        let iovs: Vec<_> = receive_buffers.iter_mut().map(|buf| {
+            [IoVec::from_mut_slice(&mut buf[..])]
+        }).collect();
+
+        for iov in &iovs {
+            msgs.push_back(RecvMmsgData {
+                iov,
+                cmsg_buffer: None,
+            })
+        };
+
+        let res = recvmmsg(rsock, &mut msgs, MsgFlags::MSG_DONTWAIT, None).expect("recvmmsg");
+        assert_eq!(res.len(), NUM_MESSAGES_SENT);
+
+        for RecvMsg { address, bytes, .. } in res.into_iter() {
+            assert_eq!(AddressFamily::Inet, address.unwrap().family());
+            assert_eq!(DATA.len(), bytes);
+        }
+
+        for buf in &receive_buffers[..NUM_MESSAGES_SENT] {
+            assert_eq!(&buf[..DATA.len()], DATA);
+        }
+    }
+}
+
 // Test error handling of our recvmsg wrapper
 #[test]
 pub fn test_recvmsg_ebadf() {
-    use nix::Error;
     use nix::errno::Errno;
     use nix::sys::socket::{MsgFlags, recvmsg};
     use nix::sys::uio::IoVec;
@@ -176,12 +576,12 @@ pub fn test_recvmsg_ebadf() {
     let iov = [IoVec::from_mut_slice(&mut buf[..])];
     let fd = -1;    // Bad file descriptor
     let r = recvmsg(fd, &iov, None, MsgFlags::empty());
-    assert_eq!(r.err().unwrap(), Error::Sys(Errno::EBADF));
+    assert_eq!(r.err().unwrap(), Errno::EBADF);
 }
 
 // Disable the test on emulated platforms due to a bug in QEMU versions <
 // 2.12.0.  https://bugs.launchpad.net/qemu/+bug/1701808
-#[cfg_attr(not(any(target_arch = "x86_64", target_arch="i686")), ignore)]
+#[cfg_attr(qemu, ignore)]
 #[test]
 pub fn test_scm_rights() {
     use nix::sys::uio::IoVec;
@@ -235,11 +635,10 @@ pub fn test_scm_rights() {
 }
 
 // Disable the test on emulated platforms due to not enabled support of AF_ALG in QEMU from rust cross
-#[cfg_attr(not(any(target_arch = "x86_64", target_arch = "i686")), ignore)]
 #[cfg(any(target_os = "linux", target_os= "android"))]
+#[cfg_attr(qemu, ignore)]
 #[test]
 pub fn test_af_alg_cipher() {
-    use libc;
     use nix::sys::uio::IoVec;
     use nix::unistd::read;
     use nix::sys::socket::{socket, sendmsg, bind, accept, setsockopt,
@@ -247,8 +646,13 @@ pub fn test_af_alg_cipher() {
                            ControlMessage, MsgFlags};
     use nix::sys::socket::sockopt::AlgSetKey;
 
+    skip_if_cirrus!("Fails for an unknown reason Cirrus CI.  Bug #1352");
+    // Travis's seccomp profile blocks AF_ALG
+    // https://docs.docker.com/engine/security/seccomp/
+    skip_if_seccomp!(test_af_alg_cipher);
+
     let alg_type = "skcipher";
-    let alg_name = "ctr(aes)";
+    let alg_name = "ctr-aes-aesni";
     // 256-bits secret key
     let key = vec![0u8; 32];
     // 16-bytes IV
@@ -298,12 +702,14 @@ pub fn test_af_alg_cipher() {
     assert_eq!(decrypted, payload);
 }
 
-// Disable the test on emulated platforms due to not enabled support of AF_ALG in QEMU from rust cross
-#[cfg_attr(not(any(target_arch = "x86_64", target_arch = "i686")), ignore)]
+// Disable the test on emulated platforms due to not enabled support of AF_ALG
+// in QEMU from rust cross
 #[cfg(any(target_os = "linux", target_os= "android"))]
+#[cfg_attr(qemu, ignore)]
 #[test]
 pub fn test_af_alg_aead() {
     use libc::{ALG_OP_DECRYPT, ALG_OP_ENCRYPT};
+    use nix::fcntl::{fcntl, FcntlArg, OFlag};
     use nix::sys::uio::IoVec;
     use nix::unistd::{read, close};
     use nix::sys::socket::{socket, sendmsg, bind, accept, setsockopt,
@@ -311,6 +717,11 @@ pub fn test_af_alg_aead() {
                            ControlMessage, MsgFlags};
     use nix::sys::socket::sockopt::{AlgSetKey, AlgSetAeadAuthSize};
 
+    skip_if_cirrus!("Fails for an unknown reason Cirrus CI.  Bug #1352");
+    // Travis's seccomp profile blocks AF_ALG
+    // https://docs.docker.com/engine/security/seccomp/
+    skip_if_seccomp!(test_af_alg_aead);
+
     let auth_size = 4usize;
     let assoc_size = 16u32;
 
@@ -377,16 +788,133 @@ pub fn test_af_alg_aead() {
 
     // allocate buffer for decrypted data
     let mut decrypted = vec![0u8; payload_len + (assoc_size as usize) + auth_size];
+    // Starting with kernel 4.9, the interface changed slightly such that the
+    // authentication tag memory is only needed in the output buffer for encryption
+    // and in the input buffer for decryption.
+    // Do not block on read, as we may have fewer bytes than buffer size
+    fcntl(session_socket,FcntlArg::F_SETFL(OFlag::O_NONBLOCK)).expect("fcntl non_blocking");
     let num_bytes = read(session_socket, &mut decrypted).expect("read decrypt");
 
     assert!(num_bytes >= payload_len + (assoc_size as usize));
     assert_eq!(decrypted[(assoc_size as usize)..(payload_len + (assoc_size as usize))], payload[(assoc_size as usize)..payload_len + (assoc_size as usize)]);
 }
 
+// Verify `ControlMessage::Ipv4PacketInfo` for `sendmsg`.
+// This creates a (udp) socket bound to localhost, then sends a message to
+// itself but uses Ipv4PacketInfo to force the source address to be localhost.
+//
+// This would be a more interesting test if we could assume that the test host
+// has more than one IP address (since we could select a different address to
+// test from).
+#[cfg(any(target_os = "linux",
+        target_os = "macos",
+        target_os = "netbsd"))]
+#[test]
+pub fn test_sendmsg_ipv4packetinfo() {
+    use cfg_if::cfg_if;
+    use nix::sys::uio::IoVec;
+    use nix::sys::socket::{socket, sendmsg, bind,
+                           AddressFamily, SockType, SockFlag, SockAddr,
+                           ControlMessage, MsgFlags};
+
+    let sock = socket(AddressFamily::Inet,
+                      SockType::Datagram,
+                      SockFlag::empty(),
+                      None)
+        .expect("socket failed");
+
+    let std_sa = SocketAddr::from_str("127.0.0.1:4000").unwrap();
+    let inet_addr = InetAddr::from_std(&std_sa);
+    let sock_addr = SockAddr::new_inet(inet_addr);
+
+    bind(sock, &sock_addr).expect("bind failed");
+
+    let slice = [1u8, 2, 3, 4, 5, 6, 7, 8];
+    let iov = [IoVec::from_slice(&slice)];
+
+    if let InetAddr::V4(sin) = inet_addr {
+        cfg_if! {
+            if #[cfg(target_os = "netbsd")] {
+                let _dontcare = sin;
+                let pi = libc::in_pktinfo {
+                    ipi_ifindex: 0, /* Unspecified interface */
+                    ipi_addr: libc::in_addr { s_addr: 0 },
+                };
+            } else {
+                let pi = libc::in_pktinfo {
+                    ipi_ifindex: 0, /* Unspecified interface */
+                    ipi_addr: libc::in_addr { s_addr: 0 },
+                    ipi_spec_dst: sin.sin_addr,
+                };
+            }
+        }
+
+        let cmsg = [ControlMessage::Ipv4PacketInfo(&pi)];
+
+        sendmsg(sock, &iov, &cmsg, MsgFlags::empty(), Some(&sock_addr))
+            .expect("sendmsg");
+    } else {
+        panic!("No IPv4 addresses available for testing?");
+    }
+}
+
+// Verify `ControlMessage::Ipv6PacketInfo` for `sendmsg`.
+// This creates a (udp) socket bound to ip6-localhost, then sends a message to
+// itself but uses Ipv6PacketInfo to force the source address to be
+// ip6-localhost.
+//
+// This would be a more interesting test if we could assume that the test host
+// has more than one IP address (since we could select a different address to
+// test from).
+#[cfg(any(target_os = "linux",
+        target_os = "macos",
+        target_os = "netbsd",
+        target_os = "freebsd"))]
+#[test]
+pub fn test_sendmsg_ipv6packetinfo() {
+    use nix::errno::Errno;
+    use nix::sys::uio::IoVec;
+    use nix::sys::socket::{socket, sendmsg, bind,
+                           AddressFamily, SockType, SockFlag, SockAddr,
+                           ControlMessage, MsgFlags};
+
+    let sock = socket(AddressFamily::Inet6,
+                      SockType::Datagram,
+                      SockFlag::empty(),
+                      None)
+        .expect("socket failed");
+
+    let std_sa = SocketAddr::from_str("[::1]:6000").unwrap();
+    let inet_addr = InetAddr::from_std(&std_sa);
+    let sock_addr = SockAddr::new_inet(inet_addr);
+
+    if let Err(Errno::EADDRNOTAVAIL) = bind(sock, &sock_addr) {
+        println!("IPv6 not available, skipping test.");
+        return;
+    }
+
+    let slice = [1u8, 2, 3, 4, 5, 6, 7, 8];
+    let iov = [IoVec::from_slice(&slice)];
+
+    if let InetAddr::V6(sin) = inet_addr {
+        let pi = libc::in6_pktinfo {
+            ipi6_ifindex: 0, /* Unspecified interface */
+            ipi6_addr: sin.sin6_addr,
+        };
+
+        let cmsg = [ControlMessage::Ipv6PacketInfo(&pi)];
+
+        sendmsg(sock, &iov, &cmsg, MsgFlags::empty(), Some(&sock_addr))
+            .expect("sendmsg");
+    } else {
+        println!("No IPv6 addresses available for testing: skipping testing Ipv6PacketInfo");
+    }
+}
+
 /// Tests that passing multiple fds using a single `ControlMessage` works.
 // Disable the test on emulated platforms due to a bug in QEMU versions <
 // 2.12.0.  https://bugs.launchpad.net/qemu/+bug/1701808
-#[cfg_attr(not(any(target_arch = "x86_64", target_arch="i686")), ignore)]
+#[cfg_attr(qemu, ignore)]
 #[test]
 fn test_scm_rights_single_cmsg_multiple_fds() {
     use std::os::unix::net::UnixDatagram;
@@ -395,7 +923,6 @@ fn test_scm_rights_single_cmsg_multiple_fds() {
     use nix::sys::socket::{ControlMessage, ControlMessageOwned, MsgFlags,
         sendmsg, recvmsg};
     use nix::sys::uio::IoVec;
-    use libc;
 
     let (send, receive) = UnixDatagram::pair().unwrap();
     let thread = thread::spawn(move || {
@@ -468,29 +995,36 @@ pub fn test_sendmsg_empty_cmsgs() {
     }
 }
 
-#[cfg(any(target_os = "android", target_os = "linux"))]
+#[cfg(any(
+    target_os = "android",
+    target_os = "linux",
+    target_os = "freebsd",
+    target_os = "dragonfly",
+))]
 #[test]
 fn test_scm_credentials() {
-    use libc;
     use nix::sys::uio::IoVec;
     use nix::unistd::{close, getpid, getuid, getgid};
-    use nix::sys::socket::{socketpair, sendmsg, recvmsg, setsockopt,
+    use nix::sys::socket::{socketpair, sendmsg, recvmsg,
                            AddressFamily, SockType, SockFlag,
-                           ControlMessage, ControlMessageOwned, MsgFlags};
-    use nix::sys::socket::sockopt::PassCred;
+                           ControlMessage, ControlMessageOwned, MsgFlags,
+                           UnixCredentials};
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    use nix::sys::socket::{setsockopt, sockopt::PassCred};
 
     let (send, recv) = socketpair(AddressFamily::Unix, SockType::Stream, None, SockFlag::empty())
         .unwrap();
+    #[cfg(any(target_os = "android", target_os = "linux"))]
     setsockopt(recv, PassCred, &true).unwrap();
 
     {
         let iov = [IoVec::from_slice(b"hello")];
-        let cred = libc::ucred {
-            pid: getpid().as_raw(),
-            uid: getuid().as_raw(),
-            gid: getgid().as_raw(),
-        };
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        let cred = UnixCredentials::new();
+        #[cfg(any(target_os = "android", target_os = "linux"))]
         let cmsg = ControlMessage::ScmCredentials(&cred);
+        #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+        let cmsg = ControlMessage::ScmCreds;
         assert_eq!(sendmsg(send, &iov, &[cmsg], MsgFlags::empty(), None).unwrap(), 5);
         close(send).unwrap();
     }
@@ -498,20 +1032,23 @@ fn test_scm_credentials() {
     {
         let mut buf = [0u8; 5];
         let iov = [IoVec::from_mut_slice(&mut buf[..])];
-        let mut cmsgspace = cmsg_space!(libc::ucred);
+        let mut cmsgspace = cmsg_space!(UnixCredentials);
         let msg = recvmsg(recv, &iov, Some(&mut cmsgspace), MsgFlags::empty()).unwrap();
         let mut received_cred = None;
 
         for cmsg in msg.cmsgs() {
-            if let ControlMessageOwned::ScmCredentials(cred) = cmsg {
-                assert!(received_cred.is_none());
-                assert_eq!(cred.pid, getpid().as_raw());
-                assert_eq!(cred.uid, getuid().as_raw());
-                assert_eq!(cred.gid, getgid().as_raw());
-                received_cred = Some(cred);
-            } else {
-                panic!("unexpected cmsg");
-            }
+            let cred = match cmsg {
+                #[cfg(any(target_os = "android", target_os = "linux"))]
+                ControlMessageOwned::ScmCredentials(cred) => cred,
+                #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+                ControlMessageOwned::ScmCreds(cred) => cred,
+                other => panic!("unexpected cmsg {:?}", other),
+            };
+            assert!(received_cred.is_none());
+            assert_eq!(cred.pid(), getpid().as_raw());
+            assert_eq!(cred.uid(), getuid().as_raw());
+            assert_eq!(cred.gid(), getgid().as_raw());
+            received_cred = Some(cred);
         }
         received_cred.expect("no creds received");
         assert_eq!(msg.bytes, 5);
@@ -523,13 +1060,11 @@ fn test_scm_credentials() {
 /// Ensure that we can send `SCM_CREDENTIALS` and `SCM_RIGHTS` with a single
 /// `sendmsg` call.
 #[cfg(any(target_os = "android", target_os = "linux"))]
-// qemu's handling of multiple cmsgs is bugged, ignore tests on non-x86
+// qemu's handling of multiple cmsgs is bugged, ignore tests under emulation
 // see https://bugs.launchpad.net/qemu/+bug/1781280
-#[cfg_attr(not(any(target_arch = "x86_64", target_arch = "x86")), ignore)]
+#[cfg_attr(qemu, ignore)]
 #[test]
 fn test_scm_credentials_and_rights() {
-    use libc;
-
     let space = cmsg_space!(libc::ucred, RawFd);
     test_impl_scm_credentials_and_rights(space);
 }
@@ -537,9 +1072,9 @@ fn test_scm_credentials_and_rights() {
 /// Ensure that passing a an oversized control message buffer to recvmsg
 /// still works.
 #[cfg(any(target_os = "android", target_os = "linux"))]
-// qemu's handling of multiple cmsgs is bugged, ignore tests on non-x86
+// qemu's handling of multiple cmsgs is bugged, ignore tests under emulation
 // see https://bugs.launchpad.net/qemu/+bug/1781280
-#[cfg_attr(not(any(target_arch = "x86_64", target_arch = "x86")), ignore)]
+#[cfg_attr(qemu, ignore)]
 #[test]
 fn test_too_large_cmsgspace() {
     let space = vec![0u8; 1024];
@@ -550,7 +1085,7 @@ fn test_too_large_cmsgspace() {
 fn test_impl_scm_credentials_and_rights(mut space: Vec<u8>) {
     use libc::ucred;
     use nix::sys::uio::IoVec;
-    use nix::unistd::{pipe, read, write, close, getpid, getuid, getgid};
+    use nix::unistd::{pipe, write, close, getpid, getuid, getgid};
     use nix::sys::socket::{socketpair, sendmsg, recvmsg, setsockopt,
                            SockType, SockFlag,
                            ControlMessage, ControlMessageOwned, MsgFlags};
@@ -569,7 +1104,7 @@ fn test_impl_scm_credentials_and_rights(mut space: Vec<u8>) {
             pid: getpid().as_raw(),
             uid: getuid().as_raw(),
             gid: getgid().as_raw(),
-        };
+        }.into();
         let fds = [r];
         let cmsgs = [
             ControlMessage::ScmCredentials(&cred),
@@ -597,9 +1132,9 @@ fn test_impl_scm_credentials_and_rights(mut space: Vec<u8>) {
                 }
                 ControlMessageOwned::ScmCredentials(cred) => {
                     assert!(received_cred.is_none());
-                    assert_eq!(cred.pid, getpid().as_raw());
-                    assert_eq!(cred.uid, getuid().as_raw());
-                    assert_eq!(cred.gid, getgid().as_raw());
+                    assert_eq!(cred.pid(), getpid().as_raw());
+                    assert_eq!(cred.uid(), getuid().as_raw());
+                    assert_eq!(cred.gid(), getgid().as_raw());
                     received_cred = Some(cred);
                 }
                 _ => panic!("unexpected cmsg"),
@@ -660,7 +1195,6 @@ pub fn test_unixdomain() {
 #[cfg(any(target_os = "macos", target_os = "ios"))]
 #[test]
 pub fn test_syscontrol() {
-    use nix::Error;
     use nix::errno::Errno;
     use nix::sys::socket::{socket, SockAddr, SockType, SockFlag, SockProtocol};
 
@@ -668,7 +1202,7 @@ pub fn test_syscontrol() {
                     SockFlag::empty(), SockProtocol::KextControl)
              .expect("socket failed");
     let _sockaddr = SockAddr::new_sys_control(fd, "com.apple.net.utun_control", 0).expect("resolving sys_control name failed");
-    assert_eq!(SockAddr::new_sys_control(fd, "foo.bar.lol", 0).err(), Some(Error::Sys(Errno::ENOENT)));
+    assert_eq!(SockAddr::new_sys_control(fd, "foo.bar.lol", 0).err(), Some(Errno::ENOENT));
 
     // requires root privileges
     // connect(fd, &sockaddr).expect("connect failed");
@@ -683,11 +1217,10 @@ pub fn test_syscontrol() {
     target_os = "netbsd",
     target_os = "openbsd",
 ))]
-fn loopback_address(family: AddressFamily) -> Option<InterfaceAddress> {
+fn loopback_address(family: AddressFamily) -> Option<nix::ifaddrs::InterfaceAddress> {
     use std::io;
     use std::io::Write;
     use nix::ifaddrs::getifaddrs;
-    use nix::sys::socket::SockAddr;
     use nix::net::if_::*;
 
     let addrs = match getifaddrs() {
@@ -730,14 +1263,16 @@ fn loopback_address(family: AddressFamily) -> Option<InterfaceAddress> {
     target_os = "netbsd",
 ))]
 // qemu doesn't seem to be emulating this correctly in these architectures
-#[cfg_attr(any(
-    target_arch = "mips",
-    target_arch = "mips64",
-    target_arch = "powerpc64",
+#[cfg_attr(all(
+    qemu,
+    any(
+        target_arch = "mips",
+        target_arch = "mips64",
+        target_arch = "powerpc64",
+    )
 ), ignore)]
 #[test]
 pub fn test_recv_ipv4pktinfo() {
-    use libc;
     use nix::sys::socket::sockopt::Ipv4PacketInfo;
     use nix::sys::socket::{bind, SockFlag, SockType};
     use nix::sys::socket::{getsockname, setsockopt, socket};
@@ -790,18 +1325,15 @@ pub fn test_recv_ipv4pktinfo() {
         );
 
         let mut cmsgs = msg.cmsgs();
-        match cmsgs.next() {
-            Some(ControlMessageOwned::Ipv4PacketInfo(pktinfo)) => {
-                let i = if_nametoindex(lo_name.as_bytes()).expect("if_nametoindex");
-                assert_eq!(
-                    pktinfo.ipi_ifindex as libc::c_uint,
-                    i,
-                    "unexpected ifindex (expected {}, got {})",
-                    i,
-                    pktinfo.ipi_ifindex
-                );
-            }
-            _ => (),
+        if let Some(ControlMessageOwned::Ipv4PacketInfo(pktinfo)) = cmsgs.next() {
+            let i = if_nametoindex(lo_name.as_bytes()).expect("if_nametoindex");
+            assert_eq!(
+                pktinfo.ipi_ifindex as libc::c_uint,
+                i,
+                "unexpected ifindex (expected {}, got {})",
+                i,
+                pktinfo.ipi_ifindex
+            );
         }
         assert!(cmsgs.next().is_none(), "unexpected additional control msg");
         assert_eq!(msg.bytes, 8);
@@ -820,14 +1352,16 @@ pub fn test_recv_ipv4pktinfo() {
     target_os = "openbsd",
 ))]
 // qemu doesn't seem to be emulating this correctly in these architectures
-#[cfg_attr(any(
-    target_arch = "mips",
-    target_arch = "mips64",
-    target_arch = "powerpc64",
+#[cfg_attr(all(
+    qemu,
+    any(
+        target_arch = "mips",
+        target_arch = "mips64",
+        target_arch = "powerpc64",
+    )
 ), ignore)]
 #[test]
 pub fn test_recvif() {
-    use libc;
     use nix::net::if_::*;
     use nix::sys::socket::sockopt::{Ipv4RecvIf, Ipv4RecvDstAddr};
     use nix::sys::socket::{bind, SockFlag, SockType};
@@ -911,8 +1445,8 @@ pub fn test_recvif() {
                 _ => panic!("unexpected additional control msg"),
             }
         }
-        assert_eq!(rx_recvif, true);
-        assert_eq!(rx_recvdstaddr, true);
+        assert!(rx_recvif);
+        assert!(rx_recvdstaddr);
         assert_eq!(msg.bytes, 8);
         assert_eq!(
             iovec[0].as_slice(),
@@ -931,14 +1465,16 @@ pub fn test_recvif() {
     target_os = "openbsd",
 ))]
 // qemu doesn't seem to be emulating this correctly in these architectures
-#[cfg_attr(any(
-    target_arch = "mips",
-    target_arch = "mips64",
-    target_arch = "powerpc64",
+#[cfg_attr(all(
+    qemu,
+    any(
+        target_arch = "mips",
+        target_arch = "mips64",
+        target_arch = "powerpc64",
+    )
 ), ignore)]
 #[test]
 pub fn test_recv_ipv6pktinfo() {
-    use libc;
     use nix::net::if_::*;
     use nix::sys::socket::sockopt::Ipv6RecvPacketInfo;
     use nix::sys::socket::{bind, SockFlag, SockType};
@@ -991,18 +1527,16 @@ pub fn test_recv_ipv6pktinfo() {
         );
 
         let mut cmsgs = msg.cmsgs();
-        match cmsgs.next() {
-            Some(ControlMessageOwned::Ipv6PacketInfo(pktinfo)) => {
-                let i = if_nametoindex(lo_name.as_bytes()).expect("if_nametoindex");
-                assert_eq!(
-                    pktinfo.ipi6_ifindex,
-                    i,
-                    "unexpected ifindex (expected {}, got {})",
-                    i,
-                    pktinfo.ipi6_ifindex
-                );
-            }
-            _ => (),
+        if let Some(ControlMessageOwned::Ipv6PacketInfo(pktinfo)) = cmsgs.next()
+        {
+            let i = if_nametoindex(lo_name.as_bytes()).expect("if_nametoindex");
+            assert_eq!(
+                pktinfo.ipi6_ifindex as libc::c_uint,
+                i,
+                "unexpected ifindex (expected {}, got {})",
+                i,
+                pktinfo.ipi6_ifindex
+            );
         }
         assert!(cmsgs.next().is_none(), "unexpected additional control msg");
         assert_eq!(msg.bytes, 8);
@@ -1013,11 +1547,10 @@ pub fn test_recv_ipv6pktinfo() {
     }
 }
 
-#[cfg(target_os = "linux")]
+#[cfg(any(target_os = "android", target_os = "linux"))]
+#[cfg_attr(graviton, ignore = "Not supported by the CI environment")]
 #[test]
 pub fn test_vsock() {
-    use libc;
-    use nix::Error;
     use nix::errno::Errno;
     use nix::sys::socket::{AddressFamily, socket, bind, connect, listen,
                            SockAddr, SockType, SockFlag};
@@ -1030,16 +1563,10 @@ pub fn test_vsock() {
                     SockFlag::empty(), None)
              .expect("socket failed");
 
-    // VMADDR_CID_HYPERVISOR and VMADDR_CID_RESERVED are reserved, so we expect
-    // an EADDRNOTAVAIL error.
+    // VMADDR_CID_HYPERVISOR is reserved, so we expect an EADDRNOTAVAIL error.
     let sockaddr = SockAddr::new_vsock(libc::VMADDR_CID_HYPERVISOR, port);
     assert_eq!(bind(s1, &sockaddr).err(),
-               Some(Error::Sys(Errno::EADDRNOTAVAIL)));
-
-    let sockaddr = SockAddr::new_vsock(libc::VMADDR_CID_RESERVED, port);
-    assert_eq!(bind(s1, &sockaddr).err(),
-               Some(Error::Sys(Errno::EADDRNOTAVAIL)));
-
+               Some(Errno::EADDRNOTAVAIL));
 
     let sockaddr = SockAddr::new_vsock(libc::VMADDR_CID_ANY, port);
     assert_eq!(bind(s1, &sockaddr), Ok(()));
@@ -1064,3 +1591,351 @@ pub fn test_vsock() {
     close(s1).unwrap();
     thr.join().unwrap();
 }
+
+// Disable the test on emulated platforms because it fails in Cirrus-CI.  Lack
+// of QEMU support is suspected.
+#[cfg_attr(qemu, ignore)]
+#[cfg(all(target_os = "linux"))]
+#[test]
+fn test_recvmsg_timestampns() {
+    use nix::sys::socket::*;
+    use nix::sys::uio::IoVec;
+    use nix::sys::time::*;
+    use std::time::*;
+
+    // Set up
+    let message = "Ohayō!".as_bytes();
+    let in_socket = socket(
+        AddressFamily::Inet,
+        SockType::Datagram,
+        SockFlag::empty(),
+        None).unwrap();
+    setsockopt(in_socket, sockopt::ReceiveTimestampns, &true).unwrap();
+    let localhost = InetAddr::new(IpAddr::new_v4(127, 0, 0, 1), 0);
+    bind(in_socket, &SockAddr::new_inet(localhost)).unwrap();
+    let address = getsockname(in_socket).unwrap();
+    // Get initial time
+    let time0 = SystemTime::now();
+    // Send the message
+    let iov = [IoVec::from_slice(message)];
+    let flags = MsgFlags::empty();
+    let l = sendmsg(in_socket, &iov, &[], flags, Some(&address)).unwrap();
+    assert_eq!(message.len(), l);
+    // Receive the message
+    let mut buffer = vec![0u8; message.len()];
+    let mut cmsgspace = nix::cmsg_space!(TimeSpec);
+    let iov = [IoVec::from_mut_slice(&mut buffer)];
+    let r = recvmsg(in_socket, &iov, Some(&mut cmsgspace), flags).unwrap();
+    let rtime = match r.cmsgs().next() {
+        Some(ControlMessageOwned::ScmTimestampns(rtime)) => rtime,
+        Some(_) => panic!("Unexpected control message"),
+        None => panic!("No control message")
+    };
+    // Check the final time
+    let time1 = SystemTime::now();
+    // the packet's received timestamp should lie in-between the two system
+    // times, unless the system clock was adjusted in the meantime.
+    let rduration = Duration::new(rtime.tv_sec() as u64,
+    rtime.tv_nsec() as u32);
+    assert!(time0.duration_since(UNIX_EPOCH).unwrap() <= rduration);
+    assert!(rduration <= time1.duration_since(UNIX_EPOCH).unwrap());
+    // Close socket
+    nix::unistd::close(in_socket).unwrap();
+}
+
+// Disable the test on emulated platforms because it fails in Cirrus-CI.  Lack
+// of QEMU support is suspected.
+#[cfg_attr(qemu, ignore)]
+#[cfg(all(target_os = "linux"))]
+#[test]
+fn test_recvmmsg_timestampns() {
+    use nix::sys::socket::*;
+    use nix::sys::uio::IoVec;
+    use nix::sys::time::*;
+    use std::time::*;
+
+    // Set up
+    let message = "Ohayō!".as_bytes();
+    let in_socket = socket(
+        AddressFamily::Inet,
+        SockType::Datagram,
+        SockFlag::empty(),
+        None).unwrap();
+    setsockopt(in_socket, sockopt::ReceiveTimestampns, &true).unwrap();
+    let localhost = InetAddr::new(IpAddr::new_v4(127, 0, 0, 1), 0);
+    bind(in_socket, &SockAddr::new_inet(localhost)).unwrap();
+    let address = getsockname(in_socket).unwrap();
+    // Get initial time
+    let time0 = SystemTime::now();
+    // Send the message
+    let iov = [IoVec::from_slice(message)];
+    let flags = MsgFlags::empty();
+    let l = sendmsg(in_socket, &iov, &[], flags, Some(&address)).unwrap();
+    assert_eq!(message.len(), l);
+    // Receive the message
+    let mut buffer = vec![0u8; message.len()];
+    let mut cmsgspace = nix::cmsg_space!(TimeSpec);
+    let iov = [IoVec::from_mut_slice(&mut buffer)];
+    let mut data = vec![
+        RecvMmsgData {
+            iov,
+            cmsg_buffer: Some(&mut cmsgspace),
+        },
+    ];
+    let r = recvmmsg(in_socket, &mut data, flags, None).unwrap();
+    let rtime = match r[0].cmsgs().next() {
+        Some(ControlMessageOwned::ScmTimestampns(rtime)) => rtime,
+        Some(_) => panic!("Unexpected control message"),
+        None => panic!("No control message")
+    };
+    // Check the final time
+    let time1 = SystemTime::now();
+    // the packet's received timestamp should lie in-between the two system
+    // times, unless the system clock was adjusted in the meantime.
+    let rduration = Duration::new(rtime.tv_sec() as u64,
+    rtime.tv_nsec() as u32);
+    assert!(time0.duration_since(UNIX_EPOCH).unwrap() <= rduration);
+    assert!(rduration <= time1.duration_since(UNIX_EPOCH).unwrap());
+    // Close socket
+    nix::unistd::close(in_socket).unwrap();
+}
+
+// Disable the test on emulated platforms because it fails in Cirrus-CI.  Lack
+// of QEMU support is suspected.
+#[cfg_attr(qemu, ignore)]
+#[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+#[test]
+fn test_recvmsg_rxq_ovfl() {
+    use nix::Error;
+    use nix::sys::socket::*;
+    use nix::sys::uio::IoVec;
+    use nix::sys::socket::sockopt::{RxqOvfl, RcvBuf};
+
+    let message = [0u8; 2048];
+    let bufsize = message.len() * 2;
+
+    let in_socket = socket(
+        AddressFamily::Inet,
+        SockType::Datagram,
+        SockFlag::empty(),
+        None).unwrap();
+    let out_socket = socket(
+        AddressFamily::Inet,
+        SockType::Datagram,
+        SockFlag::empty(),
+        None).unwrap();
+
+    let localhost = InetAddr::new(IpAddr::new_v4(127, 0, 0, 1), 0);
+    bind(in_socket, &SockAddr::new_inet(localhost)).unwrap();
+
+    let address = getsockname(in_socket).unwrap();
+    connect(out_socket, &address).unwrap();
+
+    // Set SO_RXQ_OVFL flag.
+    setsockopt(in_socket, RxqOvfl, &1).unwrap();
+
+    // Set the receiver buffer size to hold only 2 messages.
+    setsockopt(in_socket, RcvBuf, &bufsize).unwrap();
+
+    let mut drop_counter = 0;
+
+    for _ in 0..2 {
+        let iov = [IoVec::from_slice(&message)];
+        let flags = MsgFlags::empty();
+
+        // Send the 3 messages (the receiver buffer can only hold 2 messages)
+        // to create an overflow.
+        for _ in 0..3 {
+            let l = sendmsg(out_socket, &iov, &[], flags, Some(&address)).unwrap();
+            assert_eq!(message.len(), l);
+        }
+
+        // Receive the message and check the drop counter if any.
+        loop {
+            let mut buffer = vec![0u8; message.len()];
+            let mut cmsgspace = nix::cmsg_space!(u32);
+
+            let iov = [IoVec::from_mut_slice(&mut buffer)];
+
+            match recvmsg(
+                in_socket,
+                &iov,
+                Some(&mut cmsgspace),
+                MsgFlags::MSG_DONTWAIT) {
+                Ok(r) => {
+                    drop_counter = match r.cmsgs().next() {
+                        Some(ControlMessageOwned::RxqOvfl(drop_counter)) => drop_counter,
+                        Some(_) => panic!("Unexpected control message"),
+                        None => 0,
+                    };
+                },
+                Err(Error::EAGAIN) => { break; },
+                _ => { panic!("unknown recvmsg() error"); },
+            }
+        }
+    }
+
+    // One packet lost.
+    assert_eq!(drop_counter, 1);
+
+    // Close sockets
+    nix::unistd::close(in_socket).unwrap();
+    nix::unistd::close(out_socket).unwrap();
+}
+
+#[cfg(any(
+    target_os = "linux",
+    target_os = "android",
+))]
+mod linux_errqueue {
+    use nix::sys::socket::*;
+    use super::{FromStr, SocketAddr};
+
+    // Send a UDP datagram to a bogus destination address and observe an ICMP error (v4).
+    //
+    // Disable the test on QEMU because QEMU emulation of IP_RECVERR is broken (as documented on PR
+    // #1514).
+    #[cfg_attr(qemu, ignore)]
+    #[test]
+    fn test_recverr_v4() {
+        #[repr(u8)]
+        enum IcmpTypes {
+            DestUnreach = 3, // ICMP_DEST_UNREACH
+        }
+        #[repr(u8)]
+        enum IcmpUnreachCodes {
+            PortUnreach = 3, // ICMP_PORT_UNREACH
+        }
+
+        test_recverr_impl::<sockaddr_in, _, _>(
+            "127.0.0.1:6800",
+            AddressFamily::Inet,
+            sockopt::Ipv4RecvErr,
+            libc::SO_EE_ORIGIN_ICMP,
+            IcmpTypes::DestUnreach as u8,
+            IcmpUnreachCodes::PortUnreach as u8,
+            // Closure handles protocol-specific testing and returns generic sock_extended_err for
+            // protocol-independent test impl.
+            |cmsg| {
+                if let ControlMessageOwned::Ipv4RecvErr(ext_err, err_addr) = cmsg {
+                    if let Some(origin) = err_addr {
+                        // Validate that our network error originated from 127.0.0.1:0.
+                        assert_eq!(origin.sin_family, AddressFamily::Inet as _);
+                        assert_eq!(Ipv4Addr(origin.sin_addr), Ipv4Addr::new(127, 0, 0, 1));
+                        assert_eq!(origin.sin_port, 0);
+                    } else {
+                        panic!("Expected some error origin");
+                    }
+                    *ext_err
+                } else {
+                    panic!("Unexpected control message {:?}", cmsg);
+                }
+            },
+        )
+    }
+
+    // Essentially the same test as v4.
+    //
+    // Disable the test on QEMU because QEMU emulation of IPV6_RECVERR is broken (as documented on
+    // PR #1514).
+    #[cfg_attr(qemu, ignore)]
+    #[test]
+    fn test_recverr_v6() {
+        #[repr(u8)]
+        enum IcmpV6Types {
+            DestUnreach = 1, // ICMPV6_DEST_UNREACH
+        }
+        #[repr(u8)]
+        enum IcmpV6UnreachCodes {
+            PortUnreach = 4, // ICMPV6_PORT_UNREACH
+        }
+
+        test_recverr_impl::<sockaddr_in6, _, _>(
+            "[::1]:6801",
+            AddressFamily::Inet6,
+            sockopt::Ipv6RecvErr,
+            libc::SO_EE_ORIGIN_ICMP6,
+            IcmpV6Types::DestUnreach as u8,
+            IcmpV6UnreachCodes::PortUnreach as u8,
+            // Closure handles protocol-specific testing and returns generic sock_extended_err for
+            // protocol-independent test impl.
+            |cmsg| {
+                if let ControlMessageOwned::Ipv6RecvErr(ext_err, err_addr) = cmsg {
+                    if let Some(origin) = err_addr {
+                        // Validate that our network error originated from localhost:0.
+                        assert_eq!(origin.sin6_family, AddressFamily::Inet6 as _);
+                        assert_eq!(
+                            Ipv6Addr(origin.sin6_addr),
+                            Ipv6Addr::from_std(&"::1".parse().unwrap()),
+                        );
+                        assert_eq!(origin.sin6_port, 0);
+                    } else {
+                        panic!("Expected some error origin");
+                    }
+                    *ext_err
+                } else {
+                    panic!("Unexpected control message {:?}", cmsg);
+                }
+            },
+        )
+    }
+
+    fn test_recverr_impl<SA, OPT, TESTF>(sa: &str,
+                                         af: AddressFamily,
+                                         opt: OPT,
+                                         ee_origin: u8,
+                                         ee_type: u8,
+                                         ee_code: u8,
+                                         testf: TESTF)
+        where
+            OPT: SetSockOpt<Val = bool>,
+            TESTF: FnOnce(&ControlMessageOwned) -> libc::sock_extended_err,
+    {
+        use nix::errno::Errno;
+        use nix::sys::uio::IoVec;
+
+        const MESSAGE_CONTENTS: &str = "ABCDEF";
+
+        let sock_addr = {
+            let std_sa = SocketAddr::from_str(sa).unwrap();
+            let inet_addr = InetAddr::from_std(&std_sa);
+            SockAddr::new_inet(inet_addr)
+        };
+        let sock = socket(af, SockType::Datagram, SockFlag::SOCK_CLOEXEC, None).unwrap();
+        setsockopt(sock, opt, &true).unwrap();
+        if let Err(e) = sendto(sock, MESSAGE_CONTENTS.as_bytes(), &sock_addr, MsgFlags::empty()) {
+            assert_eq!(e, Errno::EADDRNOTAVAIL);
+            println!("{:?} not available, skipping test.", af);
+            return;
+        }
+
+        let mut buf = [0u8; 8];
+        let iovec = [IoVec::from_mut_slice(&mut buf)];
+        let mut cspace = cmsg_space!(libc::sock_extended_err, SA);
+
+        let msg = recvmsg(sock, &iovec, Some(&mut cspace), MsgFlags::MSG_ERRQUEUE).unwrap();
+        // The sent message / destination associated with the error is returned:
+        assert_eq!(msg.bytes, MESSAGE_CONTENTS.as_bytes().len());
+        assert_eq!(&buf[..msg.bytes], MESSAGE_CONTENTS.as_bytes());
+        // recvmsg(2): "The original destination address of the datagram that caused the error is
+        // supplied via msg_name;" however, this is not literally true.  E.g., an earlier version
+        // of this test used 0.0.0.0 (::0) as the destination address, which was mutated into
+        // 127.0.0.1 (::1).
+        assert_eq!(msg.address, Some(sock_addr));
+
+        // Check for expected control message.
+        let ext_err = match msg.cmsgs().next() {
+            Some(cmsg) => testf(&cmsg),
+            None => panic!("No control message"),
+        };
+
+        assert_eq!(ext_err.ee_errno, libc::ECONNREFUSED as u32);
+        assert_eq!(ext_err.ee_origin, ee_origin);
+        // ip(7): ee_type and ee_code are set from the type and code fields of the ICMP (ICMPv6)
+        // header.
+        assert_eq!(ext_err.ee_type, ee_type);
+        assert_eq!(ext_err.ee_code, ee_code);
+        // ip(7): ee_info contains the discovered MTU for EMSGSIZE errors.
+        assert_eq!(ext_err.ee_info, 0);
+    }
+}
diff --git a/third_party/rust/nix/test/sys/test_sockopt.rs b/third_party/rust/nix/test/sys/test_sockopt.rs
index c4860c0d61d3d..01920fd40ac77 100644
--- a/third_party/rust/nix/test/sys/test_sockopt.rs
+++ b/third_party/rust/nix/test/sys/test_sockopt.rs
@@ -1,12 +1,55 @@
 use rand::{thread_rng, Rng};
 use nix::sys::socket::{socket, sockopt, getsockopt, setsockopt, AddressFamily, SockType, SockFlag, SockProtocol};
+#[cfg(any(target_os = "android", target_os = "linux"))]
+use crate::*;
+
+// NB: FreeBSD supports LOCAL_PEERCRED for SOCK_SEQPACKET, but OSX does not.
+#[cfg(any(
+        target_os = "dragonfly",
+        target_os = "freebsd",
+))]
+#[test]
+pub fn test_local_peercred_seqpacket() {
+    use nix::{
+        unistd::{Gid, Uid},
+        sys::socket::socketpair
+    };
+
+    let (fd1, _fd2) = socketpair(AddressFamily::Unix, SockType::SeqPacket, None,
+                                SockFlag::empty()).unwrap();
+    let xucred = getsockopt(fd1, sockopt::LocalPeerCred).unwrap();
+    assert_eq!(xucred.version(), 0);
+    assert_eq!(Uid::from_raw(xucred.uid()), Uid::current());
+    assert_eq!(Gid::from_raw(xucred.groups()[0]), Gid::current());
+}
+
+#[cfg(any(
+        target_os = "dragonfly",
+        target_os = "freebsd",
+        target_os = "macos",
+        target_os = "ios"
+))]
+#[test]
+pub fn test_local_peercred_stream() {
+    use nix::{
+        unistd::{Gid, Uid},
+        sys::socket::socketpair
+    };
+
+    let (fd1, _fd2) = socketpair(AddressFamily::Unix, SockType::Stream, None,
+                                SockFlag::empty()).unwrap();
+    let xucred = getsockopt(fd1, sockopt::LocalPeerCred).unwrap();
+    assert_eq!(xucred.version(), 0);
+    assert_eq!(Uid::from_raw(xucred.uid()), Uid::current());
+    assert_eq!(Gid::from_raw(xucred.groups()[0]), Gid::current());
+}
 
 #[cfg(target_os = "linux")]
 #[test]
 fn is_so_mark_functional() {
     use nix::sys::socket::sockopt;
 
-    require_capability!(CAP_NET_ADMIN);
+    require_capability!("is_so_mark_functional", CAP_NET_ADMIN);
 
     let s = socket(AddressFamily::Inet, SockType::Stream, SockFlag::empty(), None).unwrap();
     setsockopt(s, sockopt::Mark, &1337).unwrap();
@@ -18,7 +61,7 @@ fn is_so_mark_functional() {
 fn test_so_buf() {
     let fd = socket(AddressFamily::Inet, SockType::Datagram, SockFlag::empty(), SockProtocol::Udp)
              .unwrap();
-    let bufsize: usize = thread_rng().gen_range(4096, 131_072);
+    let bufsize: usize = thread_rng().gen_range(4096..131_072);
     setsockopt(fd, sockopt::SndBuf, &bufsize).unwrap();
     let actual = getsockopt(fd, sockopt::SndBuf).unwrap();
     assert!(actual >= bufsize);
@@ -27,6 +70,57 @@ fn test_so_buf() {
     assert!(actual >= bufsize);
 }
 
+#[test]
+fn test_so_tcp_maxseg() {
+    use std::net::SocketAddr;
+    use std::str::FromStr;
+    use nix::sys::socket::{accept, bind, connect, listen, InetAddr, SockAddr};
+    use nix::unistd::{close, write};
+
+    let std_sa = SocketAddr::from_str("127.0.0.1:4001").unwrap();
+    let inet_addr = InetAddr::from_std(&std_sa);
+    let sock_addr = SockAddr::new_inet(inet_addr);
+
+    let rsock = socket(AddressFamily::Inet, SockType::Stream, SockFlag::empty(), SockProtocol::Tcp)
+                .unwrap();
+    bind(rsock, &sock_addr).unwrap();
+    listen(rsock, 10).unwrap();
+    let initial = getsockopt(rsock, sockopt::TcpMaxSeg).unwrap();
+    // Initial MSS is expected to be 536 (https://tools.ietf.org/html/rfc879#section-1) but some
+    // platforms keep it even lower. This might fail if you've tuned your initial MSS to be larger
+    // than 700
+    cfg_if! {
+        if #[cfg(any(target_os = "android", target_os = "linux"))] {
+            let segsize: u32 = 873;
+            assert!(initial < segsize);
+            setsockopt(rsock, sockopt::TcpMaxSeg, &segsize).unwrap();
+        } else {
+            assert!(initial < 700);
+        }
+    }
+
+    // Connect and check the MSS that was advertised
+    let ssock = socket(AddressFamily::Inet, SockType::Stream, SockFlag::empty(), SockProtocol::Tcp)
+                .unwrap();
+    connect(ssock, &sock_addr).unwrap();
+    let rsess = accept(rsock).unwrap();
+    write(rsess, b"hello").unwrap();
+    let actual = getsockopt(ssock, sockopt::TcpMaxSeg).unwrap();
+    // Actual max segment size takes header lengths into account, max IPv4 options (60 bytes) + max
+    // TCP options (40 bytes) are subtracted from the requested maximum as a lower boundary.
+    cfg_if! {
+        if #[cfg(any(target_os = "android", target_os = "linux"))] {
+            assert!((segsize - 100) <= actual);
+            assert!(actual <= segsize);
+        } else {
+            assert!(initial < actual);
+            assert!(536 < actual);
+        }
+    }
+    close(rsock).unwrap();
+    close(ssock).unwrap();
+}
+
 // The CI doesn't supported getsockopt and setsockopt on emulated processors.
 // It's beleived that a QEMU issue, the tests run ok on a fully emulated system.
 // Current CI just run the binary with QEMU but the Kernel remains the same as the host.
@@ -51,3 +145,55 @@ fn test_tcp_congestion() {
         val
     );
 }
+
+#[test]
+#[cfg(any(target_os = "android", target_os = "linux"))]
+fn test_bindtodevice() {
+    skip_if_not_root!("test_bindtodevice");
+
+    let fd = socket(AddressFamily::Inet, SockType::Stream, SockFlag::empty(), None).unwrap();
+
+    let val = getsockopt(fd, sockopt::BindToDevice).unwrap();
+    setsockopt(fd, sockopt::BindToDevice, &val).unwrap();
+
+    assert_eq!(
+        getsockopt(fd, sockopt::BindToDevice).unwrap(),
+        val
+    );
+}
+
+#[test]
+fn test_so_tcp_keepalive() {
+    let fd = socket(AddressFamily::Inet, SockType::Stream, SockFlag::empty(), SockProtocol::Tcp).unwrap();
+    setsockopt(fd, sockopt::KeepAlive, &true).unwrap();
+    assert!(getsockopt(fd, sockopt::KeepAlive).unwrap());
+
+    #[cfg(any(target_os = "android",
+              target_os = "dragonfly",
+              target_os = "freebsd",
+              target_os = "linux",
+              target_os = "nacl"))] {
+        let x = getsockopt(fd, sockopt::TcpKeepIdle).unwrap();
+        setsockopt(fd, sockopt::TcpKeepIdle, &(x + 1)).unwrap();
+        assert_eq!(getsockopt(fd, sockopt::TcpKeepIdle).unwrap(), x + 1);
+
+        let x = getsockopt(fd, sockopt::TcpKeepCount).unwrap();
+        setsockopt(fd, sockopt::TcpKeepCount, &(x + 1)).unwrap();
+        assert_eq!(getsockopt(fd, sockopt::TcpKeepCount).unwrap(), x + 1);
+
+        let x = getsockopt(fd, sockopt::TcpKeepInterval).unwrap();
+        setsockopt(fd, sockopt::TcpKeepInterval, &(x + 1)).unwrap();
+        assert_eq!(getsockopt(fd, sockopt::TcpKeepInterval).unwrap(), x + 1);
+    }
+}
+
+#[test]
+#[cfg(any(target_os = "android", target_os = "freebsd", target_os = "linux"))]
+fn test_ttl_opts() {
+    let fd4 = socket(AddressFamily::Inet, SockType::Datagram, SockFlag::empty(), None).unwrap();
+    setsockopt(fd4, sockopt::Ipv4Ttl, &1)
+        .expect("setting ipv4ttl on an inet socket should succeed");
+    let fd6 = socket(AddressFamily::Inet6, SockType::Datagram, SockFlag::empty(), None).unwrap();
+    setsockopt(fd6, sockopt::Ipv6Ttl, &1)
+        .expect("setting ipv6ttl on an inet6 socket should succeed");
+}
diff --git a/third_party/rust/nix/test/sys/test_termios.rs b/third_party/rust/nix/test/sys/test_termios.rs
index a14b8ce1a23cb..4a8615437e22d 100644
--- a/third_party/rust/nix/test/sys/test_termios.rs
+++ b/third_party/rust/nix/test/sys/test_termios.rs
@@ -1,10 +1,10 @@
 use std::os::unix::prelude::*;
 use tempfile::tempfile;
 
-use nix::{Error, fcntl};
+use nix::fcntl;
 use nix::errno::Errno;
 use nix::pty::openpty;
-use nix::sys::termios::{self, LocalFlags, OutputFlags, Termios, tcgetattr};
+use nix::sys::termios::{self, LocalFlags, OutputFlags, tcgetattr};
 use nix::unistd::{read, write, close};
 
 /// Helper function analogous to `std::io::Write::write_all`, but for `RawFd`s
@@ -19,10 +19,10 @@ fn write_all(f: RawFd, buf: &[u8]) {
 #[test]
 fn test_tcgetattr_pty() {
     // openpty uses ptname(3) internally
-    let _m = ::PTSNAME_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::PTSNAME_MTX.lock();
 
     let pty = openpty(None, None).expect("openpty failed");
-    assert!(termios::tcgetattr(pty.master).is_ok());
+    assert!(termios::tcgetattr(pty.slave).is_ok());
     close(pty.master).expect("closing the master failed");
     close(pty.slave).expect("closing the slave failed");
 }
@@ -32,28 +32,28 @@ fn test_tcgetattr_pty() {
 fn test_tcgetattr_enotty() {
     let file = tempfile().unwrap();
     assert_eq!(termios::tcgetattr(file.as_raw_fd()).err(),
-               Some(Error::Sys(Errno::ENOTTY)));
+               Some(Errno::ENOTTY));
 }
 
 // Test tcgetattr on an invalid file descriptor
 #[test]
 fn test_tcgetattr_ebadf() {
     assert_eq!(termios::tcgetattr(-1).err(),
-               Some(Error::Sys(Errno::EBADF)));
+               Some(Errno::EBADF));
 }
 
 // Test modifying output flags
 #[test]
 fn test_output_flags() {
     // openpty uses ptname(3) internally
-    let _m = ::PTSNAME_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::PTSNAME_MTX.lock();
 
     // Open one pty to get attributes for the second one
     let mut termios = {
         let pty = openpty(None, None).expect("openpty failed");
         assert!(pty.master > 0);
         assert!(pty.slave > 0);
-        let termios = tcgetattr(pty.master).expect("tcgetattr failed");
+        let termios = tcgetattr(pty.slave).expect("tcgetattr failed");
         close(pty.master).unwrap();
         close(pty.slave).unwrap();
         termios
@@ -77,7 +77,7 @@ fn test_output_flags() {
 
     // Read from the slave verifying that the output has been properly transformed
     let mut buf = [0u8; 10];
-    ::read_exact(pty.slave, &mut buf);
+    crate::read_exact(pty.slave, &mut buf);
     let transformed_string = "foofoofoo\n";
     close(pty.master).unwrap();
     close(pty.slave).unwrap();
@@ -88,14 +88,14 @@ fn test_output_flags() {
 #[test]
 fn test_local_flags() {
     // openpty uses ptname(3) internally
-    let _m = ::PTSNAME_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::PTSNAME_MTX.lock();
 
     // Open one pty to get attributes for the second one
     let mut termios = {
         let pty = openpty(None, None).unwrap();
         assert!(pty.master > 0);
         assert!(pty.slave > 0);
-        let termios = tcgetattr(pty.master).unwrap();
+        let termios = tcgetattr(pty.slave).unwrap();
         close(pty.master).unwrap();
         close(pty.slave).unwrap();
         termios
@@ -126,11 +126,5 @@ fn test_local_flags() {
     let read = read(pty.master, &mut buf).unwrap_err();
     close(pty.master).unwrap();
     close(pty.slave).unwrap();
-    assert_eq!(read, Error::Sys(Errno::EAGAIN));
-}
-
-#[test]
-fn test_cfmakeraw() {
-    let mut termios = unsafe { Termios::default_uninit() };
-    termios::cfmakeraw(&mut termios);
+    assert_eq!(read, Errno::EAGAIN);
 }
diff --git a/third_party/rust/nix/test/sys/test_timerfd.rs b/third_party/rust/nix/test/sys/test_timerfd.rs
new file mode 100644
index 0000000000000..24fb2ac002e1d
--- /dev/null
+++ b/third_party/rust/nix/test/sys/test_timerfd.rs
@@ -0,0 +1,61 @@
+use nix::sys::time::{TimeSpec, TimeValLike};
+use nix::sys::timerfd::{ClockId, Expiration, TimerFd, TimerFlags, TimerSetTimeFlags};
+use std::time::Instant;
+
+#[test]
+pub fn test_timerfd_oneshot() {
+    let timer = TimerFd::new(ClockId::CLOCK_MONOTONIC, TimerFlags::empty()).unwrap();
+
+    let before = Instant::now();
+
+    timer
+        .set(
+            Expiration::OneShot(TimeSpec::seconds(1)),
+            TimerSetTimeFlags::empty(),
+        )
+        .unwrap();
+
+    timer.wait().unwrap();
+
+    let millis = before.elapsed().as_millis();
+    assert!(millis > 900);
+}
+
+#[test]
+pub fn test_timerfd_interval() {
+    let timer = TimerFd::new(ClockId::CLOCK_MONOTONIC, TimerFlags::empty()).unwrap();
+
+    let before = Instant::now();
+    timer
+        .set(
+            Expiration::IntervalDelayed(TimeSpec::seconds(1), TimeSpec::seconds(2)),
+            TimerSetTimeFlags::empty(),
+        )
+        .unwrap();
+
+    timer.wait().unwrap();
+
+    let start_delay = before.elapsed().as_millis();
+    assert!(start_delay > 900);
+
+    timer.wait().unwrap();
+
+    let interval_delay = before.elapsed().as_millis();
+    assert!(interval_delay > 2900);
+}
+
+#[test]
+pub fn test_timerfd_unset() {
+    let timer = TimerFd::new(ClockId::CLOCK_MONOTONIC, TimerFlags::empty()).unwrap();
+
+    timer
+        .set(
+            Expiration::OneShot(TimeSpec::seconds(1)),
+            TimerSetTimeFlags::empty(),
+        )
+        .unwrap();
+
+    timer.unset().unwrap();
+
+    assert!(timer.get().unwrap() == None);
+}
diff --git a/third_party/rust/nix/test/sys/test_uio.rs b/third_party/rust/nix/test/sys/test_uio.rs
index 3e4fc28ceb0e4..c63b58103c670 100644
--- a/third_party/rust/nix/test/sys/test_uio.rs
+++ b/third_party/rust/nix/test/sys/test_uio.rs
@@ -6,13 +6,19 @@ use std::{cmp, iter};
 use std::fs::{OpenOptions};
 use std::os::unix::io::AsRawFd;
 
-use tempfile::{tempfile, tempdir};
+#[cfg(not(target_os = "redox"))]
+use tempfile::tempfile;
+use tempfile::tempdir;
 
 #[test]
 fn test_writev() {
     let mut to_write = Vec::with_capacity(16 * 128);
     for _ in 0..16 {
-        let s: String = thread_rng().sample_iter(&Alphanumeric).take(128).collect();
+        let s: String = thread_rng()
+            .sample_iter(&Alphanumeric)
+            .map(char::from)
+            .take(128)
+            .collect();
         let b = s.as_bytes();
         to_write.extend(b.iter().cloned());
     }
@@ -21,7 +27,7 @@ fn test_writev() {
     let mut consumed = 0;
     while consumed < to_write.len() {
         let left = to_write.len() - consumed;
-        let slice_len = if left <= 64 { left } else { thread_rng().gen_range(64, cmp::min(256, left)) };
+        let slice_len = if left <= 64 { left } else { thread_rng().gen_range(64..cmp::min(256, left)) };
         let b = &to_write[consumed..consumed+slice_len];
         iovecs.push(IoVec::from_slice(b));
         consumed += slice_len;
@@ -53,14 +59,19 @@ fn test_writev() {
 }
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_readv() {
-    let s:String = thread_rng().sample_iter(&Alphanumeric).take(128).collect();
+    let s:String = thread_rng()
+        .sample_iter(&Alphanumeric)
+        .map(char::from)
+        .take(128)
+        .collect();
     let to_write = s.as_bytes().to_vec();
     let mut storage = Vec::new();
     let mut allocated = 0;
     while allocated < to_write.len() {
         let left = to_write.len() - allocated;
-        let vec_len = if left <= 64 { left } else { thread_rng().gen_range(64, cmp::min(256, left)) };
+        let vec_len = if left <= 64 { left } else { thread_rng().gen_range(64..cmp::min(256, left)) };
         let v: Vec<u8> = iter::repeat(0u8).take(vec_len).collect();
         storage.push(v);
         allocated += vec_len;
@@ -97,6 +108,7 @@ fn test_readv() {
 }
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_pwrite() {
     use std::io::Read;
 
@@ -129,7 +141,7 @@ fn test_pread() {
 }
 
 #[test]
-#[cfg(target_os = "linux")]
+#[cfg(not(target_os = "redox"))]
 fn test_pwritev() {
     use std::io::Read;
 
@@ -159,7 +171,7 @@ fn test_pwritev() {
 }
 
 #[test]
-#[cfg(target_os = "linux")]
+#[cfg(not(target_os = "redox"))]
 fn test_preadv() {
     use std::io::Write;
 
@@ -193,21 +205,23 @@ fn test_preadv() {
 
 #[test]
 #[cfg(target_os = "linux")]
-// FIXME: qemu-user doesn't implement process_vm_readv/writev on most arches
-#[cfg_attr(not(any(target_arch = "x86", target_arch = "x86_64")), ignore)]
+// qemu-user doesn't implement process_vm_readv/writev on most arches
+#[cfg_attr(qemu, ignore)]
 fn test_process_vm_readv() {
     use nix::unistd::ForkResult::*;
     use nix::sys::signal::*;
     use nix::sys::wait::*;
+    use crate::*;
 
-    let _ = ::FORK_MTX.lock().expect("Mutex got poisoned by another test");
+    require_capability!("test_process_vm_readv", CAP_SYS_PTRACE);
+    let _m = crate::FORK_MTX.lock();
 
     // Pre-allocate memory in the child, since allocation isn't safe
     // post-fork (~= async-signal-safe)
     let mut vector = vec![1u8, 2, 3, 4, 5];
 
     let (r, w) = pipe().unwrap();
-    match fork().expect("Error: Fork Failed") {
+    match unsafe{fork()}.expect("Error: Fork Failed") {
         Parent { child } => {
             close(w).unwrap();
             // wait for child
diff --git a/third_party/rust/nix/test/sys/test_wait.rs b/third_party/rust/nix/test/sys/test_wait.rs
index d07d82f0d9075..afe4f42b29872 100644
--- a/third_party/rust/nix/test/sys/test_wait.rs
+++ b/third_party/rust/nix/test/sys/test_wait.rs
@@ -1,4 +1,4 @@
-use nix::Error;
+use nix::errno::Errno;
 use nix::unistd::*;
 use nix::unistd::ForkResult::*;
 use nix::sys::signal::*;
@@ -6,11 +6,12 @@ use nix::sys::wait::*;
 use libc::_exit;
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_wait_signal() {
-    let _ = ::FORK_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::FORK_MTX.lock();
 
     // Safe: The child only calls `pause` and/or `_exit`, which are async-signal-safe.
-    match fork().expect("Error: Fork Failed") {
+    match unsafe{fork()}.expect("Error: Fork Failed") {
       Child => {
           pause();
           unsafe { _exit(123) }
@@ -24,10 +25,10 @@ fn test_wait_signal() {
 
 #[test]
 fn test_wait_exit() {
-    let _m = ::FORK_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::FORK_MTX.lock();
 
     // Safe: Child only calls `_exit`, which is async-signal-safe.
-    match fork().expect("Error: Fork Failed") {
+    match unsafe{fork()}.expect("Error: Fork Failed") {
       Child => unsafe { _exit(12); },
       Parent { child } => {
           assert_eq!(waitpid(child, None), Ok(WaitStatus::Exited(child, 12)));
@@ -40,14 +41,14 @@ fn test_waitstatus_from_raw() {
     let pid = Pid::from_raw(1);
     assert_eq!(WaitStatus::from_raw(pid, 0x0002), Ok(WaitStatus::Signaled(pid, Signal::SIGINT, false)));
     assert_eq!(WaitStatus::from_raw(pid, 0x0200), Ok(WaitStatus::Exited(pid, 2)));
-    assert_eq!(WaitStatus::from_raw(pid, 0x7f7f), Err(Error::invalid_argument()));
+    assert_eq!(WaitStatus::from_raw(pid, 0x7f7f), Err(Errno::EINVAL));
 }
 
 #[test]
 fn test_waitstatus_pid() {
-    let _m = ::FORK_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::FORK_MTX.lock();
 
-    match fork().unwrap() {
+    match unsafe{fork()}.unwrap() {
         Child => unsafe { _exit(0) },
         Parent { child } => {
             let status = waitpid(child, None).unwrap();
@@ -66,6 +67,7 @@ mod ptrace {
     use nix::unistd::*;
     use nix::unistd::ForkResult::*;
     use libc::_exit;
+    use crate::*;
 
     fn ptrace_child() -> ! {
         ptrace::traceme().unwrap();
@@ -82,7 +84,7 @@ mod ptrace {
         assert!(ptrace::setoptions(child, Options::PTRACE_O_TRACESYSGOOD | Options::PTRACE_O_TRACEEXIT).is_ok());
 
         // First, stop on the next system call, which will be exit()
-        assert!(ptrace::syscall(child).is_ok());
+        assert!(ptrace::syscall(child, None).is_ok());
         assert_eq!(waitpid(child, None), Ok(WaitStatus::PtraceSyscall(child)));
         // Then get the ptrace event for the process exiting
         assert!(ptrace::cont(child, None).is_ok());
@@ -94,9 +96,10 @@ mod ptrace {
 
     #[test]
     fn test_wait_ptrace() {
-        let _m = ::FORK_MTX.lock().expect("Mutex got poisoned by another test");
+        require_capability!("test_wait_ptrace", CAP_SYS_PTRACE);
+        let _m = crate::FORK_MTX.lock();
 
-        match fork().expect("Error: Fork Failed") {
+        match unsafe{fork()}.expect("Error: Fork Failed") {
             Child => ptrace_child(),
             Parent { child } => ptrace_parent(child),
         }
diff --git a/third_party/rust/nix/test/test.rs b/third_party/rust/nix/test/test.rs
index 6a71d261b5712..aade937ab977f 100644
--- a/third_party/rust/nix/test/test.rs
+++ b/third_party/rust/nix/test/test.rs
@@ -1,84 +1,36 @@
-// XXX Allow deprecated items until release 0.16.0.  See issue #1096.
-#![allow(deprecated)]
-extern crate bytes;
-#[cfg(any(target_os = "android", target_os = "linux"))]
-extern crate caps;
 #[macro_use]
 extern crate cfg_if;
-#[macro_use]
+#[cfg_attr(not(target_os = "redox"), macro_use)]
 extern crate nix;
 #[macro_use]
 extern crate lazy_static;
-extern crate libc;
-extern crate rand;
-#[cfg(target_os = "freebsd")]
-extern crate sysctl;
-extern crate tempfile;
-
-#[cfg(any(target_os = "android", target_os = "linux"))]
-macro_rules! require_capability {
-    ($capname:ident) => {
-        use ::caps::{Capability, CapSet, has_cap};
-        use ::std::io::{self, Write};
-
-        if !has_cap(None, CapSet::Effective, Capability::$capname).unwrap() {
-            let stderr = io::stderr();
-            let mut handle = stderr.lock();
-            writeln!(handle, "Insufficient capabilities. Skipping test.")
-                .unwrap();
-            return;
-        }
-    }
-}
-
-#[cfg(target_os = "freebsd")]
-macro_rules! skip_if_jailed {
-    ($name:expr) => {
-        use ::sysctl::CtlValue;
-
-        if let CtlValue::Int(1) = ::sysctl::value("security.jail.jailed")
-            .unwrap()
-        {
-            use ::std::io::Write;
-            let stderr = ::std::io::stderr();
-            let mut handle = stderr.lock();
-            writeln!(handle, "{} cannot run in a jail. Skipping test.", $name)
-                .unwrap();
-            return;
-        }
-    }
-}
-
-macro_rules! skip_if_not_root {
-    ($name:expr) => {
-        use nix::unistd::Uid;
-
-        if !Uid::current().is_root() {
-            use ::std::io::Write;
-            let stderr = ::std::io::stderr();
-            let mut handle = stderr.lock();
-            writeln!(handle, "{} requires root privileges. Skipping test.", $name).unwrap();
-            return;
-        }
-    };
-}
 
+mod common;
 mod sys;
+#[cfg(not(target_os = "redox"))]
 mod test_dir;
 mod test_fcntl;
 #[cfg(any(target_os = "android",
           target_os = "linux"))]
 mod test_kmod;
+#[cfg(target_os = "freebsd")]
+mod test_nmount;
 #[cfg(any(target_os = "dragonfly",
           target_os = "freebsd",
           target_os = "fushsia",
           target_os = "linux",
           target_os = "netbsd"))]
 mod test_mq;
+#[cfg(not(target_os = "redox"))]
 mod test_net;
 mod test_nix_path;
+mod test_resource;
 mod test_poll;
+#[cfg(not(any(target_os = "redox", target_os = "fuchsia")))]
 mod test_pty;
+#[cfg(any(target_os = "android",
+          target_os = "linux"))]
+mod test_sched;
 #[cfg(any(target_os = "android",
           target_os = "freebsd",
           target_os = "ios",
@@ -86,13 +38,15 @@ mod test_pty;
           target_os = "macos"))]
 mod test_sendfile;
 mod test_stat;
+mod test_time;
 mod test_unistd;
 
 use std::os::unix::io::RawFd;
 use std::path::PathBuf;
-use std::sync::{Mutex, RwLock, RwLockWriteGuard};
+use parking_lot::{Mutex, RwLock, RwLockWriteGuard};
 use nix::unistd::{chdir, getcwd, read};
 
+
 /// Helper function analogous to `std::io::Read::read_exact`, but for `RawFD`s
 fn read_exact(f: RawFd, buf: &mut  [u8]) {
     let mut len = 0;
@@ -130,8 +84,7 @@ struct DirRestore<'a> {
 
 impl<'a> DirRestore<'a> {
     fn new() -> Self {
-        let guard = ::CWD_LOCK.write()
-            .expect("Lock got poisoned by another test");
+        let guard = crate::CWD_LOCK.write();
         DirRestore{
             _g: guard,
             d: getcwd().unwrap(),
diff --git a/third_party/rust/nix/test/test_clearenv.rs b/third_party/rust/nix/test/test_clearenv.rs
new file mode 100644
index 0000000000000..28a77680498ca
--- /dev/null
+++ b/third_party/rust/nix/test/test_clearenv.rs
@@ -0,0 +1,9 @@
+use std::env;
+
+#[test]
+fn clearenv() {
+    env::set_var("FOO", "BAR");
+    unsafe { nix::env::clearenv() }.unwrap();
+    assert_eq!(env::var("FOO").unwrap_err(), env::VarError::NotPresent);
+    assert_eq!(env::vars().count(), 0);
+}
diff --git a/third_party/rust/nix/test/test_dir.rs b/third_party/rust/nix/test/test_dir.rs
index c42fbcd18a29d..2940b6eafb351 100644
--- a/third_party/rust/nix/test/test_dir.rs
+++ b/third_party/rust/nix/test/test_dir.rs
@@ -1,19 +1,28 @@
-extern crate nix;
-extern crate tempfile;
-
 use nix::dir::{Dir, Type};
 use nix::fcntl::OFlag;
 use nix::sys::stat::Mode;
 use std::fs::File;
-use self::tempfile::tempdir;
+use tempfile::tempdir;
+
+
+#[cfg(test)]
+fn flags() -> OFlag {
+    #[cfg(target_os = "illumos")]
+    let f = OFlag::O_RDONLY | OFlag::O_CLOEXEC;
+
+    #[cfg(not(target_os = "illumos"))]
+    let f = OFlag::O_RDONLY | OFlag::O_CLOEXEC | OFlag::O_DIRECTORY;
+
+    f
+}
 
 #[test]
+#[allow(clippy::unnecessary_sort_by)]   // False positive
 fn read() {
     let tmp = tempdir().unwrap();
     File::create(&tmp.path().join("foo")).unwrap();
     ::std::os::unix::fs::symlink("foo", tmp.path().join("bar")).unwrap();
-    let mut dir = Dir::open(tmp.path(), OFlag::O_DIRECTORY | OFlag::O_RDONLY | OFlag::O_CLOEXEC,
-                            Mode::empty()).unwrap();
+    let mut dir = Dir::open(tmp.path(), flags(), Mode::empty()).unwrap();
     let mut entries: Vec<_> = dir.iter().map(|e| e.unwrap()).collect();
     entries.sort_by(|a, b| a.file_name().cmp(b.file_name()));
     let entry_names: Vec<_> = entries
@@ -33,14 +42,15 @@ fn read() {
 #[test]
 fn rewind() {
     let tmp = tempdir().unwrap();
-    let mut dir = Dir::open(tmp.path(), OFlag::O_DIRECTORY | OFlag::O_RDONLY | OFlag::O_CLOEXEC,
-                            Mode::empty()).unwrap();
+    let mut dir = Dir::open(tmp.path(), flags(), Mode::empty()).unwrap();
     let entries1: Vec<_> = dir.iter().map(|e| e.unwrap().file_name().to_owned()).collect();
     let entries2: Vec<_> = dir.iter().map(|e| e.unwrap().file_name().to_owned()).collect();
+    let entries3: Vec<_> = dir.into_iter().map(|e| e.unwrap().file_name().to_owned()).collect();
     assert_eq!(entries1, entries2);
+    assert_eq!(entries2, entries3);
 }
 
 #[test]
 fn ebadf() {
-    assert_eq!(Dir::from_fd(-1).unwrap_err(), nix::Error::Sys(nix::errno::Errno::EBADF));
+    assert_eq!(Dir::from_fd(-1).unwrap_err(), nix::Error::EBADF);
 }
diff --git a/third_party/rust/nix/test/test_fcntl.rs b/third_party/rust/nix/test/test_fcntl.rs
index 6b2bbd679fc31..db2acfbf520b6 100644
--- a/third_party/rust/nix/test/test_fcntl.rs
+++ b/third_party/rust/nix/test/test_fcntl.rs
@@ -1,14 +1,35 @@
-use nix::Error;
+#[cfg(not(target_os = "redox"))]
 use nix::errno::*;
-use nix::fcntl::{openat, open, OFlag, readlink, readlinkat, renameat};
+#[cfg(not(target_os = "redox"))]
+use nix::fcntl::{open, OFlag, readlink};
+#[cfg(not(target_os = "redox"))]
+use nix::fcntl::{openat, readlinkat, renameat};
+#[cfg(all(
+    target_os = "linux",
+    target_env = "gnu",
+    any(
+        target_arch = "x86_64",
+        target_arch = "x32",
+        target_arch = "powerpc",
+        target_arch = "s390x"
+    )
+))]
+use nix::fcntl::{RenameFlags, renameat2};
+#[cfg(not(target_os = "redox"))]
 use nix::sys::stat::Mode;
+#[cfg(not(target_os = "redox"))]
 use nix::unistd::{close, read};
+#[cfg(not(target_os = "redox"))]
 use tempfile::{self, NamedTempFile};
+#[cfg(not(target_os = "redox"))]
 use std::fs::File;
+#[cfg(not(target_os = "redox"))]
 use std::io::prelude::*;
+#[cfg(not(target_os = "redox"))]
 use std::os::unix::fs;
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_openat() {
     const CONTENTS: &[u8] = b"abcd";
     let mut tmp = NamedTempFile::new().unwrap();
@@ -31,6 +52,7 @@ fn test_openat() {
 }
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_renameat() {
     let old_dir = tempfile::tempdir().unwrap();
     let old_dirfd = open(old_dir.path(), OFlag::empty(), Mode::empty()).unwrap();
@@ -40,13 +62,140 @@ fn test_renameat() {
     let new_dirfd = open(new_dir.path(), OFlag::empty(), Mode::empty()).unwrap();
     renameat(Some(old_dirfd), "old", Some(new_dirfd), "new").unwrap();
     assert_eq!(renameat(Some(old_dirfd), "old", Some(new_dirfd), "new").unwrap_err(),
-               Error::Sys(Errno::ENOENT));
+               Errno::ENOENT);
     close(old_dirfd).unwrap();
     close(new_dirfd).unwrap();
     assert!(new_dir.path().join("new").exists());
 }
 
 #[test]
+#[cfg(all(
+    target_os = "linux",
+    target_env = "gnu",
+    any(
+        target_arch = "x86_64",
+        target_arch = "x32",
+        target_arch = "powerpc",
+        target_arch = "s390x"
+    )
+))]
+fn test_renameat2_behaves_like_renameat_with_no_flags() {
+    let old_dir = tempfile::tempdir().unwrap();
+    let old_dirfd = open(old_dir.path(), OFlag::empty(), Mode::empty()).unwrap();
+    let old_path = old_dir.path().join("old");
+    File::create(&old_path).unwrap();
+    let new_dir = tempfile::tempdir().unwrap();
+    let new_dirfd = open(new_dir.path(), OFlag::empty(), Mode::empty()).unwrap();
+    renameat2(
+        Some(old_dirfd),
+        "old",
+        Some(new_dirfd),
+        "new",
+        RenameFlags::empty(),
+    )
+    .unwrap();
+    assert_eq!(
+        renameat2(
+            Some(old_dirfd),
+            "old",
+            Some(new_dirfd),
+            "new",
+            RenameFlags::empty()
+        )
+        .unwrap_err(),
+        Errno::ENOENT
+    );
+    close(old_dirfd).unwrap();
+    close(new_dirfd).unwrap();
+    assert!(new_dir.path().join("new").exists());
+}
+
+#[test]
+#[cfg(all(
+    target_os = "linux",
+    target_env = "gnu",
+    any(
+        target_arch = "x86_64",
+        target_arch = "x32",
+        target_arch = "powerpc",
+        target_arch = "s390x"
+    )
+))]
+fn test_renameat2_exchange() {
+    let old_dir = tempfile::tempdir().unwrap();
+    let old_dirfd = open(old_dir.path(), OFlag::empty(), Mode::empty()).unwrap();
+    let old_path = old_dir.path().join("old");
+    {
+        let mut old_f = File::create(&old_path).unwrap();
+        old_f.write_all(b"old").unwrap();
+    }
+    let new_dir = tempfile::tempdir().unwrap();
+    let new_dirfd = open(new_dir.path(), OFlag::empty(), Mode::empty()).unwrap();
+    let new_path = new_dir.path().join("new");
+    {
+        let mut new_f = File::create(&new_path).unwrap();
+        new_f.write_all(b"new").unwrap();
+    }
+    renameat2(
+        Some(old_dirfd),
+        "old",
+        Some(new_dirfd),
+        "new",
+        RenameFlags::RENAME_EXCHANGE,
+    )
+    .unwrap();
+    let mut buf = String::new();
+    let mut new_f = File::open(&new_path).unwrap();
+    new_f.read_to_string(&mut buf).unwrap();
+    assert_eq!(buf, "old");
+    buf = "".to_string();
+    let mut old_f = File::open(&old_path).unwrap();
+    old_f.read_to_string(&mut buf).unwrap();
+    assert_eq!(buf, "new");
+    close(old_dirfd).unwrap();
+    close(new_dirfd).unwrap();
+}
+
+#[test]
+#[cfg(all(
+    target_os = "linux",
+    target_env = "gnu",
+    any(
+        target_arch = "x86_64",
+        target_arch = "x32",
+        target_arch = "powerpc",
+        target_arch = "s390x"
+    )
+))]
+fn test_renameat2_noreplace() {
+    let old_dir = tempfile::tempdir().unwrap();
+    let old_dirfd = open(old_dir.path(), OFlag::empty(), Mode::empty()).unwrap();
+    let old_path = old_dir.path().join("old");
+    File::create(&old_path).unwrap();
+    let new_dir = tempfile::tempdir().unwrap();
+    let new_dirfd = open(new_dir.path(), OFlag::empty(), Mode::empty()).unwrap();
+    let new_path = new_dir.path().join("new");
+    File::create(&new_path).unwrap();
+    assert_eq!(
+        renameat2(
+            Some(old_dirfd),
+            "old",
+            Some(new_dirfd),
+            "new",
+            RenameFlags::RENAME_NOREPLACE
+        )
+        .unwrap_err(),
+        Errno::EEXIST
+    );
+    close(old_dirfd).unwrap();
+    close(new_dirfd).unwrap();
+    assert!(new_dir.path().join("new").exists());
+    assert!(old_dir.path().join("old").exists());
+}
+
+
+#[test]
+#[cfg(not(target_os = "redox"))]
 fn test_readlink() {
     let tempdir = tempfile::tempdir().unwrap();
     let src = tempdir.path().join("a");
@@ -56,12 +205,11 @@ fn test_readlink() {
     let dirfd = open(tempdir.path(),
                      OFlag::empty(),
                      Mode::empty()).unwrap();
+    let expected_dir = src.to_str().unwrap();
+
+    assert_eq!(readlink(&dst).unwrap().to_str().unwrap(), expected_dir);
+    assert_eq!(readlinkat(dirfd, "b").unwrap().to_str().unwrap(), expected_dir);
 
-    let mut buf = vec![0; src.to_str().unwrap().len() + 1];
-    assert_eq!(readlink(&dst, &mut buf).unwrap().to_str().unwrap(),
-               src.to_str().unwrap());
-    assert_eq!(readlinkat(dirfd, "b", &mut buf).unwrap().to_str().unwrap(),
-               src.to_str().unwrap());
 }
 
 #[cfg(any(target_os = "linux", target_os = "android"))]
@@ -69,14 +217,17 @@ mod linux_android {
     use std::io::prelude::*;
     use std::io::SeekFrom;
     use std::os::unix::prelude::*;
-
     use libc::loff_t;
 
     use nix::fcntl::*;
     use nix::sys::uio::IoVec;
     use nix::unistd::{close, pipe, read, write};
 
-    use tempfile::{tempfile, NamedTempFile};
+    use tempfile::tempfile;
+    #[cfg(any(target_os = "linux"))]
+    use tempfile::NamedTempFile;
+
+    use crate::*;
 
     /// This test creates a temporary file containing the contents
     /// 'foobarbaz' and uses the `copy_file_range` call to transfer
@@ -84,11 +235,9 @@ mod linux_android {
     /// resulting file is read and should contain the contents `bar`.
     /// The from_offset should be updated by the call to reflect
     /// the 3 bytes read (6).
-    ///
-    /// FIXME: This test is disabled for linux based builds, because Travis
-    /// Linux version is too old for `copy_file_range`.
     #[test]
-    #[ignore]
+    // QEMU does not support copy_file_range. Skip under qemu
+    #[cfg_attr(qemu, ignore)]
     fn test_copy_file_range() {
         const CONTENTS: &[u8] = b"foobarbaz";
 
@@ -170,9 +319,10 @@ mod linux_android {
 
         let buf1 = b"abcdef";
         let buf2 = b"defghi";
-        let mut iovecs = Vec::with_capacity(2);
-        iovecs.push(IoVec::from_slice(&buf1[0..3]));
-        iovecs.push(IoVec::from_slice(&buf2[0..3]));
+        let iovecs = vec![
+            IoVec::from_slice(&buf1[0..3]),
+            IoVec::from_slice(&buf2[0..3])
+        ];
 
         let res = vmsplice(wr, &iovecs[..], SpliceFFlags::empty()).unwrap();
 
@@ -187,6 +337,7 @@ mod linux_android {
         close(wr).unwrap();
     }
 
+    #[cfg(any(target_os = "linux"))]
     #[test]
     fn test_fallocate() {
         let tmp = NamedTempFile::new().unwrap();
@@ -198,6 +349,109 @@ mod linux_android {
         let mut buf = [0u8; 200];
         assert_eq!(100, read(fd, &mut buf).unwrap());
     }
+
+    // The tests below are disabled for the listed targets
+    // due to OFD locks not being available in the kernel/libc
+    // versions used in the CI environment, probably because
+    // they run under QEMU.
+
+    #[test]
+    #[cfg(all(target_os = "linux", not(target_env = "musl")))]
+    fn test_ofd_write_lock() {
+        use nix::sys::stat::fstat;
+        use std::mem;
+
+        let tmp = NamedTempFile::new().unwrap();
+
+        let fd = tmp.as_raw_fd();
+        let statfs = nix::sys::statfs::fstatfs(&tmp).unwrap();
+        if statfs.filesystem_type() == nix::sys::statfs::OVERLAYFS_SUPER_MAGIC {
+            // OverlayFS is a union file system.  It returns one inode value in
+            // stat(2), but a different one shows up in /proc/locks.  So we must
+            // skip the test.
+            skip!("/proc/locks does not work on overlayfs");
+        }
+        let inode = fstat(fd).expect("fstat failed").st_ino as usize;
+
+        let mut flock: libc::flock = unsafe {
+            mem::zeroed()  // required for Linux/mips
+        };
+        flock.l_type = libc::F_WRLCK as libc::c_short;
+        flock.l_whence = libc::SEEK_SET as libc::c_short;
+        flock.l_start = 0;
+        flock.l_len = 0;
+        flock.l_pid = 0;
+        fcntl(fd, FcntlArg::F_OFD_SETLKW(&flock)).expect("write lock failed");
+        assert_eq!(
+            Some(("OFDLCK".to_string(), "WRITE".to_string())),
+            lock_info(inode)
+        );
+
+        flock.l_type = libc::F_UNLCK as libc::c_short;
+        fcntl(fd, FcntlArg::F_OFD_SETLKW(&flock)).expect("write unlock failed");
+        assert_eq!(None, lock_info(inode));
+    }
+
+    #[test]
+    #[cfg(all(target_os = "linux", not(target_env = "musl")))]
+    fn test_ofd_read_lock() {
+        use nix::sys::stat::fstat;
+        use std::mem;
+
+        let tmp = NamedTempFile::new().unwrap();
+
+        let fd = tmp.as_raw_fd();
+        let statfs = nix::sys::statfs::fstatfs(&tmp).unwrap();
+        if statfs.filesystem_type() == nix::sys::statfs::OVERLAYFS_SUPER_MAGIC {
+            // OverlayFS is a union file system.  It returns one inode value in
+            // stat(2), but a different one shows up in /proc/locks.  So we must
+            // skip the test.
+            skip!("/proc/locks does not work on overlayfs");
+        }
+        let inode = fstat(fd).expect("fstat failed").st_ino as usize;
+
+        let mut flock: libc::flock = unsafe {
+            mem::zeroed()  // required for Linux/mips
+        };
+        flock.l_type = libc::F_RDLCK as libc::c_short;
+        flock.l_whence = libc::SEEK_SET as libc::c_short;
+        flock.l_start = 0;
+        flock.l_len = 0;
+        flock.l_pid = 0;
+        fcntl(fd, FcntlArg::F_OFD_SETLKW(&flock)).expect("read lock failed");
+        assert_eq!(
+            Some(("OFDLCK".to_string(), "READ".to_string())),
+            lock_info(inode)
+        );
+
+        flock.l_type = libc::F_UNLCK as libc::c_short;
+        fcntl(fd, FcntlArg::F_OFD_SETLKW(&flock)).expect("read unlock failed");
+        assert_eq!(None, lock_info(inode));
+    }
+
+    #[cfg(all(target_os = "linux", not(target_env = "musl")))]
+    fn lock_info(inode: usize) -> Option<(String, String)> {
+        use std::{
+            fs::File,
+            io::BufReader
+        };
+
+        let file = File::open("/proc/locks").expect("open /proc/locks failed");
+        let buf = BufReader::new(file);
+
+        for line in buf.lines() {
+            let line = line.unwrap();
+            let parts: Vec<_> = line.split_whitespace().collect();
+            let lock_type = parts[1];
+            let lock_access = parts[3];
+            let ino_parts: Vec<_> = parts[5].split(':').collect();
+            let ino: usize = ino_parts[2].parse().unwrap();
+            if ino == inode {
+                return Some((lock_type.to_string(), lock_access.to_string()));
+            }
+        }
+        None
+    }
 }
 
 #[cfg(any(target_os = "linux",
@@ -206,7 +460,7 @@ mod linux_android {
           target_os = "fuchsia",
           any(target_os = "wasi", target_env = "wasi"),
           target_env = "uclibc",
-          target_env = "freebsd"))]
+          target_os = "freebsd"))]
 mod test_posix_fadvise {
 
     use tempfile::NamedTempFile;
@@ -219,16 +473,68 @@ mod test_posix_fadvise {
     fn test_success() {
         let tmp = NamedTempFile::new().unwrap();
         let fd = tmp.as_raw_fd();
-        let res = posix_fadvise(fd, 0, 100, PosixFadviseAdvice::POSIX_FADV_WILLNEED).unwrap();
+        let res = posix_fadvise(fd, 0, 100, PosixFadviseAdvice::POSIX_FADV_WILLNEED);
 
-        assert_eq!(res, 0);
+        assert!(res.is_ok());
     }
 
     #[test]
     fn test_errno() {
         let (rd, _wr) = pipe().unwrap();
-        let errno = posix_fadvise(rd as RawFd, 0, 100, PosixFadviseAdvice::POSIX_FADV_WILLNEED)
-                                 .unwrap();
-        assert_eq!(errno, Errno::ESPIPE as i32);
+        let res = posix_fadvise(rd as RawFd, 0, 100, PosixFadviseAdvice::POSIX_FADV_WILLNEED);
+        assert_eq!(res, Err(Errno::ESPIPE));
+    }
+}
+
+#[cfg(any(target_os = "linux",
+          target_os = "android",
+          target_os = "emscripten",
+          target_os = "fuchsia",
+          any(target_os = "wasi", target_env = "wasi"),
+          target_os = "freebsd"))]
+mod test_posix_fallocate {
+
+    use tempfile::NamedTempFile;
+    use std::{io::Read, os::unix::io::{RawFd, AsRawFd}};
+    use nix::errno::Errno;
+    use nix::fcntl::*;
+    use nix::unistd::pipe;
+
+    #[test]
+    fn success() {
+        const LEN: usize = 100;
+        let mut tmp = NamedTempFile::new().unwrap();
+        let fd = tmp.as_raw_fd();
+        let res = posix_fallocate(fd, 0, LEN as libc::off_t);
+        match res {
+            Ok(_) => {
+                let mut data = [1u8; LEN];
+                assert_eq!(tmp.read(&mut data).expect("read failure"), LEN);
+                assert_eq!(&data[..], &[0u8; LEN][..]);
+            }
+            Err(Errno::EINVAL) => {
+                // POSIX requires posix_fallocate to return EINVAL both for
+                // invalid arguments (i.e. len < 0) and if the operation is not
+                // supported by the file system.
+                // There's no way to tell for sure whether the file system
+                // supports posix_fallocate, so we must pass the test if it
+                // returns EINVAL.
+            }
+            _ => res.unwrap(),
+        }
+    }
+
+    #[test]
+    fn errno() {
+        let (rd, _wr) = pipe().unwrap();
+        let err = posix_fallocate(rd as RawFd, 0, 100).unwrap_err();
+        match err {
+            Errno::EINVAL | Errno::ENODEV | Errno::ESPIPE | Errno::EBADF => (),
+            errno =>
+                panic!(
+                    "unexpected errno {}",
+                    errno,
+                ),
+        }
     }
 }
diff --git a/third_party/rust/nix/test/test_kmod/mod.rs b/third_party/rust/nix/test/test_kmod/mod.rs
index ad406357b06d2..8eef5384a36e2 100644
--- a/third_party/rust/nix/test/test_kmod/mod.rs
+++ b/third_party/rust/nix/test/test_kmod/mod.rs
@@ -2,11 +2,10 @@ use std::fs::copy;
 use std::path::PathBuf;
 use std::process::Command;
 use tempfile::{tempdir, TempDir};
+use crate::*;
 
 fn compile_kernel_module() -> (PathBuf, String, TempDir) {
-    let _m = ::FORK_MTX
-        .lock()
-        .expect("Mutex got poisoned by another test");
+    let _m = crate::FORK_MTX.lock();
 
     let tmp_dir = tempdir().expect("unable to create temporary build directory");
 
@@ -33,16 +32,15 @@ fn compile_kernel_module() -> (PathBuf, String, TempDir) {
 use nix::errno::Errno;
 use nix::kmod::{delete_module, DeleteModuleFlags};
 use nix::kmod::{finit_module, init_module, ModuleInitFlags};
-use nix::Error;
 use std::ffi::CString;
 use std::fs::File;
 use std::io::Read;
 
 #[test]
 fn test_finit_and_delete_module() {
-    require_capability!(CAP_SYS_MODULE);
-    let _m0 = ::KMOD_MTX.lock().expect("Mutex got poisoned by another test");
-    let _m1 = ::CWD_LOCK.read().expect("Mutex got poisoned by another test");
+    require_capability!("test_finit_and_delete_module", CAP_SYS_MODULE);
+    let _m0 = crate::KMOD_MTX.lock();
+    let _m1 = crate::CWD_LOCK.read();
 
     let (kmod_path, kmod_name, _kmod_dir) = compile_kernel_module();
 
@@ -57,10 +55,10 @@ fn test_finit_and_delete_module() {
 }
 
 #[test]
-fn test_finit_and_delete_modul_with_params() {
-    require_capability!(CAP_SYS_MODULE);
-    let _m0 = ::KMOD_MTX.lock().expect("Mutex got poisoned by another test");
-    let _m1 = ::CWD_LOCK.read().expect("Mutex got poisoned by another test");
+fn test_finit_and_delete_module_with_params() {
+    require_capability!("test_finit_and_delete_module_with_params", CAP_SYS_MODULE);
+    let _m0 = crate::KMOD_MTX.lock();
+    let _m1 = crate::CWD_LOCK.read();
 
     let (kmod_path, kmod_name, _kmod_dir) = compile_kernel_module();
 
@@ -79,9 +77,9 @@ fn test_finit_and_delete_modul_with_params() {
 
 #[test]
 fn test_init_and_delete_module() {
-    require_capability!(CAP_SYS_MODULE);
-    let _m0 = ::KMOD_MTX.lock().expect("Mutex got poisoned by another test");
-    let _m1 = ::CWD_LOCK.read().expect("Mutex got poisoned by another test");
+    require_capability!("test_init_and_delete_module", CAP_SYS_MODULE);
+    let _m0 = crate::KMOD_MTX.lock();
+    let _m1 = crate::CWD_LOCK.read();
 
     let (kmod_path, kmod_name, _kmod_dir) = compile_kernel_module();
 
@@ -89,7 +87,7 @@ fn test_init_and_delete_module() {
     let mut contents: Vec<u8> = Vec::new();
     f.read_to_end(&mut contents)
         .expect("unable to read kernel module content to buffer");
-    init_module(&mut contents, &CString::new("").unwrap()).expect("unable to load kernel module");
+    init_module(&contents, &CString::new("").unwrap()).expect("unable to load kernel module");
 
     delete_module(
         &CString::new(kmod_name).unwrap(),
@@ -99,9 +97,9 @@ fn test_init_and_delete_module() {
 
 #[test]
 fn test_init_and_delete_module_with_params() {
-    require_capability!(CAP_SYS_MODULE);
-    let _m0 = ::KMOD_MTX.lock().expect("Mutex got poisoned by another test");
-    let _m1 = ::CWD_LOCK.read().expect("Mutex got poisoned by another test");
+    require_capability!("test_init_and_delete_module_with_params", CAP_SYS_MODULE);
+    let _m0 = crate::KMOD_MTX.lock();
+    let _m1 = crate::CWD_LOCK.read();
 
     let (kmod_path, kmod_name, _kmod_dir) = compile_kernel_module();
 
@@ -109,7 +107,7 @@ fn test_init_and_delete_module_with_params() {
     let mut contents: Vec<u8> = Vec::new();
     f.read_to_end(&mut contents)
         .expect("unable to read kernel module content to buffer");
-    init_module(&mut contents, &CString::new("who=Nix number=2015").unwrap())
+    init_module(&contents, &CString::new("who=Nix number=2015").unwrap())
         .expect("unable to load kernel module");
 
     delete_module(
@@ -120,23 +118,23 @@ fn test_init_and_delete_module_with_params() {
 
 #[test]
 fn test_finit_module_invalid() {
-    require_capability!(CAP_SYS_MODULE);
-    let _m0 = ::KMOD_MTX.lock().expect("Mutex got poisoned by another test");
-    let _m1 = ::CWD_LOCK.read().expect("Mutex got poisoned by another test");
+    require_capability!("test_finit_module_invalid", CAP_SYS_MODULE);
+    let _m0 = crate::KMOD_MTX.lock();
+    let _m1 = crate::CWD_LOCK.read();
 
     let kmod_path = "/dev/zero";
 
     let f = File::open(kmod_path).expect("unable to open kernel module");
     let result = finit_module(&f, &CString::new("").unwrap(), ModuleInitFlags::empty());
 
-    assert_eq!(result.unwrap_err(), Error::Sys(Errno::EINVAL));
+    assert_eq!(result.unwrap_err(), Errno::EINVAL);
 }
 
 #[test]
 fn test_finit_module_twice_and_delete_module() {
-    require_capability!(CAP_SYS_MODULE);
-    let _m0 = ::KMOD_MTX.lock().expect("Mutex got poisoned by another test");
-    let _m1 = ::CWD_LOCK.read().expect("Mutex got poisoned by another test");
+    require_capability!("test_finit_module_twice_and_delete_module", CAP_SYS_MODULE);
+    let _m0 = crate::KMOD_MTX.lock();
+    let _m1 = crate::CWD_LOCK.read();
 
     let (kmod_path, kmod_name, _kmod_dir) = compile_kernel_module();
 
@@ -146,7 +144,7 @@ fn test_finit_module_twice_and_delete_module() {
 
     let result = finit_module(&f, &CString::new("").unwrap(), ModuleInitFlags::empty());
 
-    assert_eq!(result.unwrap_err(), Error::Sys(Errno::EEXIST));
+    assert_eq!(result.unwrap_err(), Errno::EEXIST);
 
     delete_module(
         &CString::new(kmod_name).unwrap(),
@@ -156,11 +154,11 @@ fn test_finit_module_twice_and_delete_module() {
 
 #[test]
 fn test_delete_module_not_loaded() {
-    require_capability!(CAP_SYS_MODULE);
-    let _m0 = ::KMOD_MTX.lock().expect("Mutex got poisoned by another test");
-    let _m1 = ::CWD_LOCK.read().expect("Mutex got poisoned by another test");
+    require_capability!("test_delete_module_not_loaded", CAP_SYS_MODULE);
+    let _m0 = crate::KMOD_MTX.lock();
+    let _m1 = crate::CWD_LOCK.read();
 
     let result = delete_module(&CString::new("hello").unwrap(), DeleteModuleFlags::empty());
 
-    assert_eq!(result.unwrap_err(), Error::Sys(Errno::ENOENT));
+    assert_eq!(result.unwrap_err(), Errno::ENOENT);
 }
diff --git a/third_party/rust/nix/test/test_mount.rs b/third_party/rust/nix/test/test_mount.rs
index d2e08bc42855d..44287f975ff07 100644
--- a/third_party/rust/nix/test/test_mount.rs
+++ b/third_party/rust/nix/test/test_mount.rs
@@ -1,12 +1,10 @@
+mod common;
+
 // Impelmentation note: to allow unprivileged users to run it, this test makes
 // use of user and mount namespaces. On systems that allow unprivileged user
 // namespaces (Linux >= 3.8 compiled with CONFIG_USER_NS), the test should run
 // without root.
 
-extern crate libc;
-extern crate nix;
-extern crate tempfile;
-
 #[cfg(target_os = "linux")]
 mod test_mount {
     use std::fs::{self, File};
@@ -23,14 +21,13 @@ mod test_mount {
     use nix::sys::stat::{self, Mode};
     use nix::unistd::getuid;
 
-    use tempfile;
-
-    static SCRIPT_CONTENTS: &'static [u8] = b"#!/bin/sh
+    static SCRIPT_CONTENTS: &[u8] = b"#!/bin/sh
 exit 23";
 
     const EXPECTED_STATUS: i32 = 23;
 
     const NONE: Option<&'static [u8]> = None;
+    #[allow(clippy::bind_instead_of_map)]   // False positive
     pub fn test_mount_tmpfs_without_flags_allows_rwx() {
         let tempdir = tempfile::tempdir().unwrap();
 
@@ -226,6 +223,7 @@ fn main() {
     use test_mount::{setup_namespaces, test_mount_tmpfs_without_flags_allows_rwx,
                      test_mount_rdonly_disallows_write, test_mount_noexec_disallows_exec,
                      test_mount_bind};
+    skip_if_cirrus!("Fails for an unknown reason Cirrus CI.  Bug #1351");
     setup_namespaces();
 
     run_tests!(test_mount_tmpfs_without_flags_allows_rwx,
diff --git a/third_party/rust/nix/test/test_mq.rs b/third_party/rust/nix/test/test_mq.rs
index caac4fc261cd6..430df5ddccbe5 100644
--- a/third_party/rust/nix/test/test_mq.rs
+++ b/third_party/rust/nix/test/test_mq.rs
@@ -1,24 +1,21 @@
-use libc::c_long;
-
 use std::ffi::CString;
 use std::str;
 
-use nix::errno::Errno::*;
-use nix::Error::Sys;
-use nix::mqueue::{mq_open, mq_close, mq_send, mq_receive};
+use nix::errno::Errno;
+use nix::mqueue::{mq_open, mq_close, mq_send, mq_receive, mq_attr_member_t};
 use nix::mqueue::{MqAttr, MQ_OFlag};
 use nix::sys::stat::Mode;
 
 #[test]
 fn test_mq_send_and_receive() {
-    const MSG_SIZE: c_long =  32;
+    const MSG_SIZE: mq_attr_member_t = 32;
     let attr =  MqAttr::new(0, 10, MSG_SIZE, 0);
     let mq_name= &CString::new(b"/a_nix_test_queue".as_ref()).unwrap();
 
     let oflag0 = MQ_OFlag::O_CREAT | MQ_OFlag::O_WRONLY;
     let mode = Mode::S_IWUSR | Mode::S_IRUSR | Mode::S_IRGRP | Mode::S_IROTH;
     let r0 = mq_open(mq_name, oflag0, mode, Some(&attr));
-    if let Err(Sys(ENOSYS)) = r0 {
+    if let Err(Errno::ENOSYS) = r0 {
         println!("message queues not supported or module not loaded?");
         return;
     };
@@ -31,7 +28,7 @@ fn test_mq_send_and_receive() {
     let mut buf = [0u8; 32];
     let mut prio = 0u32;
     let len = mq_receive(mqd1, &mut buf, &mut prio).unwrap();
-    assert!(prio == 1);
+    assert_eq!(prio, 1);
 
     mq_close(mqd1).unwrap();
     mq_close(mqd0).unwrap();
@@ -43,13 +40,13 @@ fn test_mq_send_and_receive() {
 #[cfg(not(any(target_os = "netbsd")))]
 fn test_mq_getattr() {
     use nix::mqueue::mq_getattr;
-    const MSG_SIZE: c_long =  32;
+    const MSG_SIZE: mq_attr_member_t = 32;
     let initial_attr =  MqAttr::new(0, 10, MSG_SIZE, 0);
     let mq_name = &CString::new(b"/attr_test_get_attr".as_ref()).unwrap();
     let oflag = MQ_OFlag::O_CREAT | MQ_OFlag::O_WRONLY;
     let mode = Mode::S_IWUSR | Mode::S_IRUSR | Mode::S_IRGRP | Mode::S_IROTH;
     let r = mq_open(mq_name, oflag, mode, Some(&initial_attr));
-    if let Err(Sys(ENOSYS)) = r {
+    if let Err(Errno::ENOSYS) = r {
         println!("message queues not supported or module not loaded?");
         return;
     };
@@ -63,16 +60,20 @@ fn test_mq_getattr() {
 // FIXME: Fix failures for mips in QEMU
 #[test]
 #[cfg(not(any(target_os = "netbsd")))]
-#[cfg_attr(any(target_arch = "mips", target_arch = "mips64"), ignore)]
+#[cfg_attr(all(
+        qemu,
+        any(target_arch = "mips", target_arch = "mips64")
+    ), ignore
+)]
 fn test_mq_setattr() {
     use nix::mqueue::{mq_getattr, mq_setattr};
-    const MSG_SIZE: c_long =  32;
+    const MSG_SIZE: mq_attr_member_t = 32;
     let initial_attr =  MqAttr::new(0, 10, MSG_SIZE, 0);
     let mq_name = &CString::new(b"/attr_test_get_attr".as_ref()).unwrap();
     let oflag = MQ_OFlag::O_CREAT | MQ_OFlag::O_WRONLY;
     let mode = Mode::S_IWUSR | Mode::S_IRUSR | Mode::S_IRGRP | Mode::S_IROTH;
     let r = mq_open(mq_name, oflag, mode, Some(&initial_attr));
-    if let Err(Sys(ENOSYS)) = r {
+    if let Err(Errno::ENOSYS) = r {
         println!("message queues not supported or module not loaded?");
         return;
     };
@@ -87,7 +88,7 @@ fn test_mq_setattr() {
     // O_NONBLOCK can be set (see tests below)
     assert_ne!(new_attr_get, new_attr);
 
-    let new_attr_non_blocking =  MqAttr::new(MQ_OFlag::O_NONBLOCK.bits() as c_long, 10, MSG_SIZE, 0);
+    let new_attr_non_blocking =  MqAttr::new(MQ_OFlag::O_NONBLOCK.bits() as mq_attr_member_t, 10, MSG_SIZE, 0);
     mq_setattr(mqd, &new_attr_non_blocking).unwrap();
     let new_attr_get = mq_getattr(mqd).unwrap();
 
@@ -100,26 +101,30 @@ fn test_mq_setattr() {
 // FIXME: Fix failures for mips in QEMU
 #[test]
 #[cfg(not(any(target_os = "netbsd")))]
-#[cfg_attr(any(target_arch = "mips", target_arch = "mips64"), ignore)]
+#[cfg_attr(all(
+        qemu,
+        any(target_arch = "mips", target_arch = "mips64")
+    ), ignore
+)]
 fn test_mq_set_nonblocking() {
     use nix::mqueue::{mq_getattr, mq_set_nonblock, mq_remove_nonblock};
-    const MSG_SIZE: c_long =  32;
+    const MSG_SIZE: mq_attr_member_t = 32;
     let initial_attr =  MqAttr::new(0, 10, MSG_SIZE, 0);
     let mq_name = &CString::new(b"/attr_test_get_attr".as_ref()).unwrap();
     let oflag = MQ_OFlag::O_CREAT | MQ_OFlag::O_WRONLY;
     let mode = Mode::S_IWUSR | Mode::S_IRUSR | Mode::S_IRGRP | Mode::S_IROTH;
     let r = mq_open(mq_name, oflag, mode, Some(&initial_attr));
-    if let Err(Sys(ENOSYS)) = r {
+    if let Err(Errno::ENOSYS) = r {
         println!("message queues not supported or module not loaded?");
         return;
     };
     let mqd = r.unwrap();
     mq_set_nonblock(mqd).unwrap();
     let new_attr = mq_getattr(mqd);
-    assert!(new_attr.unwrap().flags() == MQ_OFlag::O_NONBLOCK.bits() as c_long);
+    assert_eq!(new_attr.unwrap().flags(), MQ_OFlag::O_NONBLOCK.bits() as mq_attr_member_t);
     mq_remove_nonblock(mqd).unwrap();
     let new_attr = mq_getattr(mqd);
-    assert!(new_attr.unwrap().flags() == 0);
+    assert_eq!(new_attr.unwrap().flags(), 0);
     mq_close(mqd).unwrap();
 }
 
@@ -127,26 +132,26 @@ fn test_mq_set_nonblocking() {
 #[cfg(not(any(target_os = "netbsd")))]
 fn test_mq_unlink() {
     use nix::mqueue::mq_unlink;
-    const MSG_SIZE: c_long =  32;
+    const MSG_SIZE: mq_attr_member_t = 32;
     let initial_attr =  MqAttr::new(0, 10, MSG_SIZE, 0);
     let mq_name_opened = &CString::new(b"/mq_unlink_test".as_ref()).unwrap();
     let mq_name_not_opened = &CString::new(b"/mq_unlink_test".as_ref()).unwrap();
     let oflag = MQ_OFlag::O_CREAT | MQ_OFlag::O_WRONLY;
     let mode = Mode::S_IWUSR | Mode::S_IRUSR | Mode::S_IRGRP | Mode::S_IROTH;
     let r = mq_open(mq_name_opened, oflag, mode, Some(&initial_attr));
-    if let Err(Sys(ENOSYS)) = r {
+    if let Err(Errno::ENOSYS) = r {
         println!("message queues not supported or module not loaded?");
         return;
     };
     let mqd = r.unwrap();
 
     let res_unlink = mq_unlink(mq_name_opened);
-    assert!(res_unlink == Ok(()) );
+    assert_eq!(res_unlink, Ok(()) );
 
     let res_unlink_not_opened = mq_unlink(mq_name_not_opened);
-    assert!(res_unlink_not_opened == Err(Sys(ENOENT)) );
+    assert_eq!(res_unlink_not_opened, Err(Errno::ENOENT) );
 
     mq_close(mqd).unwrap();
     let res_unlink_after_close = mq_unlink(mq_name_opened);
-    assert!(res_unlink_after_close == Err(Sys(ENOENT)) );
+    assert_eq!(res_unlink_after_close, Err(Errno::ENOENT) );
 }
diff --git a/third_party/rust/nix/test/test_net.rs b/third_party/rust/nix/test/test_net.rs
index b8940e718bdf3..40ecd6bb754fa 100644
--- a/third_party/rust/nix/test/test_net.rs
+++ b/third_party/rust/nix/test/test_net.rs
@@ -8,5 +8,5 @@ const LOOPBACK: &[u8] = b"lo0";
 
 #[test]
 fn test_if_nametoindex() {
-    assert!(if_nametoindex(&LOOPBACK[..]).is_ok());
+    assert!(if_nametoindex(LOOPBACK).is_ok());
 }
diff --git a/third_party/rust/nix/test/test_nmount.rs b/third_party/rust/nix/test/test_nmount.rs
new file mode 100644
index 0000000000000..4c74ecf627330
--- /dev/null
+++ b/third_party/rust/nix/test/test_nmount.rs
@@ -0,0 +1,51 @@
+use crate::*;
+use nix::{
+    errno::Errno,
+    mount::{MntFlags, Nmount, unmount}
+};
+use std::{
+    ffi::CString,
+    fs::File,
+    path::Path
+};
+use tempfile::tempdir;
+
+#[test]
+fn ok() {
+    require_mount!("nullfs");
+
+    let mountpoint = tempdir().unwrap();
+    let target = tempdir().unwrap();
+    let _sentry = File::create(target.path().join("sentry")).unwrap();
+
+    let fstype = CString::new("fstype").unwrap();
+    let nullfs = CString::new("nullfs").unwrap();
+    Nmount::new()
+        .str_opt(&fstype, &nullfs)
+        .str_opt_owned("fspath", mountpoint.path().to_str().unwrap())
+        .str_opt_owned("target", target.path().to_str().unwrap())
+        .nmount(MntFlags::empty()).unwrap();
+    
+    // Now check that the sentry is visible through the mountpoint
+    let exists = Path::exists(&mountpoint.path().join("sentry"));
+
+    // Cleanup the mountpoint before asserting
+    unmount(mountpoint.path(), MntFlags::empty()).unwrap();
+    
+    assert!(exists);
+}
+
+#[test]
+fn bad_fstype() {
+    let mountpoint = tempdir().unwrap();
+    let target = tempdir().unwrap();
+    let _sentry = File::create(target.path().join("sentry")).unwrap();
+
+    let e = Nmount::new()
+        .str_opt_owned("fspath", mountpoint.path().to_str().unwrap())
+        .str_opt_owned("target", target.path().to_str().unwrap())
+        .nmount(MntFlags::empty()).unwrap_err();
+    
+    assert_eq!(e.error(), Errno::EINVAL);
+    assert_eq!(e.errmsg(), Some("Invalid fstype"));
+}
diff --git a/third_party/rust/nix/test/test_poll.rs b/third_party/rust/nix/test/test_poll.rs
index aef40e4792b5a..e4b369f3f2a02 100644
--- a/third_party/rust/nix/test/test_poll.rs
+++ b/third_party/rust/nix/test/test_poll.rs
@@ -1,5 +1,20 @@
-use nix::poll::{PollFlags, poll, PollFd};
-use nix::unistd::{write, pipe};
+use nix::{
+    errno::Errno,
+    poll::{PollFlags, poll, PollFd},
+    unistd::{write, pipe}
+};
+
+macro_rules! loop_while_eintr {
+    ($poll_expr: expr) => {
+        loop {
+            match $poll_expr {
+                Ok(nfds) => break nfds,
+                Err(Errno::EINTR) => (),
+                Err(e) => panic!("{}", e)
+            }
+        }
+    }
+}
 
 #[test]
 fn test_poll() {
@@ -7,7 +22,7 @@ fn test_poll() {
     let mut fds = [PollFd::new(r, PollFlags::POLLIN)];
 
     // Poll an idle pipe.  Should timeout
-    let nfds = poll(&mut fds, 100).unwrap();
+    let nfds = loop_while_eintr!(poll(&mut fds, 100));
     assert_eq!(nfds, 0);
     assert!(!fds[0].revents().unwrap().contains(PollFlags::POLLIN));
 
@@ -37,14 +52,31 @@ fn test_ppoll() {
     let mut fds = [PollFd::new(r, PollFlags::POLLIN)];
 
     // Poll an idle pipe.  Should timeout
-    let nfds = ppoll(&mut fds, timeout, SigSet::empty()).unwrap();
+    let sigset = SigSet::empty();
+    let nfds = loop_while_eintr!(ppoll(&mut fds, Some(timeout), sigset));
     assert_eq!(nfds, 0);
     assert!(!fds[0].revents().unwrap().contains(PollFlags::POLLIN));
 
     write(w, b".").unwrap();
 
     // Poll a readable pipe.  Should return an event.
-    let nfds = ppoll(&mut fds, timeout, SigSet::empty()).unwrap();
+    let nfds = ppoll(&mut fds, Some(timeout), SigSet::empty()).unwrap();
     assert_eq!(nfds, 1);
     assert!(fds[0].revents().unwrap().contains(PollFlags::POLLIN));
 }
+
+#[test]
+fn test_pollfd_fd() {
+    use std::os::unix::io::AsRawFd;
+
+    let pfd = PollFd::new(0x1234, PollFlags::empty());
+    assert_eq!(pfd.as_raw_fd(), 0x1234);
+}
+
+#[test]
+fn test_pollfd_events() {
+    let mut pfd = PollFd::new(-1, PollFlags::POLLIN);
+    assert_eq!(pfd.events(), PollFlags::POLLIN);
+    pfd.set_events(PollFlags::POLLOUT);
+    assert_eq!(pfd.events(), PollFlags::POLLOUT);
+}
diff --git a/third_party/rust/nix/test/test_pty.rs b/third_party/rust/nix/test/test_pty.rs
index 476b15c10128c..71932f2d6e230 100644
--- a/third_party/rust/nix/test/test_pty.rs
+++ b/third_party/rust/nix/test/test_pty.rs
@@ -1,4 +1,5 @@
-use std::io::Write;
+use std::fs::File;
+use std::io::{Read, Write};
 use std::path::Path;
 use std::os::unix::prelude::*;
 use tempfile::tempfile;
@@ -28,7 +29,7 @@ fn test_explicit_close() {
 #[test]
 #[cfg(any(target_os = "android", target_os = "linux"))]
 fn test_ptsname_equivalence() {
-    let _m = ::PTSNAME_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::PTSNAME_MTX.lock();
 
     // Open a new PTTY master
     let master_fd = posix_openpt(OFlag::O_RDWR).unwrap();
@@ -45,7 +46,7 @@ fn test_ptsname_equivalence() {
 #[test]
 #[cfg(any(target_os = "android", target_os = "linux"))]
 fn test_ptsname_copy() {
-    let _m = ::PTSNAME_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::PTSNAME_MTX.lock();
 
     // Open a new PTTY master
     let master_fd = posix_openpt(OFlag::O_RDWR).unwrap();
@@ -54,7 +55,7 @@ fn test_ptsname_copy() {
     // Get the name of the slave
     let slave_name1 = unsafe { ptsname(&master_fd) }.unwrap();
     let slave_name2 = unsafe { ptsname(&master_fd) }.unwrap();
-    assert!(slave_name1 == slave_name2);
+    assert_eq!(slave_name1, slave_name2);
     // Also make sure that the string was actually copied and they point to different parts of
     // memory.
     assert!(slave_name1.as_ptr() != slave_name2.as_ptr());
@@ -71,7 +72,7 @@ fn test_ptsname_r_copy() {
     // Get the name of the slave
     let slave_name1 = ptsname_r(&master_fd).unwrap();
     let slave_name2 = ptsname_r(&master_fd).unwrap();
-    assert!(slave_name1 == slave_name2);
+    assert_eq!(slave_name1, slave_name2);
     assert!(slave_name1.as_ptr() != slave_name2.as_ptr());
 }
 
@@ -79,7 +80,7 @@ fn test_ptsname_r_copy() {
 #[test]
 #[cfg(any(target_os = "android", target_os = "linux"))]
 fn test_ptsname_unique() {
-    let _m = ::PTSNAME_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::PTSNAME_MTX.lock();
 
     // Open a new PTTY master
     let master1_fd = posix_openpt(OFlag::O_RDWR).unwrap();
@@ -95,35 +96,98 @@ fn test_ptsname_unique() {
     assert!(slave_name1 != slave_name2);
 }
 
-/// Test opening a master/slave PTTY pair
-///
-/// This is a single larger test because much of these functions aren't useful by themselves. So for
-/// this test we perform the basic act of getting a file handle for a connect master/slave PTTY
-/// pair.
-#[test]
-fn test_open_ptty_pair() {
-    let _m = ::PTSNAME_MTX.lock().expect("Mutex got poisoned by another test");
+/// Common setup for testing PTTY pairs
+fn open_ptty_pair() -> (PtyMaster, File) {
+    let _m = crate::PTSNAME_MTX.lock();
 
     // Open a new PTTY master
-    let master_fd = posix_openpt(OFlag::O_RDWR).expect("posix_openpt failed");
-    assert!(master_fd.as_raw_fd() > 0);
+    let master = posix_openpt(OFlag::O_RDWR).expect("posix_openpt failed");
 
     // Allow a slave to be generated for it
-    grantpt(&master_fd).expect("grantpt failed");
-    unlockpt(&master_fd).expect("unlockpt failed");
+    grantpt(&master).expect("grantpt failed");
+    unlockpt(&master).expect("unlockpt failed");
 
     // Get the name of the slave
-    let slave_name = unsafe { ptsname(&master_fd) }.expect("ptsname failed");
+    let slave_name = unsafe { ptsname(&master) }.expect("ptsname failed");
 
     // Open the slave device
     let slave_fd = open(Path::new(&slave_name), OFlag::O_RDWR, stat::Mode::empty()).unwrap();
-    assert!(slave_fd > 0);
+
+    #[cfg(target_os = "illumos")]
+    // TODO: rewrite using ioctl!
+    #[allow(clippy::comparison_chain)]
+    {
+        use libc::{ioctl, I_FIND, I_PUSH};
+
+        // On illumos systems, as per pts(7D), one must push STREAMS modules
+        // after opening a device path returned from ptsname().
+        let ptem = b"ptem\0";
+        let ldterm = b"ldterm\0";
+        let r = unsafe { ioctl(slave_fd, I_FIND, ldterm.as_ptr()) };
+        if r < 0 {
+            panic!("I_FIND failure");
+        } else if r == 0 {
+            if unsafe { ioctl(slave_fd, I_PUSH, ptem.as_ptr()) } < 0 {
+                panic!("I_PUSH ptem failure");
+            }
+            if unsafe { ioctl(slave_fd, I_PUSH, ldterm.as_ptr()) } < 0 {
+                panic!("I_PUSH ldterm failure");
+            }
+        }
+    }
+
+    let slave = unsafe { File::from_raw_fd(slave_fd) };
+
+    (master, slave)
+}
+
+/// Test opening a master/slave PTTY pair
+///
+/// This uses a common `open_ptty_pair` because much of these functions aren't useful by
+/// themselves. So for this test we perform the basic act of getting a file handle for a
+/// master/slave PTTY pair, then just sanity-check the raw values.
+#[test]
+fn test_open_ptty_pair() {
+    let (master, slave) = open_ptty_pair();
+    assert!(master.as_raw_fd() > 0);
+    assert!(slave.as_raw_fd() > 0);
+}
+
+/// Put the terminal in raw mode.
+fn make_raw(fd: RawFd) {
+    let mut termios = tcgetattr(fd).unwrap();
+    cfmakeraw(&mut termios);
+    tcsetattr(fd, SetArg::TCSANOW, &termios).unwrap();
+}
+
+/// Test `io::Read` on the PTTY master
+#[test]
+fn test_read_ptty_pair() {
+    let (mut master, mut slave) = open_ptty_pair();
+    make_raw(slave.as_raw_fd());
+
+    let mut buf = [0u8; 5];
+    slave.write_all(b"hello").unwrap();
+    master.read_exact(&mut buf).unwrap();
+    assert_eq!(&buf, b"hello");
+}
+
+/// Test `io::Write` on the PTTY master
+#[test]
+fn test_write_ptty_pair() {
+    let (mut master, mut slave) = open_ptty_pair();
+    make_raw(slave.as_raw_fd());
+
+    let mut buf = [0u8; 5];
+    master.write_all(b"adios").unwrap();
+    slave.read_exact(&mut buf).unwrap();
+    assert_eq!(&buf, b"adios");
 }
 
 #[test]
 fn test_openpty() {
     // openpty uses ptname(3) internally
-    let _m = ::PTSNAME_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::PTSNAME_MTX.lock();
 
     let pty = openpty(None, None).unwrap();
     assert!(pty.master > 0);
@@ -133,21 +197,21 @@ fn test_openpty() {
     let string = "foofoofoo\n";
     let mut buf = [0u8; 10];
     write(pty.master, string.as_bytes()).unwrap();
-    ::read_exact(pty.slave, &mut buf);
+    crate::read_exact(pty.slave, &mut buf);
 
     assert_eq!(&buf, string.as_bytes());
 
     // Read the echo as well
     let echoed_string = "foofoofoo\r\n";
     let mut buf = [0u8; 11];
-    ::read_exact(pty.master, &mut buf);
+    crate::read_exact(pty.master, &mut buf);
     assert_eq!(&buf, echoed_string.as_bytes());
 
     let string2 = "barbarbarbar\n";
     let echoed_string2 = "barbarbarbar\r\n";
     let mut buf = [0u8; 14];
     write(pty.slave, string2.as_bytes()).unwrap();
-    ::read_exact(pty.master, &mut buf);
+    crate::read_exact(pty.master, &mut buf);
 
     assert_eq!(&buf, echoed_string2.as_bytes());
 
@@ -158,14 +222,14 @@ fn test_openpty() {
 #[test]
 fn test_openpty_with_termios() {
     // openpty uses ptname(3) internally
-    let _m = ::PTSNAME_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::PTSNAME_MTX.lock();
 
     // Open one pty to get attributes for the second one
     let mut termios = {
         let pty = openpty(None, None).unwrap();
         assert!(pty.master > 0);
         assert!(pty.slave > 0);
-        let termios = tcgetattr(pty.master).unwrap();
+        let termios = tcgetattr(pty.slave).unwrap();
         close(pty.master).unwrap();
         close(pty.slave).unwrap();
         termios
@@ -182,20 +246,20 @@ fn test_openpty_with_termios() {
     let string = "foofoofoo\n";
     let mut buf = [0u8; 10];
     write(pty.master, string.as_bytes()).unwrap();
-    ::read_exact(pty.slave, &mut buf);
+    crate::read_exact(pty.slave, &mut buf);
 
     assert_eq!(&buf, string.as_bytes());
 
     // read the echo as well
     let echoed_string = "foofoofoo\n";
-    ::read_exact(pty.master, &mut buf);
+    crate::read_exact(pty.master, &mut buf);
     assert_eq!(&buf, echoed_string.as_bytes());
 
     let string2 = "barbarbarbar\n";
     let echoed_string2 = "barbarbarbar\n";
     let mut buf = [0u8; 13];
     write(pty.slave, string2.as_bytes()).unwrap();
-    ::read_exact(pty.master, &mut buf);
+    crate::read_exact(pty.master, &mut buf);
 
     assert_eq!(&buf, echoed_string2.as_bytes());
 
@@ -209,13 +273,15 @@ fn test_forkpty() {
     use nix::sys::signal::*;
     use nix::sys::wait::wait;
     // forkpty calls openpty which uses ptname(3) internally.
-    let _m0 = ::PTSNAME_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m0 = crate::PTSNAME_MTX.lock();
     // forkpty spawns a child process
-    let _m1 = ::FORK_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m1 = crate::FORK_MTX.lock();
 
     let string = "naninani\n";
     let echoed_string = "naninani\r\n";
-    let pty = forkpty(None, None).unwrap();
+    let pty = unsafe {
+        forkpty(None, None).unwrap()
+    };
     match pty.fork_result {
         Child => {
             write(STDOUT_FILENO, string.as_bytes()).unwrap();
@@ -225,7 +291,7 @@ fn test_forkpty() {
         Parent { child } => {
             let mut buf = [0u8; 10];
             assert!(child.as_raw() > 0);
-            ::read_exact(pty.master, &mut buf);
+            crate::read_exact(pty.master, &mut buf);
             kill(child, SIGTERM).unwrap();
             wait().unwrap(); // keep other tests using generic wait from getting our child
             assert_eq!(&buf, echoed_string.as_bytes());
diff --git a/third_party/rust/nix/test/test_ptymaster_drop.rs b/third_party/rust/nix/test/test_ptymaster_drop.rs
index 9b59d66435ed0..a68f81ee1e24f 100644
--- a/third_party/rust/nix/test/test_ptymaster_drop.rs
+++ b/third_party/rust/nix/test/test_ptymaster_drop.rs
@@ -1,21 +1,20 @@
-extern crate nix;
+#[cfg(not(any(target_os = "redox", target_os = "fuchsia")))]
+mod t {
+    use nix::fcntl::OFlag;
+    use nix::pty::*;
+    use nix::unistd::close;
+    use std::os::unix::io::AsRawFd;
 
-use nix::fcntl::OFlag;
-use nix::pty::*;
-use nix::unistd::close;
-use std::os::unix::io::AsRawFd;
-
-/// Regression test for Issue #659
-/// `PtyMaster` should panic rather than double close the file descriptor
-/// This must run in its own test process because it deliberately creates a race
-/// condition.
-#[test]
-#[should_panic(expected = "Closing an invalid file descriptor!")]
-// In Travis on i686-unknown-linux-musl, this test gets SIGABRT.  I don't know
-// why.  It doesn't happen on any other target, and it doesn't happen on my PC.
-#[cfg_attr(all(target_env = "musl", target_arch = "x86"), ignore)]
-fn test_double_close() {
-    let m = posix_openpt(OFlag::O_RDWR).unwrap();
-    close(m.as_raw_fd()).unwrap();
-    drop(m);            // should panic here
+    /// Regression test for Issue #659
+    ///
+    /// `PtyMaster` should panic rather than double close the file descriptor
+    /// This must run in its own test process because it deliberately creates a
+    /// race condition.
+    #[test]
+    #[should_panic(expected = "Closing an invalid file descriptor!")]
+    fn test_double_close() {
+        let m = posix_openpt(OFlag::O_RDWR).unwrap();
+        close(m.as_raw_fd()).unwrap();
+        drop(m);            // should panic here
+    }
 }
diff --git a/third_party/rust/nix/test/test_resource.rs b/third_party/rust/nix/test/test_resource.rs
new file mode 100644
index 0000000000000..5969750091d7e
--- /dev/null
+++ b/third_party/rust/nix/test/test_resource.rs
@@ -0,0 +1,23 @@
+#[cfg(not(any(target_os = "redox", target_os = "fuchsia", target_os = "illumos")))]
+use nix::sys::resource::{getrlimit, setrlimit, Resource};
+
+/// Tests the RLIMIT_NOFILE functionality of getrlimit(), where the resource RLIMIT_NOFILE refers
+/// to the maximum file descriptor number that can be opened by the process (aka the maximum number
+/// of file descriptors that the process can open, since Linux 4.5).
+///
+/// We first fetch the existing file descriptor maximum values using getrlimit(), then edit the
+/// soft limit to make sure it has a new and distinct value to the hard limit. We then setrlimit()
+/// to put the new soft limit in effect, and then getrlimit() once more to ensure the limits have
+/// been updated.
+#[test]
+#[cfg(not(any(target_os = "redox", target_os = "fuchsia", target_os = "illumos")))]
+pub fn test_resource_limits_nofile() {
+    let (soft_limit, hard_limit) = getrlimit(Resource::RLIMIT_NOFILE).unwrap();
+
+    let soft_limit = Some(soft_limit.map_or(1024, |v| v - 1));
+    assert_ne!(soft_limit, hard_limit);
+    setrlimit(Resource::RLIMIT_NOFILE, soft_limit, hard_limit).unwrap();
+
+    let (new_soft_limit, _) = getrlimit(Resource::RLIMIT_NOFILE).unwrap();
+    assert_eq!(new_soft_limit, soft_limit);
+}
diff --git a/third_party/rust/nix/test/test_sched.rs b/third_party/rust/nix/test/test_sched.rs
new file mode 100644
index 0000000000000..922196a3dba73
--- /dev/null
+++ b/third_party/rust/nix/test/test_sched.rs
@@ -0,0 +1,32 @@
+use nix::sched::{sched_getaffinity, sched_setaffinity, CpuSet};
+use nix::unistd::Pid;
+
+#[test]
+fn test_sched_affinity() {
+    // If pid is zero, then the mask of the calling process is returned.
+    let initial_affinity = sched_getaffinity(Pid::from_raw(0)).unwrap();
+    let mut at_least_one_cpu = false;
+    let mut last_valid_cpu = 0;
+    for field in 0..CpuSet::count() {
+        if initial_affinity.is_set(field).unwrap() {
+            at_least_one_cpu = true;
+            last_valid_cpu = field;
+        }
+    }
+    assert!(at_least_one_cpu);
+
+    // Now restrict the running CPU
+    let mut new_affinity = CpuSet::new();
+    new_affinity.set(last_valid_cpu).unwrap();
+    sched_setaffinity(Pid::from_raw(0), &new_affinity).unwrap();
+
+    // And now re-check the affinity which should be only the one we set.
+    let updated_affinity = sched_getaffinity(Pid::from_raw(0)).unwrap();
+    for field in 0..CpuSet::count() {
+        // Should be set only for the CPU we set previously
+        assert_eq!(updated_affinity.is_set(field).unwrap(), field==last_valid_cpu)
+    }
+
+    // Finally, reset the initial CPU set
+    sched_setaffinity(Pid::from_raw(0), &initial_affinity).unwrap();
+}
diff --git a/third_party/rust/nix/test/test_sendfile.rs b/third_party/rust/nix/test/test_sendfile.rs
index 3bc7932f4c84f..b6559d329b470 100644
--- a/third_party/rust/nix/test/test_sendfile.rs
+++ b/third_party/rust/nix/test/test_sendfile.rs
@@ -36,6 +36,28 @@ fn test_sendfile_linux() {
     close(wr).unwrap();
 }
 
+#[cfg(target_os = "linux")]
+#[test]
+fn test_sendfile64_linux() {
+    const CONTENTS: &[u8] = b"abcdef123456";
+    let mut tmp = tempfile().unwrap();
+    tmp.write_all(CONTENTS).unwrap();
+
+    let (rd, wr) = pipe().unwrap();
+    let mut offset: libc::off64_t = 5;
+    let res = sendfile64(wr, tmp.as_raw_fd(), Some(&mut offset), 2).unwrap();
+
+    assert_eq!(2, res);
+
+    let mut buf = [0u8; 1024];
+    assert_eq!(2, read(rd, &mut buf).unwrap());
+    assert_eq!(b"f1", &buf[0..2]);
+    assert_eq!(7, offset);
+
+    close(rd).unwrap();
+    close(wr).unwrap();
+}
+
 #[cfg(target_os = "freebsd")]
 #[test]
 fn test_sendfile_freebsd() {
diff --git a/third_party/rust/nix/test/test_stat.rs b/third_party/rust/nix/test/test_stat.rs
index 1173455fae8db..33cf748da3730 100644
--- a/third_party/rust/nix/test/test_stat.rs
+++ b/third_party/rust/nix/test/test_stat.rs
@@ -1,15 +1,27 @@
-use std::fs::{self, File};
+#[cfg(not(target_os = "redox"))]
+use std::fs;
+use std::fs::File;
+#[cfg(not(target_os = "redox"))]
 use std::os::unix::fs::{symlink, PermissionsExt};
 use std::os::unix::prelude::AsRawFd;
+#[cfg(not(target_os = "redox"))]
 use std::time::{Duration, UNIX_EPOCH};
+#[cfg(not(target_os = "redox"))]
 use std::path::Path;
 
-#[cfg(not(any(target_os = "netbsd")))]
-use libc::{S_IFMT, S_IFLNK, mode_t};
-
-use nix::{fcntl, Error};
-use nix::errno::{Errno};
-use nix::sys::stat::{self, fchmod, fchmodat, futimens, stat, utimes, utimensat, mkdirat};
+#[cfg(not(any(target_os = "netbsd", target_os = "redox")))]
+use libc::{S_IFMT, S_IFLNK};
+use libc::mode_t;
+
+#[cfg(not(target_os = "redox"))]
+use nix::fcntl;
+#[cfg(not(target_os = "redox"))]
+use nix::errno::Errno;
+#[cfg(not(target_os = "redox"))]
+use nix::sys::stat::{self, futimens, utimes};
+use nix::sys::stat::{fchmod, stat};
+#[cfg(not(target_os = "redox"))]
+use nix::sys::stat::{fchmodat, utimensat, mkdirat};
 #[cfg(any(target_os = "linux",
           target_os = "haiku",
           target_os = "ios",
@@ -17,43 +29,37 @@ use nix::sys::stat::{self, fchmod, fchmodat, futimens, stat, utimes, utimensat,
           target_os = "freebsd",
           target_os = "netbsd"))]
 use nix::sys::stat::lutimes;
-use nix::sys::stat::{Mode, FchmodatFlags, UtimensatFlags};
+#[cfg(not(target_os = "redox"))]
+use nix::sys::stat::{FchmodatFlags, UtimensatFlags};
+use nix::sys::stat::Mode;
 
-#[cfg(not(any(target_os = "netbsd")))]
+#[cfg(not(any(target_os = "netbsd", target_os = "redox")))]
 use nix::sys::stat::FileStat;
 
+#[cfg(not(target_os = "redox"))]
 use nix::sys::time::{TimeSpec, TimeVal, TimeValLike};
+#[cfg(not(target_os = "redox"))]
 use nix::unistd::chdir;
 
-#[cfg(not(any(target_os = "netbsd")))]
+#[cfg(not(any(target_os = "netbsd", target_os = "redox")))]
 use nix::Result;
-use tempfile;
-
-#[allow(unused_comparisons)]
-// uid and gid are signed on Windows, but not on other platforms. This function
-// allows warning free compiles on all platforms, and can be removed when
-// expression-level #[allow] is available.
-#[cfg(not(any(target_os = "netbsd")))]
-fn valid_uid_gid(stat: FileStat) -> bool {
-    // uid could be 0 for the `root` user. This quite possible when
-    // the tests are being run on a rooted Android device.
-    stat.st_uid >= 0 && stat.st_gid >= 0
-}
 
-#[cfg(not(any(target_os = "netbsd")))]
+#[cfg(not(any(target_os = "netbsd", target_os = "redox")))]
 fn assert_stat_results(stat_result: Result<FileStat>) {
     let stats = stat_result.expect("stat call failed");
     assert!(stats.st_dev > 0);      // must be positive integer, exact number machine dependent
     assert!(stats.st_ino > 0);      // inode is positive integer, exact number machine dependent
     assert!(stats.st_mode > 0);     // must be positive integer
-    assert!(stats.st_nlink == 1);   // there links created, must be 1
-    assert!(valid_uid_gid(stats));  // must be positive integers
-    assert!(stats.st_size == 0);    // size is 0 because we did not write anything to the file
+    assert_eq!(stats.st_nlink, 1);   // there links created, must be 1
+    assert_eq!(stats.st_size, 0);    // size is 0 because we did not write anything to the file
     assert!(stats.st_blksize > 0);  // must be positive integer, exact number machine dependent
     assert!(stats.st_blocks <= 16);  // Up to 16 blocks can be allocated for a blank file
 }
 
-#[cfg(not(any(target_os = "netbsd")))]
+#[cfg(not(any(target_os = "netbsd", target_os = "redox")))]
+// (Android's st_blocks is ulonglong which is always non-negative.)
+#[cfg_attr(target_os = "android", allow(unused_comparisons))]
+#[allow(clippy::absurd_extreme_comparisons)]    // Not absurd on all OSes
 fn assert_lstat_results(stat_result: Result<FileStat>) {
     let stats = stat_result.expect("stat call failed");
     assert!(stats.st_dev > 0);      // must be positive integer, exact number machine dependent
@@ -63,20 +69,18 @@ fn assert_lstat_results(stat_result: Result<FileStat>) {
     // st_mode is c_uint (u32 on Android) while S_IFMT is mode_t
     // (u16 on Android), and that will be a compile error.
     // On other platforms they are the same (either both are u16 or u32).
-    assert!((stats.st_mode as usize) & (S_IFMT as usize) == S_IFLNK as usize); // should be a link
-    assert!(stats.st_nlink == 1);   // there links created, must be 1
-    assert!(valid_uid_gid(stats));  // must be positive integers
+    assert_eq!((stats.st_mode as usize) & (S_IFMT as usize), S_IFLNK as usize); // should be a link
+    assert_eq!(stats.st_nlink, 1);   // there links created, must be 1
     assert!(stats.st_size > 0);    // size is > 0 because it points to another file
     assert!(stats.st_blksize > 0);  // must be positive integer, exact number machine dependent
 
     // st_blocks depends on whether the machine's file system uses fast
     // or slow symlinks, so just make sure it's not negative
-    // (Android's st_blocks is ulonglong which is always non-negative.)
     assert!(stats.st_blocks >= 0);
 }
 
 #[test]
-#[cfg(not(any(target_os = "netbsd")))]
+#[cfg(not(any(target_os = "netbsd", target_os = "redox")))]
 fn test_stat_and_fstat() {
     use nix::sys::stat::fstat;
 
@@ -92,7 +96,7 @@ fn test_stat_and_fstat() {
 }
 
 #[test]
-#[cfg(not(any(target_os = "netbsd")))]
+#[cfg(not(any(target_os = "netbsd", target_os = "redox")))]
 fn test_fstatat() {
     let tempdir = tempfile::tempdir().unwrap();
     let filename = tempdir.path().join("foo.txt");
@@ -108,7 +112,7 @@ fn test_fstatat() {
 }
 
 #[test]
-#[cfg(not(any(target_os = "netbsd")))]
+#[cfg(not(any(target_os = "netbsd", target_os = "redox")))]
 fn test_stat_fstat_lstat() {
     use nix::sys::stat::{fstat, lstat};
 
@@ -144,19 +148,20 @@ fn test_fchmod() {
     fchmod(file.as_raw_fd(), mode1).unwrap();
 
     let file_stat1 = stat(&filename).unwrap();
-    assert_eq!(file_stat1.st_mode & 0o7777, mode1.bits());
+    assert_eq!(file_stat1.st_mode as mode_t & 0o7777, mode1.bits());
 
     let mut mode2 = Mode::empty();
     mode2.insert(Mode::S_IROTH);
     fchmod(file.as_raw_fd(), mode2).unwrap();
 
     let file_stat2 = stat(&filename).unwrap();
-    assert_eq!(file_stat2.st_mode & 0o7777, mode2.bits());
+    assert_eq!(file_stat2.st_mode as mode_t & 0o7777, mode2.bits());
 }
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_fchmodat() {
-    let _dr = ::DirRestore::new();
+    let _dr = crate::DirRestore::new();
     let tempdir = tempfile::tempdir().unwrap();
     let filename = "foo.txt";
     let fullpath = tempdir.path().join(filename);
@@ -170,7 +175,7 @@ fn test_fchmodat() {
     fchmodat(Some(dirfd), filename, mode1, FchmodatFlags::FollowSymlink).unwrap();
 
     let file_stat1 = stat(&fullpath).unwrap();
-    assert_eq!(file_stat1.st_mode & 0o7777, mode1.bits());
+    assert_eq!(file_stat1.st_mode as mode_t & 0o7777, mode1.bits());
 
     chdir(tempdir.path()).unwrap();
 
@@ -179,13 +184,14 @@ fn test_fchmodat() {
     fchmodat(None, filename, mode2, FchmodatFlags::FollowSymlink).unwrap();
 
     let file_stat2 = stat(&fullpath).unwrap();
-    assert_eq!(file_stat2.st_mode & 0o7777, mode2.bits());
+    assert_eq!(file_stat2.st_mode as mode_t & 0o7777, mode2.bits());
 }
 
 /// Asserts that the atime and mtime in a file's metadata match expected values.
 ///
 /// The atime and mtime are expressed with a resolution of seconds because some file systems
 /// (like macOS's HFS+) do not have higher granularity.
+#[cfg(not(target_os = "redox"))]
 fn assert_times_eq(exp_atime_sec: u64, exp_mtime_sec: u64, attr: &fs::Metadata) {
     assert_eq!(
         Duration::new(exp_atime_sec, 0),
@@ -196,6 +202,7 @@ fn assert_times_eq(exp_atime_sec: u64, exp_mtime_sec: u64, attr: &fs::Metadata)
 }
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_utimes() {
     let tempdir = tempfile::tempdir().unwrap();
     let fullpath = tempdir.path().join("file");
@@ -231,6 +238,7 @@ fn test_lutimes() {
 }
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_futimens() {
     let tempdir = tempfile::tempdir().unwrap();
     let fullpath = tempdir.path().join("file");
@@ -243,8 +251,9 @@ fn test_futimens() {
 }
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_utimensat() {
-    let _dr = ::DirRestore::new();
+    let _dr = crate::DirRestore::new();
     let tempdir = tempfile::tempdir().unwrap();
     let filename = "foo.txt";
     let fullpath = tempdir.path().join(filename);
@@ -264,6 +273,7 @@ fn test_utimensat() {
 }
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_mkdirat_success_path() {
     let tempdir = tempfile::tempdir().unwrap();
     let filename = "example_subdir";
@@ -273,6 +283,7 @@ fn test_mkdirat_success_path() {
 }
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_mkdirat_success_mode() {
     let expected_bits = stat::SFlag::S_IFDIR.bits() | stat::Mode::S_IRWXU.bits();
     let tempdir = tempfile::tempdir().unwrap();
@@ -285,6 +296,7 @@ fn test_mkdirat_success_mode() {
 }
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_mkdirat_fail() {
     let tempdir = tempfile::tempdir().unwrap();
     let not_dir_filename= "example_not_dir";
@@ -292,5 +304,55 @@ fn test_mkdirat_fail() {
     let dirfd = fcntl::open(&tempdir.path().join(not_dir_filename), fcntl::OFlag::O_CREAT,
                             stat::Mode::empty()).unwrap();
     let result = mkdirat(dirfd, filename, Mode::S_IRWXU).unwrap_err();
-    assert_eq!(result, Error::Sys(Errno::ENOTDIR));
+    assert_eq!(result, Errno::ENOTDIR);
+}
+
+#[test]
+#[cfg(not(any(target_os = "freebsd",
+              target_os = "ios",
+              target_os = "macos",
+              target_os = "redox")))]
+fn test_mknod() {
+    use stat::{lstat, mknod, SFlag};
+
+    let file_name = "test_file";
+    let tempdir = tempfile::tempdir().unwrap();
+    let target = tempdir.path().join(file_name);
+    mknod(&target, SFlag::S_IFREG, Mode::S_IRWXU, 0).unwrap();
+    let mode = lstat(&target).unwrap().st_mode as mode_t;
+    assert!(mode & libc::S_IFREG == libc::S_IFREG);
+    assert!(mode & libc::S_IRWXU == libc::S_IRWXU);
+}
+
+#[test]
+#[cfg(not(any(target_os = "freebsd",
+              target_os = "illumos",
+              target_os = "ios",
+              target_os = "macos",
+              target_os = "redox")))]
+fn test_mknodat() {
+    use fcntl::{AtFlags, OFlag};
+    use nix::dir::Dir;
+    use stat::{fstatat, mknodat, SFlag};
+
+    let file_name = "test_file";
+    let tempdir = tempfile::tempdir().unwrap();
+    let target_dir = Dir::open(tempdir.path(), OFlag::O_DIRECTORY, Mode::S_IRWXU).unwrap();
+    mknodat(
+        target_dir.as_raw_fd(),
+        file_name,
+        SFlag::S_IFREG,
+        Mode::S_IRWXU,
+        0,
+    )
+    .unwrap();
+    let mode = fstatat(
+        target_dir.as_raw_fd(),
+        file_name,
+        AtFlags::AT_SYMLINK_NOFOLLOW,
+    )
+    .unwrap()
+    .st_mode as mode_t;
+    assert!(mode & libc::S_IFREG == libc::S_IFREG);
+    assert!(mode & libc::S_IRWXU == libc::S_IRWXU);
 }
diff --git a/third_party/rust/nix/test/test_time.rs b/third_party/rust/nix/test/test_time.rs
new file mode 100644
index 0000000000000..dc307e57b3abf
--- /dev/null
+++ b/third_party/rust/nix/test/test_time.rs
@@ -0,0 +1,58 @@
+#[cfg(any(
+    target_os = "freebsd",
+    target_os = "dragonfly",
+    target_os = "linux",
+    target_os = "android",
+    target_os = "emscripten",
+))]
+use nix::time::clock_getcpuclockid;
+use nix::time::{clock_gettime, ClockId};
+
+#[cfg(not(target_os = "redox"))]
+#[test]
+pub fn test_clock_getres() {
+    assert!(nix::time::clock_getres(ClockId::CLOCK_REALTIME).is_ok());
+}
+
+#[test]
+pub fn test_clock_gettime() {
+    assert!(clock_gettime(ClockId::CLOCK_REALTIME).is_ok());
+}
+
+#[cfg(any(
+    target_os = "freebsd",
+    target_os = "dragonfly",
+    target_os = "linux",
+    target_os = "android",
+    target_os = "emscripten",
+))]
+#[test]
+pub fn test_clock_getcpuclockid() {
+    let clock_id = clock_getcpuclockid(nix::unistd::Pid::this()).unwrap();
+    assert!(clock_gettime(clock_id).is_ok());
+}
+
+#[cfg(not(target_os = "redox"))]
+#[test]
+pub fn test_clock_id_res() {
+    assert!(ClockId::CLOCK_REALTIME.res().is_ok());
+}
+
+#[test]
+pub fn test_clock_id_now() {
+    assert!(ClockId::CLOCK_REALTIME.now().is_ok());
+}
+
+#[cfg(any(
+    target_os = "freebsd",
+    target_os = "dragonfly",
+    target_os = "linux",
+    target_os = "android",
+    target_os = "emscripten",
+))]
+#[test]
+pub fn test_clock_id_pid_cpu_clock_id() {
+    assert!(ClockId::pid_cpu_clock_id(nix::unistd::Pid::this())
+        .map(ClockId::now)
+        .is_ok());
+}
diff --git a/third_party/rust/nix/test/test_unistd.rs b/third_party/rust/nix/test/test_unistd.rs
index 46196dec7ccce..61062ad229988 100644
--- a/third_party/rust/nix/test/test_unistd.rs
+++ b/third_party/rust/nix/test/test_unistd.rs
@@ -1,26 +1,37 @@
-use nix::fcntl::{self, fcntl, FcntlArg, FdFlag, open, OFlag, readlink};
+#[cfg(not(target_os = "redox"))]
+use nix::fcntl::{self, open, readlink};
+use nix::fcntl::OFlag;
 use nix::unistd::*;
 use nix::unistd::ForkResult::*;
+#[cfg(not(target_os = "redox"))]
 use nix::sys::signal::{SaFlags, SigAction, SigHandler, SigSet, Signal, sigaction};
 use nix::sys::wait::*;
 use nix::sys::stat::{self, Mode, SFlag};
+#[cfg(not(any(target_os = "redox", target_os = "fuchsia")))]
+use nix::pty::{posix_openpt, grantpt, unlockpt, ptsname};
 use nix::errno::Errno;
-use nix::Error;
-use std::{env, iter};
+use std::env;
+#[cfg(not(any(target_os = "fuchsia", target_os = "redox")))]
 use std::ffi::CString;
-use std::fs::{self, DirBuilder, File};
+#[cfg(not(target_os = "redox"))]
+use std::fs::DirBuilder;
+use std::fs::{self, File};
 use std::io::Write;
 use std::os::unix::prelude::*;
-use tempfile::{self, tempfile};
-use libc::{self, _exit, off_t};
+#[cfg(not(any(target_os = "fuchsia", target_os = "redox")))]
+use std::path::Path;
+use tempfile::{tempdir, tempfile};
+use libc::{_exit, mode_t, off_t};
+
+use crate::*;
 
 #[test]
 #[cfg(not(any(target_os = "netbsd")))]
 fn test_fork_and_waitpid() {
-    let _m = ::FORK_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::FORK_MTX.lock();
 
     // Safe: Child only calls `_exit`, which is signal-safe
-    match fork().expect("Error: Fork Failed") {
+    match unsafe{fork()}.expect("Error: Fork Failed") {
         Child => unsafe { _exit(0) },
         Parent { child } => {
             // assert that child was created and pid > 0
@@ -29,7 +40,7 @@ fn test_fork_and_waitpid() {
             let wait_status = waitpid(child, None);
             match wait_status {
                 // assert that waitpid returned correct status and the pid is the one of the child
-                Ok(WaitStatus::Exited(pid_t, _)) =>  assert!(pid_t == child),
+                Ok(WaitStatus::Exited(pid_t, _)) =>  assert_eq!(pid_t, child),
 
                 // panic, must never happen
                 s @ Ok(_) => panic!("Child exited {:?}, should never happen", s),
@@ -45,10 +56,10 @@ fn test_fork_and_waitpid() {
 #[test]
 fn test_wait() {
     // Grab FORK_MTX so wait doesn't reap a different test's child process
-    let _m = ::FORK_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::FORK_MTX.lock();
 
     // Safe: Child only calls `_exit`, which is signal-safe
-    match fork().expect("Error: Fork Failed") {
+    match unsafe{fork()}.expect("Error: Fork Failed") {
         Child => unsafe { _exit(0) },
         Parent { child } => {
             let wait_status = wait();
@@ -81,23 +92,85 @@ fn test_mkstemp_directory() {
 }
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_mkfifo() {
-    let tempdir = tempfile::tempdir().unwrap();
+    let tempdir = tempdir().unwrap();
     let mkfifo_fifo = tempdir.path().join("mkfifo_fifo");
 
     mkfifo(&mkfifo_fifo, Mode::S_IRUSR).unwrap();
 
     let stats = stat::stat(&mkfifo_fifo).unwrap();
-    let typ = stat::SFlag::from_bits_truncate(stats.st_mode);
+    let typ = stat::SFlag::from_bits_truncate(stats.st_mode as mode_t);
     assert!(typ == SFlag::S_IFIFO);
 }
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_mkfifo_directory() {
     // mkfifo should fail if a directory is given
     assert!(mkfifo(&env::temp_dir(), Mode::S_IRUSR).is_err());
 }
 
+#[test]
+#[cfg(not(any(
+    target_os = "macos", target_os = "ios",
+    target_os = "android", target_os = "redox")))]
+fn test_mkfifoat_none() {
+    let _m = crate::CWD_LOCK.read();
+
+    let tempdir = tempdir().unwrap();
+    let mkfifoat_fifo = tempdir.path().join("mkfifoat_fifo");
+
+    mkfifoat(None, &mkfifoat_fifo, Mode::S_IRUSR).unwrap();
+
+    let stats = stat::stat(&mkfifoat_fifo).unwrap();
+    let typ = stat::SFlag::from_bits_truncate(stats.st_mode);
+    assert_eq!(typ, SFlag::S_IFIFO);
+}
+
+#[test]
+#[cfg(not(any(
+    target_os = "macos", target_os = "ios",
+    target_os = "android", target_os = "redox")))]
+fn test_mkfifoat() {
+    use nix::fcntl;
+
+    let tempdir = tempdir().unwrap();
+    let dirfd = open(tempdir.path(), OFlag::empty(), Mode::empty()).unwrap();
+    let mkfifoat_name = "mkfifoat_name";
+
+    mkfifoat(Some(dirfd), mkfifoat_name, Mode::S_IRUSR).unwrap();
+
+    let stats = stat::fstatat(dirfd, mkfifoat_name, fcntl::AtFlags::empty()).unwrap();
+    let typ = stat::SFlag::from_bits_truncate(stats.st_mode);
+    assert_eq!(typ, SFlag::S_IFIFO);
+}
+
+#[test]
+#[cfg(not(any(
+    target_os = "macos", target_os = "ios",
+    target_os = "android", target_os = "redox")))]
+fn test_mkfifoat_directory_none() {
+    let _m = crate::CWD_LOCK.read();
+
+    // mkfifoat should fail if a directory is given
+    assert!(mkfifoat(None, &env::temp_dir(), Mode::S_IRUSR).is_err());
+}
+
+#[test]
+#[cfg(not(any(
+    target_os = "macos", target_os = "ios",
+    target_os = "android", target_os = "redox")))]
+fn test_mkfifoat_directory() {
+    // mkfifoat should fail if a directory is given
+    let tempdir = tempdir().unwrap();
+    let dirfd = open(tempdir.path(), OFlag::empty(), Mode::empty()).unwrap();
+    let mkfifoat_dir = "mkfifoat_dir";
+    stat::mkdirat(dirfd, mkfifoat_dir, Mode::S_IRUSR).unwrap();
+
+    assert!(mkfifoat(Some(dirfd), mkfifoat_dir, Mode::S_IRUSR).is_err());
+}
+
 #[test]
 fn test_getpid() {
     let pid: ::libc::pid_t = getpid().into();
@@ -107,11 +180,12 @@ fn test_getpid() {
 }
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_getsid() {
     let none_sid: ::libc::pid_t = getsid(None).unwrap().into();
     let pid_sid: ::libc::pid_t = getsid(Some(getpid())).unwrap().into();
     assert!(none_sid > 0);
-    assert!(none_sid == pid_sid);
+    assert_eq!(none_sid, pid_sid);
 }
 
 #[cfg(any(target_os = "linux", target_os = "android"))]
@@ -127,12 +201,12 @@ mod linux_android {
 
 #[test]
 // `getgroups()` and `setgroups()` do not behave as expected on Apple platforms
-#[cfg(not(any(target_os = "ios", target_os = "macos")))]
+#[cfg(not(any(target_os = "ios", target_os = "macos", target_os = "redox", target_os = "fuchsia")))]
 fn test_setgroups() {
     // Skip this test when not run as root as `setgroups()` requires root.
     skip_if_not_root!("test_setgroups");
 
-    let _m = ::GROUPS_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::GROUPS_MTX.lock();
 
     // Save the existing groups
     let old_groups = getgroups().unwrap();
@@ -150,13 +224,17 @@ fn test_setgroups() {
 
 #[test]
 // `getgroups()` and `setgroups()` do not behave as expected on Apple platforms
-#[cfg(not(any(target_os = "ios", target_os = "macos")))]
+#[cfg(not(any(target_os = "ios",
+              target_os = "macos",
+              target_os = "redox",
+              target_os = "fuchsia",
+              target_os = "illumos")))]
 fn test_initgroups() {
     // Skip this test when not run as root as `initgroups()` and `setgroups()`
     // require root.
     skip_if_not_root!("test_initgroups");
 
-    let _m = ::GROUPS_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::GROUPS_MTX.lock();
 
     // Save the existing groups
     let old_groups = getgroups().unwrap();
@@ -180,11 +258,53 @@ fn test_initgroups() {
     setgroups(&old_groups).unwrap();
 }
 
+#[cfg(not(any(target_os = "fuchsia", target_os = "redox")))]
 macro_rules! execve_test_factory(
     ($test_name:ident, $syscall:ident, $exe: expr $(, $pathname:expr, $flags:expr)*) => (
-    #[test]
-    fn $test_name() {
-        let _m = ::FORK_MTX.lock().expect("Mutex got poisoned by another test");
+
+    #[cfg(test)]
+    mod $test_name {
+    use std::ffi::CStr;
+    use super::*;
+
+    const EMPTY: &'static [u8] = b"\0";
+    const DASH_C: &'static [u8] = b"-c\0";
+    const BIGARG: &'static [u8] = b"echo nix!!! && echo foo=$foo && echo baz=$baz\0";
+    const FOO: &'static [u8] = b"foo=bar\0";
+    const BAZ: &'static [u8] = b"baz=quux\0";
+
+    fn syscall_cstr_ref() -> Result<std::convert::Infallible, nix::Error> {
+        $syscall(
+            $exe,
+            $(CString::new($pathname).unwrap().as_c_str(), )*
+            &[CStr::from_bytes_with_nul(EMPTY).unwrap(),
+              CStr::from_bytes_with_nul(DASH_C).unwrap(),
+              CStr::from_bytes_with_nul(BIGARG).unwrap()],
+            &[CStr::from_bytes_with_nul(FOO).unwrap(),
+              CStr::from_bytes_with_nul(BAZ).unwrap()]
+            $(, $flags)*)
+    }
+
+    fn syscall_cstring() -> Result<std::convert::Infallible, nix::Error> {
+        $syscall(
+            $exe,
+            $(CString::new($pathname).unwrap().as_c_str(), )*
+            &[CString::from(CStr::from_bytes_with_nul(EMPTY).unwrap()),
+              CString::from(CStr::from_bytes_with_nul(DASH_C).unwrap()),
+              CString::from(CStr::from_bytes_with_nul(BIGARG).unwrap())],
+            &[CString::from(CStr::from_bytes_with_nul(FOO).unwrap()),
+              CString::from(CStr::from_bytes_with_nul(BAZ).unwrap())]
+            $(, $flags)*)
+    }
+
+    fn common_test(syscall: fn() -> Result<std::convert::Infallible, nix::Error>) {
+        if "execveat" == stringify!($syscall) {
+            // Though undocumented, Docker's default seccomp profile seems to
+            // block this syscall.  https://github.com/nix-rust/nix/issues/1122
+            skip_if_seccomp!($test_name);
+        }
+
+        let m = crate::FORK_MTX.lock();
         // The `exec`d process will write to `writer`, and we'll read that
         // data from `reader`.
         let (reader, writer) = pipe().unwrap();
@@ -192,27 +312,21 @@ macro_rules! execve_test_factory(
         // Safe: Child calls `exit`, `dup`, `close` and the provided `exec*` family function.
         // NOTE: Technically, this makes the macro unsafe to use because you could pass anything.
         //       The tests make sure not to do that, though.
-        match fork().unwrap() {
+        match unsafe{fork()}.unwrap() {
             Child => {
-                // Close stdout.
-                close(1).unwrap();
                 // Make `writer` be the stdout of the new process.
-                dup(writer).unwrap();
-                // exec!
-                $syscall(
-                    $exe,
-                    $(&CString::new($pathname).unwrap(), )*
-                    &[CString::new(b"".as_ref()).unwrap(),
-                      CString::new(b"-c".as_ref()).unwrap(),
-                      CString::new(b"echo nix!!! && echo foo=$foo && echo baz=$baz"
-                                   .as_ref()).unwrap()],
-                    &[CString::new(b"foo=bar".as_ref()).unwrap(),
-                      CString::new(b"baz=quux".as_ref()).unwrap()]
-                    $(, $flags)*).unwrap();
+                dup2(writer, 1).unwrap();
+                let r = syscall();
+                let _ = std::io::stderr()
+                    .write_all(format!("{:?}", r).as_bytes());
+                // Should only get here in event of error
+                unsafe{ _exit(1) };
             },
             Parent { child } => {
                 // Wait for the child to exit.
-                waitpid(child, None).unwrap();
+                let ws = waitpid(child, None);
+                drop(m);
+                assert_eq!(ws, Ok(WaitStatus::Exited(child, 0)));
                 // Read 1024 bytes.
                 let mut buf = [0u8; 1024];
                 read(reader, &mut buf).unwrap();
@@ -224,23 +338,45 @@ macro_rules! execve_test_factory(
             }
         }
     }
+
+    // These tests frequently fail on musl, probably due to
+        // https://github.com/nix-rust/nix/issues/555
+    #[cfg_attr(target_env = "musl", ignore)]
+    #[test]
+    fn test_cstr_ref() {
+        common_test(syscall_cstr_ref);
+    }
+
+    // These tests frequently fail on musl, probably due to
+        // https://github.com/nix-rust/nix/issues/555
+    #[cfg_attr(target_env = "musl", ignore)]
+    #[test]
+    fn test_cstring() {
+        common_test(syscall_cstring);
+    }
+    }
+
     )
 );
 
 cfg_if!{
     if #[cfg(target_os = "android")] {
-        execve_test_factory!(test_execve, execve, &CString::new("/system/bin/sh").unwrap());
+        execve_test_factory!(test_execve, execve, CString::new("/system/bin/sh").unwrap().as_c_str());
         execve_test_factory!(test_fexecve, fexecve, File::open("/system/bin/sh").unwrap().into_raw_fd());
     } else if #[cfg(any(target_os = "freebsd",
                         target_os = "linux"))] {
-        execve_test_factory!(test_execve, execve, &CString::new("/bin/sh").unwrap());
+        // These tests frequently fail on musl, probably due to
+        // https://github.com/nix-rust/nix/issues/555
+        execve_test_factory!(test_execve, execve, CString::new("/bin/sh").unwrap().as_c_str());
         execve_test_factory!(test_fexecve, fexecve, File::open("/bin/sh").unwrap().into_raw_fd());
     } else if #[cfg(any(target_os = "dragonfly",
+                        target_os = "illumos",
                         target_os = "ios",
                         target_os = "macos",
                         target_os = "netbsd",
-                        target_os = "openbsd"))] {
-        execve_test_factory!(test_execve, execve, &CString::new("/bin/sh").unwrap());
+                        target_os = "openbsd",
+                        target_os = "solaris"))] {
+        execve_test_factory!(test_execve, execve, CString::new("/bin/sh").unwrap().as_c_str());
         // No fexecve() on DragonFly, ios, macos, NetBSD, OpenBSD.
         //
         // Note for NetBSD and OpenBSD: although rust-lang/libc includes it
@@ -255,13 +391,16 @@ execve_test_factory!(test_execvpe, execvpe, &CString::new("sh").unwrap());
 cfg_if!{
     if #[cfg(target_os = "android")] {
         use nix::fcntl::AtFlags;
-        execve_test_factory!(test_execveat_empty, execveat, File::open("/system/bin/sh").unwrap().into_raw_fd(),
+        execve_test_factory!(test_execveat_empty, execveat,
+                             File::open("/system/bin/sh").unwrap().into_raw_fd(),
                              "", AtFlags::AT_EMPTY_PATH);
-        execve_test_factory!(test_execveat_relative, execveat, File::open("/system/bin/").unwrap().into_raw_fd(),
+        execve_test_factory!(test_execveat_relative, execveat,
+                             File::open("/system/bin/").unwrap().into_raw_fd(),
                              "./sh", AtFlags::empty());
-        execve_test_factory!(test_execveat_absolute, execveat, File::open("/").unwrap().into_raw_fd(),
+        execve_test_factory!(test_execveat_absolute, execveat,
+                             File::open("/").unwrap().into_raw_fd(),
                              "/system/bin/sh", AtFlags::empty());
-    } else if #[cfg(all(target_os = "linux"), any(target_arch ="x86_64", target_arch ="x86"))] {
+    } else if #[cfg(all(target_os = "linux", any(target_arch ="x86_64", target_arch ="x86")))] {
         use nix::fcntl::AtFlags;
         execve_test_factory!(test_execveat_empty, execveat, File::open("/bin/sh").unwrap().into_raw_fd(),
                              "", AtFlags::AT_EMPTY_PATH);
@@ -273,11 +412,12 @@ cfg_if!{
 }
 
 #[test]
+#[cfg(not(target_os = "fuchsia"))]
 fn test_fchdir() {
     // fchdir changes the process's cwd
-    let _dr = ::DirRestore::new();
+    let _dr = crate::DirRestore::new();
 
-    let tmpdir = tempfile::tempdir().unwrap();
+    let tmpdir = tempdir().unwrap();
     let tmpdir_path = tmpdir.path().canonicalize().unwrap();
     let tmpdir_fd = File::open(&tmpdir_path).unwrap().into_raw_fd();
 
@@ -290,9 +430,9 @@ fn test_fchdir() {
 #[test]
 fn test_getcwd() {
     // chdir changes the process's cwd
-    let _dr = ::DirRestore::new();
+    let _dr = crate::DirRestore::new();
 
-    let tmpdir = tempfile::tempdir().unwrap();
+    let tmpdir = tempdir().unwrap();
     let tmpdir_path = tmpdir.path().canonicalize().unwrap();
     assert!(chdir(&tmpdir_path).is_ok());
     assert_eq!(getcwd().unwrap(), tmpdir_path);
@@ -301,9 +441,9 @@ fn test_getcwd() {
     // kicks in.  Note: One path cannot be longer than 255 bytes
     // (NAME_MAX) whole path cannot be longer than PATH_MAX (usually
     // 4096 on linux, 1024 on macos)
-    let mut inner_tmp_dir = tmpdir_path.to_path_buf();
+    let mut inner_tmp_dir = tmpdir_path;
     for _ in 0..5 {
-        let newdir = iter::repeat("a").take(100).collect::<String>();
+        let newdir = "a".repeat(100);
         inner_tmp_dir.push(newdir);
         assert!(mkdir(inner_tmp_dir.as_path(), Mode::S_IRWXU).is_ok());
     }
@@ -317,7 +457,7 @@ fn test_chown() {
     let uid = Some(getuid());
     let gid = Some(getgid());
 
-    let tempdir = tempfile::tempdir().unwrap();
+    let tempdir = tempdir().unwrap();
     let path = tempdir.path().join("file");
     {
         File::create(&path).unwrap();
@@ -332,13 +472,29 @@ fn test_chown() {
 }
 
 #[test]
+fn test_fchown() {
+    // Testing for anything other than our own UID/GID is hard.
+    let uid = Some(getuid());
+    let gid = Some(getgid());
+
+    let path = tempfile().unwrap();
+    let fd = path.as_raw_fd();
+
+    fchown(fd, uid, gid).unwrap();
+    fchown(fd, uid, None).unwrap();
+    fchown(fd, None, gid).unwrap();
+    fchown(999999999, uid, gid).unwrap_err();
+}
+
+#[test]
+#[cfg(not(target_os = "redox"))]
 fn test_fchownat() {
-    let _dr = ::DirRestore::new();
+    let _dr = crate::DirRestore::new();
     // Testing for anything other than our own UID/GID is hard.
     let uid = Some(getuid());
     let gid = Some(getgid());
 
-    let tempdir = tempfile::tempdir().unwrap();
+    let tempdir = tempdir().unwrap();
     let path = tempdir.path().join("file");
     {
         File::create(&path).unwrap();
@@ -366,7 +522,7 @@ fn test_lseek() {
     lseek(tmpfd, offset, Whence::SeekSet).unwrap();
 
     let mut buf = [0u8; 7];
-    ::read_exact(tmpfd, &mut buf);
+    crate::read_exact(tmpfd, &mut buf);
     assert_eq!(b"f123456", &buf);
 
     close(tmpfd).unwrap();
@@ -383,7 +539,7 @@ fn test_lseek64() {
     lseek64(tmpfd, 5, Whence::SeekSet).unwrap();
 
     let mut buf = [0u8; 7];
-    ::read_exact(tmpfd, &mut buf);
+    crate::read_exact(tmpfd, &mut buf);
     assert_eq!(b"f123456", &buf);
 
     close(tmpfd).unwrap();
@@ -393,7 +549,7 @@ cfg_if!{
     if #[cfg(any(target_os = "android", target_os = "linux"))] {
         macro_rules! require_acct{
             () => {
-                require_capability!(CAP_SYS_PACCT);
+                require_capability!("test_acct", CAP_SYS_PACCT);
             }
         }
     } else if #[cfg(target_os = "freebsd")] {
@@ -403,7 +559,7 @@ cfg_if!{
                 skip_if_jailed!("test_acct");
             }
         }
-    } else {
+    } else if #[cfg(not(any(target_os = "redox", target_os = "fuchsia")))] {
         macro_rules! require_acct{
             () => {
                 skip_if_not_root!("test_acct");
@@ -413,12 +569,13 @@ cfg_if!{
 }
 
 #[test]
+#[cfg(not(any(target_os = "redox", target_os = "fuchsia")))]
 fn test_acct() {
     use tempfile::NamedTempFile;
     use std::process::Command;
     use std::{thread, time};
 
-    let _m = ::FORK_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::FORK_MTX.lock();
     require_acct!();
 
     let file = NamedTempFile::new().unwrap();
@@ -467,22 +624,53 @@ fn test_sysconf_unsupported() {
     assert!(open_max.expect("sysconf failed").is_none())
 }
 
+
+#[cfg(any(target_os = "android", target_os = "linux"))]
+#[test]
+fn test_getresuid() {
+    let resuids = getresuid().unwrap();
+    assert!(resuids.real.as_raw() != libc::uid_t::max_value());
+    assert!(resuids.effective.as_raw() != libc::uid_t::max_value());
+    assert!(resuids.saved.as_raw() != libc::uid_t::max_value());
+}
+
+#[cfg(any(target_os = "android", target_os = "linux"))]
+#[test]
+fn test_getresgid() {
+    let resgids = getresgid().unwrap();
+    assert!(resgids.real.as_raw() != libc::gid_t::max_value());
+    assert!(resgids.effective.as_raw() != libc::gid_t::max_value());
+    assert!(resgids.saved.as_raw() != libc::gid_t::max_value());
+}
+
 // Test that we can create a pair of pipes.  No need to verify that they pass
 // data; that's the domain of the OS, not nix.
 #[test]
 fn test_pipe() {
     let (fd0, fd1) = pipe().unwrap();
-    let m0 = stat::SFlag::from_bits_truncate(stat::fstat(fd0).unwrap().st_mode);
+    let m0 = stat::SFlag::from_bits_truncate(stat::fstat(fd0).unwrap().st_mode as mode_t);
     // S_IFIFO means it's a pipe
     assert_eq!(m0, SFlag::S_IFIFO);
-    let m1 = stat::SFlag::from_bits_truncate(stat::fstat(fd1).unwrap().st_mode);
+    let m1 = stat::SFlag::from_bits_truncate(stat::fstat(fd1).unwrap().st_mode as mode_t);
     assert_eq!(m1, SFlag::S_IFIFO);
 }
 
 // pipe2(2) is the same as pipe(2), except it allows setting some flags.  Check
 // that we can set a flag.
+#[cfg(any(target_os = "android",
+          target_os = "dragonfly",
+          target_os = "emscripten",
+          target_os = "freebsd",
+          target_os = "illumos",
+          target_os = "linux",
+          target_os = "netbsd",
+          target_os = "openbsd",
+          target_os = "redox",
+          target_os = "solaris"))]
 #[test]
 fn test_pipe2() {
+    use nix::fcntl::{fcntl, FcntlArg, FdFlag};
+
     let (fd0, fd1) = pipe2(OFlag::O_CLOEXEC).unwrap();
     let f0 = FdFlag::from_bits_truncate(fcntl(fd0, FcntlArg::F_GETFD).unwrap());
     assert!(f0.contains(FdFlag::FD_CLOEXEC));
@@ -491,8 +679,9 @@ fn test_pipe2() {
 }
 
 #[test]
+#[cfg(not(any(target_os = "redox", target_os = "fuchsia")))]
 fn test_truncate() {
-    let tempdir = tempfile::tempdir().unwrap();
+    let tempdir = tempdir().unwrap();
     let path = tempdir.path().join("file");
 
     {
@@ -509,7 +698,7 @@ fn test_truncate() {
 
 #[test]
 fn test_ftruncate() {
-    let tempdir = tempfile::tempdir().unwrap();
+    let tempdir = tempdir().unwrap();
     let path = tempdir.path().join("file");
 
     let tmpfd = {
@@ -527,17 +716,26 @@ fn test_ftruncate() {
 }
 
 // Used in `test_alarm`.
+#[cfg(not(target_os = "redox"))]
 static mut ALARM_CALLED: bool = false;
 
 // Used in `test_alarm`.
+#[cfg(not(target_os = "redox"))]
 pub extern fn alarm_signal_handler(raw_signal: libc::c_int) {
     assert_eq!(raw_signal, libc::SIGALRM, "unexpected signal: {}", raw_signal);
     unsafe { ALARM_CALLED = true };
 }
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_alarm() {
-    let _m = ::SIGNAL_MTX.lock().expect("Mutex got poisoned by another test");
+    use std::{
+        time::{Duration, Instant,},
+        thread
+    };
+
+    // Maybe other tests that fork interfere with this one?
+    let _m = crate::SIGNAL_MTX.lock();
 
     let handler = SigHandler::Handler(alarm_signal_handler);
     let signal_action = SigAction::new(handler, SaFlags::SA_RESTART, SigSet::empty());
@@ -552,10 +750,18 @@ fn test_alarm() {
     // Overwriting an alarm should return the old alarm.
     assert_eq!(alarm::set(1), Some(60));
 
-    // We should be woken up after 1 second by the alarm, so we'll sleep for 2
+    // We should be woken up after 1 second by the alarm, so we'll sleep for 3
     // seconds to be sure.
-    sleep(2);
-    assert_eq!(unsafe { ALARM_CALLED }, true, "expected our alarm signal handler to be called");
+    let starttime = Instant::now();
+    loop {
+        thread::sleep(Duration::from_millis(100));
+        if unsafe { ALARM_CALLED} {
+            break;
+        }
+        if starttime.elapsed() > Duration::from_secs(3) {
+            panic!("Timeout waiting for SIGALRM");
+        }
+    }
 
     // Reset the signal.
     unsafe {
@@ -565,8 +771,9 @@ fn test_alarm() {
 }
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_canceling_alarm() {
-    let _m = ::SIGNAL_MTX.lock().expect("Mutex got poisoned by another test");
+    let _m = crate::SIGNAL_MTX.lock();
 
     assert_eq!(alarm::cancel(), None);
 
@@ -575,15 +782,17 @@ fn test_canceling_alarm() {
 }
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_symlinkat() {
-    let mut buf = [0; 1024];
-    let tempdir = tempfile::tempdir().unwrap();
+    let _m = crate::CWD_LOCK.read();
+
+    let tempdir = tempdir().unwrap();
 
     let target = tempdir.path().join("a");
     let linkpath = tempdir.path().join("b");
     symlinkat(&target, None, &linkpath).unwrap();
     assert_eq!(
-        readlink(&linkpath, &mut buf).unwrap().to_str().unwrap(),
+        readlink(&linkpath).unwrap().to_str().unwrap(),
         target.to_str().unwrap()
     );
 
@@ -592,7 +801,7 @@ fn test_symlinkat() {
     let linkpath = "d";
     symlinkat(target, Some(dirfd), linkpath).unwrap();
     assert_eq!(
-        readlink(&tempdir.path().join(linkpath), &mut buf)
+        readlink(&tempdir.path().join(linkpath))
             .unwrap()
             .to_str()
             .unwrap(),
@@ -600,10 +809,156 @@ fn test_symlinkat() {
     );
 }
 
+#[test]
+#[cfg(not(target_os = "redox"))]
+fn test_linkat_file() {
+    let tempdir = tempdir().unwrap();
+    let oldfilename = "foo.txt";
+    let oldfilepath = tempdir.path().join(oldfilename);
+
+    let newfilename = "bar.txt";
+    let newfilepath = tempdir.path().join(newfilename);
+
+    // Create file
+    File::create(&oldfilepath).unwrap();
+
+    // Get file descriptor for base directory
+    let dirfd = fcntl::open(tempdir.path(), fcntl::OFlag::empty(), stat::Mode::empty()).unwrap();
+
+    // Attempt hard link file at relative path
+    linkat(Some(dirfd), oldfilename, Some(dirfd), newfilename, LinkatFlags::SymlinkFollow).unwrap();
+    assert!(newfilepath.exists());
+}
+
+#[test]
+#[cfg(not(target_os = "redox"))]
+fn test_linkat_olddirfd_none() {
+    let _dr = crate::DirRestore::new();
+
+    let tempdir_oldfile = tempdir().unwrap();
+    let oldfilename = "foo.txt";
+    let oldfilepath = tempdir_oldfile.path().join(oldfilename);
+
+    let tempdir_newfile = tempdir().unwrap();
+    let newfilename = "bar.txt";
+    let newfilepath = tempdir_newfile.path().join(newfilename);
+
+    // Create file
+    File::create(&oldfilepath).unwrap();
+
+    // Get file descriptor for base directory of new file
+    let dirfd = fcntl::open(tempdir_newfile.path(), fcntl::OFlag::empty(), stat::Mode::empty()).unwrap();
+
+    // Attempt hard link file using curent working directory as relative path for old file path
+    chdir(tempdir_oldfile.path()).unwrap();
+    linkat(None, oldfilename, Some(dirfd), newfilename, LinkatFlags::SymlinkFollow).unwrap();
+    assert!(newfilepath.exists());
+}
+
+#[test]
+#[cfg(not(target_os = "redox"))]
+fn test_linkat_newdirfd_none() {
+    let _dr = crate::DirRestore::new();
+
+    let tempdir_oldfile = tempdir().unwrap();
+    let oldfilename = "foo.txt";
+    let oldfilepath = tempdir_oldfile.path().join(oldfilename);
+
+    let tempdir_newfile = tempdir().unwrap();
+    let newfilename = "bar.txt";
+    let newfilepath = tempdir_newfile.path().join(newfilename);
+
+    // Create file
+    File::create(&oldfilepath).unwrap();
+
+    // Get file descriptor for base directory of old file
+    let dirfd = fcntl::open(tempdir_oldfile.path(), fcntl::OFlag::empty(), stat::Mode::empty()).unwrap();
+
+    // Attempt hard link file using current working directory as relative path for new file path
+    chdir(tempdir_newfile.path()).unwrap();
+    linkat(Some(dirfd), oldfilename, None, newfilename, LinkatFlags::SymlinkFollow).unwrap();
+    assert!(newfilepath.exists());
+}
+
+#[test]
+#[cfg(not(any(target_os = "ios", target_os = "macos", target_os = "redox")))]
+fn test_linkat_no_follow_symlink() {
+    let _m = crate::CWD_LOCK.read();
+
+    let tempdir = tempdir().unwrap();
+    let oldfilename = "foo.txt";
+    let oldfilepath = tempdir.path().join(oldfilename);
+
+    let symoldfilename = "symfoo.txt";
+    let symoldfilepath = tempdir.path().join(symoldfilename);
+
+    let newfilename = "nofollowsymbar.txt";
+    let newfilepath = tempdir.path().join(newfilename);
+
+    // Create file
+    File::create(&oldfilepath).unwrap();
+
+    // Create symlink to file
+    symlinkat(&oldfilepath, None, &symoldfilepath).unwrap();
+
+    // Get file descriptor for base directory
+    let dirfd = fcntl::open(tempdir.path(), fcntl::OFlag::empty(), stat::Mode::empty()).unwrap();
+
+    // Attempt link symlink of file at relative path
+    linkat(Some(dirfd), symoldfilename, Some(dirfd), newfilename, LinkatFlags::NoSymlinkFollow).unwrap();
+
+    // Assert newfile is actually a symlink to oldfile.
+    assert_eq!(
+        readlink(&newfilepath)
+            .unwrap()
+            .to_str()
+            .unwrap(),
+        oldfilepath.to_str().unwrap()
+    );
+}
+
+#[test]
+#[cfg(not(target_os = "redox"))]
+fn test_linkat_follow_symlink() {
+    let _m = crate::CWD_LOCK.read();
+
+    let tempdir = tempdir().unwrap();
+    let oldfilename = "foo.txt";
+    let oldfilepath = tempdir.path().join(oldfilename);
+
+    let symoldfilename = "symfoo.txt";
+    let symoldfilepath = tempdir.path().join(symoldfilename);
+
+    let newfilename = "nofollowsymbar.txt";
+    let newfilepath = tempdir.path().join(newfilename);
+
+    // Create file
+    File::create(&oldfilepath).unwrap();
+
+    // Create symlink to file
+    symlinkat(&oldfilepath, None, &symoldfilepath).unwrap();
+
+    // Get file descriptor for base directory
+    let dirfd = fcntl::open(tempdir.path(), fcntl::OFlag::empty(), stat::Mode::empty()).unwrap();
+
+    // Attempt link target of symlink of file at relative path
+    linkat(Some(dirfd), symoldfilename, Some(dirfd), newfilename, LinkatFlags::SymlinkFollow).unwrap();
+
+    let newfilestat = stat::stat(&newfilepath).unwrap();
+
+    // Check the file type of the new link
+    assert_eq!((stat::SFlag::from_bits_truncate(newfilestat.st_mode as mode_t) & SFlag::S_IFMT),
+        SFlag::S_IFREG
+    );
+
+    // Check the number of hard links to the original file
+    assert_eq!(newfilestat.st_nlink, 2);
+}
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_unlinkat_dir_noremovedir() {
-    let tempdir = tempfile::tempdir().unwrap();
+    let tempdir = tempdir().unwrap();
     let dirname = "foo_dir";
     let dirpath = tempdir.path().join(dirname);
 
@@ -615,12 +970,13 @@ fn test_unlinkat_dir_noremovedir() {
 
     // Attempt unlink dir at relative path without proper flag
     let err_result = unlinkat(Some(dirfd), dirname, UnlinkatFlags::NoRemoveDir).unwrap_err();
-    assert!(err_result == Error::Sys(Errno::EISDIR) || err_result == Error::Sys(Errno::EPERM));
+    assert!(err_result == Errno::EISDIR || err_result == Errno::EPERM);
  }
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_unlinkat_dir_removedir() {
-    let tempdir = tempfile::tempdir().unwrap();
+    let tempdir = tempdir().unwrap();
     let dirname = "foo_dir";
     let dirpath = tempdir.path().join(dirname);
 
@@ -636,8 +992,9 @@ fn test_unlinkat_dir_removedir() {
  }
 
 #[test]
+#[cfg(not(target_os = "redox"))]
 fn test_unlinkat_file() {
-    let tempdir = tempfile::tempdir().unwrap();
+    let tempdir = tempdir().unwrap();
     let filename = "foo.txt";
     let filepath = tempdir.path().join(filename);
 
@@ -654,16 +1011,140 @@ fn test_unlinkat_file() {
 
 #[test]
 fn test_access_not_existing() {
-    let tempdir = tempfile::tempdir().unwrap();
+    let tempdir = tempdir().unwrap();
     let dir = tempdir.path().join("does_not_exist.txt");
-    assert_eq!(access(&dir, AccessFlags::F_OK).err().unwrap().as_errno().unwrap(),
+    assert_eq!(access(&dir, AccessFlags::F_OK).err().unwrap(),
                Errno::ENOENT);
 }
 
 #[test]
 fn test_access_file_exists() {
-    let tempdir = tempfile::tempdir().unwrap();
+    let tempdir = tempdir().unwrap();
     let path  = tempdir.path().join("does_exist.txt");
     let _file = File::create(path.clone()).unwrap();
     assert!(access(&path, AccessFlags::R_OK | AccessFlags::W_OK).is_ok());
 }
+
+#[cfg(not(target_os = "redox"))]
+#[test]
+fn test_user_into_passwd() {
+    // get the UID of the "nobody" user
+    let nobody = User::from_name("nobody").unwrap().unwrap();
+    let pwd: libc::passwd = nobody.into();
+    let _: User = (&pwd).into();
+}
+
+/// Tests setting the filesystem UID with `setfsuid`.
+#[cfg(any(target_os = "linux", target_os = "android"))]
+#[test]
+fn test_setfsuid() {
+    use std::os::unix::fs::PermissionsExt;
+    use std::{fs, io, thread};
+    require_capability!("test_setfsuid", CAP_SETUID);
+
+    // get the UID of the "nobody" user
+    let nobody = User::from_name("nobody").unwrap().unwrap();
+
+    // create a temporary file with permissions '-rw-r-----'
+    let file = tempfile::NamedTempFile::new_in("/var/tmp").unwrap();
+    let temp_path = file.into_temp_path();
+    dbg!(&temp_path);
+    let temp_path_2 = (&temp_path).to_path_buf();
+    let mut permissions = fs::metadata(&temp_path).unwrap().permissions();
+    permissions.set_mode(0o640);
+
+    // spawn a new thread where to test setfsuid
+    thread::spawn(move || {
+        // set filesystem UID
+        let fuid = setfsuid(nobody.uid);
+        // trying to open the temporary file should fail with EACCES
+        let res = fs::File::open(&temp_path);
+        assert!(res.is_err());
+        assert_eq!(res.err().unwrap().kind(), io::ErrorKind::PermissionDenied);
+
+        // assert fuid actually changes
+        let prev_fuid = setfsuid(Uid::from_raw(-1i32 as u32));
+        assert_ne!(prev_fuid, fuid);
+    })
+    .join()
+    .unwrap();
+
+    // open the temporary file with the current thread filesystem UID
+    fs::File::open(temp_path_2).unwrap();
+}
+
+#[test]
+#[cfg(not(any(target_os = "redox", target_os = "fuchsia")))]
+fn test_ttyname() {
+    let fd = posix_openpt(OFlag::O_RDWR).expect("posix_openpt failed");
+    assert!(fd.as_raw_fd() > 0);
+
+    // on linux, we can just call ttyname on the pty master directly, but
+    // apparently osx requires that ttyname is called on a slave pty (can't
+    // find this documented anywhere, but it seems to empirically be the case)
+    grantpt(&fd).expect("grantpt failed");
+    unlockpt(&fd).expect("unlockpt failed");
+    let sname = unsafe { ptsname(&fd) }.expect("ptsname failed");
+    let fds = open(
+        Path::new(&sname),
+        OFlag::O_RDWR,
+        stat::Mode::empty(),
+    ).expect("open failed");
+    assert!(fds > 0);
+
+    let name = ttyname(fds).expect("ttyname failed");
+    assert!(name.starts_with("/dev"));
+}
+
+#[test]
+#[cfg(not(any(target_os = "redox", target_os = "fuchsia")))]
+fn test_ttyname_not_pty() {
+    let fd = File::open("/dev/zero").unwrap();
+    assert!(fd.as_raw_fd() > 0);
+    assert_eq!(ttyname(fd.as_raw_fd()), Err(Errno::ENOTTY));
+}
+
+#[test]
+#[cfg(not(any(target_os = "redox", target_os = "fuchsia")))]
+fn test_ttyname_invalid_fd() {
+    assert_eq!(ttyname(-1), Err(Errno::EBADF));
+}
+
+#[test]
+#[cfg(any(
+    target_os = "macos",
+    target_os = "ios",
+    target_os = "freebsd",
+    target_os = "openbsd",
+    target_os = "netbsd",
+    target_os = "dragonfly",
+))]
+fn test_getpeereid() {
+    use std::os::unix::net::UnixStream;
+    let (sock_a, sock_b) = UnixStream::pair().unwrap();
+
+    let (uid_a, gid_a) = getpeereid(sock_a.as_raw_fd()).unwrap();
+    let (uid_b, gid_b) = getpeereid(sock_b.as_raw_fd()).unwrap();
+
+    let uid = geteuid();
+    let gid = getegid();
+
+    assert_eq!(uid, uid_a);
+    assert_eq!(gid, gid_a);
+    assert_eq!(uid_a, uid_b);
+    assert_eq!(gid_a, gid_b);
+}
+
+#[test]
+#[cfg(any(
+    target_os = "macos",
+    target_os = "ios",
+    target_os = "freebsd",
+    target_os = "openbsd",
+    target_os = "netbsd",
+    target_os = "dragonfly",
+))]
+fn test_getpeereid_invalid_fd() {
+    // getpeereid is not POSIX, so error codes are inconsistent between different Unices.
+    assert!(getpeereid(-1).is_err());
+}
-- 
2.35.1

